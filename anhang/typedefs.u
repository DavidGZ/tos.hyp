## Hypertext zum TOS-Betriebssystem
## entwickelt fÅr den ST-Guide
##
## Last Edit: 29.08.1998
##
## Kapitel 6: Typdefinitionen


!begin_node Typdefinitionen

In diesem Hypertext finden sich Verweise auf die folgenden Datentypen:

!begin_table [l l l l l]
AESVARS      !! APPLRECORD   !! ARHEADER     !! BASEPAGE     !! BCB
BCONMAP      !! BITBLK       !! BPB          !! CD_DISC_INFO !! CD_TOC_ENTRY
CICON        !! CICONBLK     !! CPXINFO      !! dev_descr    !! DEVDRV
DISKINFO     !! DITHER_MODE  !! DOSTIME      !! DOSVARS      !! DRV_INFO
DSPBLOCK     !! DTA          !! EVNT         !! fcookie      !! FILEPTR
FILESYS      !! fix31        !! FNTS_ITEM    !! FONT_HDR     !! fs_descr
GEM_MUPB     !! GRECT        !! HDFUNCS      !! HNDL_OBJ     !! ICONBLK
IOREC        !! KBDVBASE     !! KEYTAB       !! LBOX_ITEM    !! LINE
ltchars      !! MAPTAB       !! MCB          !! (!link [MD][Memory-Deskriptor (MD)]) !! MEDIA_SIZE
MEDIA_TYPE   !! MENU         !! META_DRVINFO !! META_INFO_1  !! META_INFO_2
META_HEADER  !! MFDB         !! MFORM        !! MN_SET       !! MOUSE
MPB          !! MRETS        !! mutimbuf     !! OBJECT       !! OHEADER
OSHEADER     !! OVERPATCH    !! PARMBLK      !! PBDEF        !! PD
PDLG_SUB     !! PH           !! ploadinfo    !! POPINFO      !! PRN_ENTRY
PRN_MODE     !! PRN_TRAY     !! PRN_SETTINGS !! PRN_SWITCH   !! PUN_INFO
pxyarray     !! RGB_LIST     !! RSHDR        !! SCANX        !! SCREEN
SET_ITEM     !! sgttyb       !! SHELTAIL     !! SLCT_ITEM    !! SWINFO
tchars       !! timeval      !! timezone     !! TEDINFO      !! THREADINFO
USERBLK      !! UTXT_FN      !! winsize      !! XAESMSG      !! XATTR
XCPB         !! XDO_INF      !! XFNT_INFO    !! XFSL_FILTER  !! XSHW_COMMAND
XTED         !! xkey         !! ~      !! ~      !! ~
!end_table



!begin_node AESVARS

!begin_verbatim
typedef struct
{
     int32_t magic;                 /* muû $87654321 sein         */
     void *membot;                  /* Ende der AES- Variablen    */
     void *aes_start;               /* Startadresse               */
     int32_t magic2;                /* ist 'MAGX'                 */
     int32_t date;                  /* Erstelldatum               */
     void (*chgres)(int16_t res, int16_t txt);  /* Auflîsung Ñndern    */
     int32_t (**shel_vector)(void); /* residentes Desktop         */
     int8_t *aes_bootdrv;           /* von hieraus wurde gebootet */
     int16_t *vdi_device;           /* vom AES benutzter Treiber  */
     void *reservd1;                /* reserviert                 */
     void *reservd2;                /* reserviert                 */
     void *reservd3;                /* reserviert                 */
     int16_t version;               /* Version ($0201 ist V2.1)   */
     int16_t release;               /* 0=alpha..3=release         */
} AESVARS;
!end_verbatim

(!B)Hinweis:(!b) Diese Variablen sind READ-ONLY!

Die ersten drei Variablen sind auch unter TOS vorhanden, und kînnen dort
Åber den Betriebssystem-Header ermittelt werden. Die Komponente
(!I)vdi_device(!i) ist ab MagiC-2.0 ÅberflÅssig, weil man die GerÑtenummer
Multi-TOS kompatibel Åber appl_getinfo (Opcode 2) erhÑlt. Die Routine zum
éndern der Auflîsung ((!I)chgres(!i)) erwartet im Register d2 einen
optionalen Falcon-Modus (als int16_t).

Querverweis:
(!link [Cookie von MagiC][Cookie, MagX]) ~  DOMagixAESVars
!end_node


!begin_node Archivheader (ARHEADER)
!label ARHEADER

!begin_verbatim
typedef struct
{
  int8_t a_fname[14];   /* Dateiname                 */
  int32_t a_modti;      /* Zeitpunkt letzter Zugriff */
  int8_t a_userid;      /* unbenutzt                 */
  int8_t a_gid;         /* unbenutzt                 */
  int16_t a_fimode;     /* Filemodus                 */
  int32_t a_fsize;      /* DateilÑnge                */
  int16_t reserved;     /* reserviert                */
} ARHEADER;
!end_verbatim

(!B)Hinweis:(!b) Eine Archivdatei im (!I)Digital-Research-Format(!i) besteht
aus einem Dateikopf, beliebig vielen Dateien (jeweils durch eine
ARHEADER-Struktur eingeleitet) sowie einer Ende-Kennung. Der Dateikopf
besteht dabei lediglich aus dem Wort 0xff65, das Ende der Archivdatei wird
durch den Wert 0x0000 gekennzeichnet.

Querverweis: OHEADER
!end_node



!begin_node Buffer-Control-Block (BCB)
!label BCB

!begin_verbatim
typedef struct _bcb
{
  struct _bcb   *b_link;          /* nÑchster BCB          */
  int16_t       b_negl;           /* auf -1 initialisieren */
  int16_t       b_private[5];     /* unbekannt             */
  void          *b_buf;           /* eigentlicher Puffer   */
} BCB;
!end_verbatim

!end_node


!begin_node CPXINFO

!begin_verbatim
typedef struct
{
    int16_t cdecl (*cpx_call)();
    void cdecl    (*cpx_draw)();
    void cdecl    (*cpx_wmove)();
    void cdecl    (*cpx_timer)();
    void cdecl    (*cpx_key)();
    void cdecl    (*cpx_button)();
    void cdecl    (*cpx_m1)();
    void cdecl    (*cpx_m2)();
    int16_t cdecl (*cpx_hook)();
    void cdecl    (*cpx_close)();
} CPXINFO;
!end_verbatim

Querverweis:
XCONTROL ~  cpx_init
!end_node


!begin_node FlpDrvInfo

Diese Struktur spielt im Zusammenhang mit (!nolink [MagiCMac]) eine Rolle, und ist wie
folgt definiert:

!begin_verbatim
typedef struct
{
   BOOLEAN  inserted;    /* true: disk is inserted and available */
                         /* to GEMDOS/BIOS functions             */
   BOOLEAN  highDensity; /* true: HD disk inserted, false: none  */
                         /* or DD disk inserted                  */
   int16_t    res1;        /* reserved */
   int32_t  res2;        /* reserved */
} FlpDrvInfo;
!end_verbatim

Querverweis:
(!link [Cookie von MagiCMac][Der Cookie von MagiCMac])
!end_node


!iflang [english]
!begin_node GEM_MUPB

Diese Struktur beschreibt den '(!nolink [GEM]) memory usage parameter block', der wie
folgt definiert ist:

!begin_verbatim
typdef struct
{
   int32_t gm_magic;  /* muss 0x87654321 sein                  */
   void *gm_end;      /* Ende des vom GEM benîtigten Speichers */
   void *gm_init;     /* Startadresse von GEM                  */
} GEM_MUPB;
!end_verbatim

See Also:
_sysbase ~  OSHEADER ~  (!link [Systemvariablen][Die Systemvariablen]) ~
(!link [System Vectors][The System Vectors])
!end_node
!else
!begin_node GEM_MUPB

Diese Struktur beschreibt den '(!nolink [GEM]) memory usage parameter block', der wie
folgt definiert ist:

!begin_verbatim
typdef struct
{
   int32_t gm_magic;  /* muss 0x87654321 sein                  */
   void *gm_end;      /* Ende des vom GEM benîtigten Speichers */
   void *gm_init;     /* Startadresse von GEM                  */
} GEM_MUPB;
!end_verbatim

Querverweis:
_sysbase ~  OSHEADER ~  (!link [Systemvariablen][Die Systemvariablen]) ~
(!link [Systemvektoren][Die Systemvektoren])
!end_node
!endif

!begin_node GRECT

!begin_verbatim
typedef struct
{
   int16_t x;   /* x-Koordinate */
   int16_t y;   /* y-Koordinate */
   int16_t w;   /* Breite       */
   int16_t h;   /* Hîhe         */
} GRECT;
!end_verbatim

Querverweis:
AES ~  GEM  ~ VDI
!end_node



!begin_node HDFUNCS

!begin_verbatim
typedef struct
{
    int32_t dma_begin ( void);
    int32_t dma_end   ( void );
    int32_t dma_wait  ( d0 = int32_t ticks_200hz );
    int32_t ncr_begin ( void );
    int32_t ncr_end   ( void );
    int32_t ncr_wait  ( d0 = int32_t ticks_200hz );
} HDFUNCS;
!end_verbatim

(!B)Hinweis:(!b) Direkt vor der Struktur (2 Bytes vorher) liegt ein int16_t,
das die TabellenlÑnge in int32_ts angibt (in diesem Fall 6). Alle 6 Zeiger
liegen im Systemvariablenbereich und dÅrfen notfalls verÑndert werden. Die
internen Funktionen fÅr die Floppy springen ebenfalls Åber die 6 Zeiger.
(!B)Wichtig:(!b) Der Zeiger (!I)hddrv_functions(!i) im MagX-Cookie darf
(!I)nicht(!i) verÑndert werden.

Querverweis: Hintergrund-DMA in MagiC
!end_node


!begin_node MacVersion

Diese Struktur spielt im Zusammenhang mit MagiCMac eine Rolle, und ist wie
folgt definiert:

!begin_verbatim
typedef struct /* 'vers' resource definition, see Inside Mac docs */
{
   int8_t vm;       /* first part of version number in BCD */
   int8_t vn;       /* second and third part of version    */
                    /* number in BCD                       */
   int8_t  vt;      /* development: 0x20, alpha: 0x40,     */
                    /* beta: 0x60, release: 0x80           */
   int8_t  vd;      /* stage of prerelease version         */
   int16_t region;    /* region code                         */
   int8_t  str[];   /* two version strings                 */
} MacVersion;
!end_verbatim

Querverweis: (!link [Cookie von MagiCMac][Der Cookie von MagiCMac])
!end_node


!begin_node Memory-Control-Block (MCB)
!label Speicherverwaltung in MagiC
!label MagiC, Speicherverwaltung in
!label MCB

!begin_verbatim
typedef struct
{
    int32_t mcb_magic;        /* 'ANDR' oder 'KROM' (letzter)    */
    int32_t mcb_len;          /* NettolÑnge                      */
    int32_t mcb_owner;        /* Zeiger auf PD-Struktur          */
    int32_t mcb_prev;         /* vorh. Block oder NULL           */
    int8_t mcb_data[0];
} MCB;
!end_verbatim

(!B)Hinweis:(!b) Die Komponente (!I)mcb_magic(!i) besitzt den Wert 'KROM',
falls kein weiterer MCB folgt, und anderenfalls den Wert 'ANDR'. Im
letzteren Fall liegt der nÑchste MCB (!I)mcb_len(!i) Bytes hinter dem
aktuellen MCB. Die Liste ist per (!I)mcb_prev(!i) rÅckwÑrts verkettet, was
viele Operationen erheblich beschleunigt.

Bei allen Speicheroperationen wird immer die Komponente (!I)mcb_magic(!i)
ÅberprÅft, und das System bei einem Fehler sofort angehalten. Beim Anhalten
aufgrund eines Speicherfehlers werden die Adresse des fehlerhaften MCB sowie
die Daten (4 Langworte) ausgegeben. Anschlieûend wird man gefragt, auf
!label core dump
!label Systemauszug (core dump)
welches Laufwerk man einen (!B)Systemauszug (core dump)(!b) speichern
mîchte. Gibt man ein gÅltiges Laufwerk an, so wird der gesamte ST-Speicher
von 0 bis phystop auf das Wurzelverzeichnis des angegebenen Laufwerks
!label core dump, Name fÅr
geschrieben, und zwar unter dem Namen "_sys_". Die Datei kann natÅrlich je
nach ST-Modell bis zu 4 oder gar 16 MB lang werden.

Speicherresidente Programme (beenden sich Åber Ptermres) arbeiten jetzt im
Gegensatz zu frÅher einfach nur so, daû die Blîcke (!I)nicht(!i) freigegeben
werden, alle MCBs bleiben intakt und werden auch weiterhin benutzt
(jedesmal, wenn man in die MenÅleiste klickt, wird der freie Speicher
ausgegeben, dazu wird die gesamte Liste einmal durchlaufen und dabei alle
MCBs ÅberprÅft).  Wer mîchte, kann also speicherresidente Programme (oder
auch Teile davon) nachtrÑglich freigeben.

Querverweis:
GEMDOS  ~ MagiC ~  (!link [MD][Memory-Deskriptor (MD)]) ~
Speicherverwaltung
!end_node



!begin_node Memory-Deskriptor (MD)
!label Speicherverwaltung in TOS
!label TOS, Speicherverwaltung in

!begin_verbatim
typedef struct md
{
    struct md *m_link;      /* Zeiger auf nÑchsten MD    */
    int32_t      m_start;   /* Anfangsadresse des Blocks */
    int32_t      m_length;  /* LÑnge des Blocks          */
    BASEPAGE  *m_own;       /* Zeiger auf die Basepage   */
} MD;
!end_verbatim

(!B)Hinweis:(!b) Die Komponente (!I)m_own(!i) zeigt dabei auf die Basepage
des Prozesses, dem der Speicherblock gehîrt.

Diese Strukturen werden in der internen Speicherverwaltung von TOS (aber
(!I)nicht(!i) von MagiC!) verwaltet. Diese Deskriptoren, soweit benutzt,
hÑngen in drei Speicherlisten, und zwar fÅr freie Blîcke, belegte Blîcke und
fÅr den nÑchsten zu belegenden Block (mem_rover). Mit dem mem_rover-Konzept
sollte erreicht werden, daû aufeinanderfolgende Malloc-Aufrufe mîglichst
aufeinanderfolgenden Speicher anfordern (wurde an anderer Stelle schon als
Fehler bezeichnet). Damit sollte die Segmentierung verringert werden.

(!B)Diese Idee ist jedoch unbrauchbar, wenn mehrere Programme gleichzeitig
laufen und abwechselnd Mallocs machen(!b). Das von Atari implementierte
Konzept hat den Vorteil, daû es unempfindlich gegen amoklaufende Programme
ist, da die MDs im Systemspeicher liegen, weit weg vom Benutzerspeicher. Ein
bekannter Nachteil des beschriebenen Konzepts ist, daû nur eine sehr
begrenzte Anzahl von (!nolink [Malloc])-Aufrufen mîglich sind, da jeder Aufruf einen MD
des begrenzten Systemspeichers aufzehrt; dieser wird auûerdem noch massiv
von geîffneten Ordnern und Dateien belastet. Ein weiterer Nachteil der
Speicherverwaltung des TOS: Wenn ein Programm einen Speicherblock Åberlaufen
lÑût, d.h. Åber dessen Ende hinausschreibt, bleibt dies i.a. vîllig
unbemerkt.

Besonders im Multitaskingsystem ist die Gefahr eines Åberschriebenen
Speicherblocks ungleich hîher als im TOS. Ferner ist die Anzahl der
benîtigten Speicherblîcke sowie auch die der Ordner (jedes Programm hat
eigene Dateien und Standardverzeichnisse) wesentlich hîher. Aus diesem Grund
hat (!nolink [MagiC]) ein vîllig anderes Konzept; dort gibt es nur noch eine
Speicherliste deren Zeiger auf den ersten MCB zeigt.

Querverweis:
GEMDOS ~  MCB  ~ MPB ~
Speicherverwaltung ~  themd
!end_node



!begin_node MRETS

!begin_verbatim
typedef struct
{
    int16_t x;
    int16_t y;
    int16_t buttons;
    int16_t kstate;
} MRETS;
!end_verbatim

Querverweis:
cpx_button ~  cpx_m1  ~ cpx_m2 ~  XCONTROL
!end_node



!begin_node OHEADER

Diese Struktur beschreibt den Header einer Objektdatei im
(!I)Digital-Research(!i) Format:

!begin_verbatim
typedef struct
{
   int16_t magic;         /* magischer Wert: 0x601a      */
   int32_t tsize;         /* Grîûe des Text-Segments     */
   int32_t dsize;         /* Grîûe des Data-Segments     */
   int32_t bsize;         /* Grîûe der BSS               */
   int32_t ssize;         /* Grîûe der Symboltabelle     */
   int8_t reserved[10];   /* reserviert, auf Null setzen */
} OHEADER;
!end_verbatim

Querverweis:
ARHEADER  ~ BASEPAGE
!end_node



!iflang [english]
!begin_node OSHEADER
!label SYSHDR

!label TOS, Versionsnummer von
!label EmuTOS, Detect
!begin_verbatim
typedef struct _osheader
{
    uint16_t    os_entry;       /* BRAnch-Instruktion zum Reset-Handler */
    uint16_t    os_version;     /* TOS-Versionsnummer                   */
    void       *reseth;         /* Zeiger auf Reset-Handler             */
    struct _osheader *os_beg;   /* Basisadresse des Betriebssystems     */
    void       *os_end;         /* erstes nicht vom BS benutztes Byte   */
    int32_t     os_rsvl;        /* reserviert                           */
    GEM_MUPB   *os_magic;       /* GEM-Memory-Usage-Parameter-Block     */
    int32_t     os_date;        /* TOS-Datum (englisch !) im BCD-Format */
    uint16_t    os_conf;        /* verschiedene Konfigurationsbits      */
    uint16_t    os_dosdate;     /* TOS-Datum im GEMDOS-Format           */

    /* Die folgenden Komponenten stehen erst ab TOS-Version 1.02
       (Blitter-TOS) zur VerfÅgung */
    int8_t    **p_root;         /* Basisadresse des GEMDOS-Pools        */
    int8_t    **pkbshift;       /* Zeiger auf BIOS-Kbshift-Variable
                                   FÅr TOS 1.00 siehe Kbshift           */
    BASEPAGE  **p_run;          /* Adresse der Variablen, die einen
                                   Zeiger auf den aktuellen GEMDOS-
                                   Prozess enthÑlt.
                                   Bei Ñlteren TOS-Versionen ist die
                                   Adresse von p_run 0x602C.            */
    int8_t     *p_rsv2;         /* reserviert                           */

    /* Only available with EmuTOS */
    int8_t      name[4];        /* Always 'ETOS', if EmuTOS present     */
} OSHEADER;
!end_verbatim

Die Struktur tauch auch unter dem Namen SYSHDR auf.

(!B)Hinweis:(!b) Die Komponente (!I)os_conf(!i) enthÑlt im untersten Bit das
sogenannte NTSC/PAL-Flag; ist dieses Bit gesetzt, so handelt es sich um ein
PAL-Videosystem. Die restlichen Bits beinhalten eine LÑnderkennung, die z.B.
dazu dienen kann, die zu benutzende Sprache zu erkennen. Es gilt die
folgende Belegung:

!begin_table [c l]
Value !! Country
~ !! ~
 0 !! USA
 1 !! Germany
 2 !! France
 3 !! England
 4 !! Spanien
 5 !! Italy
 6 !! Schweden
 7 !! franz. Schweiz
 8 !! deutsche Schweiz
 9 !! TÅrkei
10 !! Finnland
11 !! Norwegen
12 !! DÑnemark
13 !! Saudi-Arabien
14 !! Niederlande
15 !! CSSR
16 !! Ungarn
!end_table

(!B)Achtung:(!b) Um die zu benutzende Sprache zu ermitteln, sollte nach
Mîglichkeit (!I)nicht(!i) auf den OSHEADER, sondern auf den
(!link [_AKP][Cookie, _AKP])-Cookie bzw.
auf die Funktion appl_getinfo (Opcode 3) zurÅckgegriffen werden.

See Also:
Kbshift ~  _sysbase ~
(!link [Systemvariablen][Die Systemvariablen]) ~
(!link [System Vectors][The System Vectors])

!end_node
!else
!begin_node OSHEADER
!label SYSHDR

!label TOS, Versionsnummer von
!label EmuTOS, Ermitteln von
!begin_verbatim
typedef struct _osheader
{
    uint16_t    os_entry;       /* BRAnch-Instruktion zum Reset-Handler */
    uint16_t    os_version;     /* TOS-Versionsnummer                   */
    void       *reseth;         /* Zeiger auf Reset-Handler             */
    struct _osheader *os_beg;   /* Basisadresse des Betriebssystems     */
    void       *os_end;         /* erstes nicht vom BS benutztes Byte   */
    int32_t     os_rsvl;        /* reserviert                           */
    GEM_MUPB   *os_magic;       /* GEM-Memory-Usage-Parameter-Block     */
    int32_t     os_date;        /* TOS-Datum (englisch !) im BCD-Format */
    uint16_t    os_conf;        /* verschiedene Konfigurationsbits      */
    uint16_t    os_dosdate;     /* TOS-Datum im GEMDOS-Format           */

    /* Die folgenden Komponenten stehen erst ab TOS-Version 1.02
       (Blitter-TOS) zur VerfÅgung */
    int8_t    **p_root;         /* Basisadresse des GEMDOS-Pools        */
    int8_t    **pkbshift;       /* Zeiger auf BIOS-Kbshift-Variable
                                   FÅr TOS 1.00 siehe Kbshift           */
    BASEPAGE  **p_run;          /* Adresse der Variablen, die einen
                                   Zeiger auf den aktuellen GEMDOS-
                                   Prozess enthÑlt.
                                   Bei Ñlteren TOS-Versionen ist die
                                   Adresse von p_run 0x602C.            */
    int8_t     *p_rsv2;         /* reserviert                           */

    /* Nur verfÅgbar mit EmuTOS */
    int8_t      name[4];        /* Immer 'ETOS', wenn EmuTOS vorhanden  */
} OSHEADER;
!end_verbatim

Die Struktur tauch auch unter dem Namen SYSHDR auf.

(!B)Hinweis:(!b) Die Komponente (!I)os_conf(!i) enthÑlt im untersten Bit das
sogenannte NTSC/PAL-Flag; ist dieses Bit gesetzt, so handelt es sich um ein
PAL-Videosystem. Die restlichen Bits beinhalten eine LÑnderkennung, die z.B.
dazu dienen kann, die zu benutzende Sprache zu erkennen. Es gilt die
folgende Belegung:

!begin_table [c l]
Wert !! Land
~ !! ~
 0 !! USA
 1 !! Deutschland
 2 !! Frankreich
 3 !! England
 4 !! Spanien
 5 !! Italien
 6 !! Schweden
 7 !! franz. Schweiz
 8 !! deutsche Schweiz
 9 !! TÅrkei
10 !! Finnland
11 !! Norwegen
12 !! DÑnemark
13 !! Saudi-Arabien
14 !! Niederlande
15 !! CSSR
16 !! Ungarn
!end_table

(!B)Achtung:(!b) Um die zu benutzende Sprache zu ermitteln, sollte nach
Mîglichkeit (!I)nicht(!i) auf den OSHEADER, sondern auf den
(!link [_AKP][Cookie, _AKP])-Cookie bzw.
auf die Funktion appl_getinfo (Opcode 3) zurÅckgegriffen werden.

Querverweis:
Kbshift ~  _sysbase ~
(!link [Systemvariablen][Die Systemvariablen]) ~
(!link [Systemvektoren][Die Systemvektoren])

!end_node
!endif

!begin_node PrintDesc

Diese Struktur spielt im Zusammenhang mit MagiCMac eine Rolle, und ist wie
folgt definiert:

!begin_verbatim
typedef struct
{
    THPrint printHdl;            /* Printer-Konfiguration fÅr NVDI */
    PrSetupProc doPrintSetup;    /* dto.       */
    VoidProcPtr saveSetup;       /* dto.       */
    int32_t        reserved[7];  /* reserviert */
} PrintDesc;
!end_verbatim

Querverweis:  (!link [Cookie von MagiCMac][Der Cookie von MagiCMac])
!end_node



!begin_node RGB_LIST

!begin_verbatim
typedef struct
{
    uint16_t red;     /* Rot-Anteil  in Promille */
    uint16_t green;   /* GrÅn-Anteil in Promille */
    uint16_t blue;    /* Blau-Anteil in Promille */
} RGB_LIST;
!end_verbatim

Querverweis: (!link [XIMG-Format][Das XIMG-Format fÅr Pixelbilder])
!end_node



!begin_node THREADINFO

!begin_verbatim
typedef struct
{
   int32_t cdecl (*proc)(void *par);
   void *user_stack;
   uint32_t stacksize;
   int16_t mode;
   int32_t res1;
} THREADINFO;
!end_verbatim

(!B)Hinweis:(!b) Ist die Komponente (!I)user_stack(!i) NULL, so legt das
System selbst den Stack an. Wenn der Thread terminiert, wird der Stack
automatisch vom System wieder freigegeben. Die Komponente (!I)stacksize(!i)
ist in jedem Fall anzugeben, damit das System den Stackpointer des Threads
auf das Ende des Stacks setzen kann. Der Systemstapel (Supervisior-Stack)
wird vom Betriebssystem selbst festgelegt, so daû dessen Grîûe nicht
beeinfluût werden kann.

Die Komponenten (!I)mode(!i) und (!I)res1(!i) sind fÅr zukÅnftige Zwecke
reserviert, und sollten deshalb auf den Wert 0 bzw. 0L gesetzt werden. In
Solaris 2.x kann man damit z.B. einen Thread bis zum endgÅltigen Start
anhalten. Der gestartete Thread fÅhrt die Funktion (!I)proc(!i) aus, der als
Parameter die Komponente (!I)par(!i) (auf dem Stack) Åbergeben wird. Die
CPU-Register d0-d2 und a0-a2 dÅrfen von der Funktion verÑndert werden.

Querverweis:
Threads in MagiC ~  shel_write ~
(!link [Beispiel-Code][Threads, Beispiel-Code zu])
!end_node


!begin_node XCPB

!begin_verbatim
typedef struct
{
    int16_t       handle;
    int16_t       booting;
    int16_t       reserved;
    int16_t       SkipRshFix;
    void          *reserve1;
    void          *reserve2;
    void cdecl    (*rsh_fix)      ( int num_objs, int num_frstr, int num_frimg,
                                    int num_tree, OBJECT *rs_object,
                                    TEDINFO *rs_tedinfo, char *rs_strings[],
                                    ICONBLK *rs_iconblk, BITBLK *rs_bitblk,
                                    long *rs_frstr, long *rs_frimg, long *rs_trindex,
                                    struct foobar *rs_imdope );
    void cdecl    (*rsh_obfix)    ( OBJECT *tree, int curob );
    int16_t cdecl (*Popup)        ( char *items[], int num_items, int default_item,
                                    int font_size, GRECT *button, GRECT *world );
    void cdecl    (*Sl_size)      ( OBJECT *tree, int base, int slider, int num_items, 
                                    int visible, int direction, int min_size );
    void cdecl    (*Sl_x)         ( OBJECT *tree, int base, int slider, int value,
                                    int num_min, int num_max, void (*foo)() );
    void cdecl    (*Sl_y)         ( OBJECT *tree, int base, int slider,  int value,
                                    int num_min, int num_max, void (*foo)() );
    void cdecl    (*Sl_arrow)     ( OBJECT *tree, int base, int slider, int obj,
                                    int inc, int min, int max, int *numvar,
                                    int direction, void (*foo)() );
    void cdecl    (*Sl_dragx)     ( OBJECT *tree, int base, int slider,
                                    int min, int max, int *numvar, void (*foo)() );
    void cdecl    (*Sl_dragy)     ( OBJECT *tree, int base, int slider, 
                                    int min, int max, int *numvar, void (*foo)() );
    int16_t cdecl (*Xform_do)     ( OBJECT *tree, int start_field, int puntmsg[] );
    GRECT * cdecl (*GetFirstRect) ( GRECT *prect );
    GRECT * cdecl (*GetNextRect)  ( void );
    void cdecl    (*Set_Evnt_Mask)( int mask, MOBLK *m1, MOBLK *m2, long time );
    int16_t cdecl (*XGen_Alert)   ( int id );
    int16_t cdecl (*CPX_Save)     ( void *ptr, long num );
    void * cdecl  (*Get_Buffer)   ( void );
    int16_t cdecl (*getcookie)    ( long cookie, long *p_value );
    int16_t       Country_Code;
    void cdecl    (*MFsave)       ( int saveit, MFORM *mf );
} XCPB;
!end_verbatim

Querverweis:
cpx_init ~  XCONTROL
!end_node

!end_node
