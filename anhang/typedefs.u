## Hypertext zum TOS-Betriebssystem
## entwickelt fÅr den ST-Guide
##
## Last Edit: 29.08.1998
##
## Kapitel 6: Typdefinitionen


!begin_node Typdefinitionen

In diesem Hypertext finden sich Verweise auf die folgenden Datentypen:

!begin_table [l l l l l]
AESVARS      !! APPLRECORD   !! ARHEADER     !! BASEPAGE     !! BCB
BCONMAP      !! BITBLK       !! BPB          !! CD_DISC_INFO !! CD_TOC_ENTRY
CICON        !! CICONBLK     !! CPXINFO      !! dev_descr    !! DEVDRV
DISKINFO     !! DITHER_MODE  !! DOSTIME      !! DOSVARS      !! DRV_INFO
DSPBLOCK     !! DTA          !! EVNT         !! fcookie      !! FILEPTR
FILESYS      !! fix31        !! FNTS_ITEM    !! FONT_HDR     !! fs_descr
GEM_MUPB     !! GRECT        !! HDFUNCS      !! HNDL_OBJ     !! ICONBLK
IOREC        !! KBDVBASE     !! KEYTAB       !! LBOX_ITEM    !! LINE
ltchars      !! MAPTAB       !! MCB          !! (!link [MD][Memory-Deskriptor (MD)]) !! MEDIA_SIZE
MEDIA_TYPE   !! MENU         !! META_DRVINFO !! META_INFO_1  !! META_INFO_2
META_HEADER  !! MFDB         !! MFORM        !! MN_SET       !! MOUSE
MPB          !! MRETS        !! mutimbuf     !! OBJECT       !! OHEADER
OSHEADER     !! OVERPATCH    !! PARMBLK      !! PBDEF        !! PD
PDLG_SUB     !! PH           !! ploadinfo    !! POPINFO      !! PRN_ENTRY
PRN_MODE     !! PRN_TRAY     !! PRN_SETTINGS !! PRN_SWITCH   !! PUN_INFO
pxyarray     !! RGB_LIST     !! RSHDR        !! SCANX        !! SCREEN
SET_ITEM     !! sgttyb       !! SHELTAIL     !! SLCT_ITEM    !! SWINFO
tchars       !! timeval      !! timezone     !! TEDINFO      !! THREADINFO
USERBLK      !! UTXT_FN      !! winsize      !! XAESMSG      !! XATTR
XCPB         !! XDO_INF      !! XFNT_INFO    !! XFSL_FILTER  !! XSHW_COMMAND
XTED         !! xkey         !! ~      !! ~      !! ~
!end_table



!begin_node AESVARS

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
     int32_t magic;                 /* muû $87654321 sein         */
     void *membot;                  /* Ende der AES- Variablen    */
     void *aes_start;               /* Startadresse               */
     int32_t magic2;                /* ist 'MAGX'                 */
     int32_t date;                  /* Erstelldatum               */
     void (*chgres)(int16_t res, int16_t txt);  /* Auflîsung Ñndern    */
     int32_t (**shel_vector)(void); /* residentes Desktop         */
     int8_t *aes_bootdrv;           /* von hieraus wurde gebootet */
     int16_t *vdi_device;           /* vom AES benutzter Treiber  */
     void *reservd1;                /* reserviert                 */
     void *reservd2;                /* reserviert                 */
     void *reservd3;                /* reserviert                 */
     int16_t version;               /* Version ($0201 ist V2.1)   */
     int16_t release;               /* 0=alpha..3=release         */ 
} AESVARS;
!end_verbatim

(!B)Hinweis:(!b) Diese Variablen sind READ-ONLY!

Die ersten drei Variablen sind auch unter TOS vorhanden, und kînnen dort
Åber den Betriebssystem-Header ermittelt werden. Die Komponente
(!I)vdi_device(!i) ist ab MagiC-2.0 ÅberflÅssig, weil man die GerÑtenummer
Multi-TOS kompatibel Åber appl_getinfo (Opcode 2) erhÑlt. Die Routine zum
éndern der Auflîsung ((!I)chgres(!i)) erwartet im Register d2 einen
optionalen Falcon-Modus (als int16_t).

Querverweis:
(!link [Cookie von MagiC][Cookie, MagX]) ~  DoMagixAESVars
!end_node


!begin_node Archivheader (ARHEADER)
!label ARHEADER
Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
  int8_t a_fname[14];   /* Dateiname                 */
  int32_t a_modti;      /* Zeitpunkt letzter Zugriff */
  int8_t a_userid;      /* unbenutzt                 */
  int8_t a_gid;         /* unbenutzt                 */
  int16_t a_fimode;     /* Filemodus                 */
  int32_t a_fsize;      /* DateilÑnge                */
  int16_t reserved;     /* reserviert                */
} ARHEADER;
!end_verbatim

(!B)Hinweis:(!b) Eine Archivdatei im (!I)Digital-Research-Format(!i) besteht
aus einem Dateikopf, beliebig vielen Dateien (jeweils durch eine
ARHEADER-Struktur eingeleitet) sowie einer Ende-Kennung. Der Dateikopf
besteht dabei lediglich aus dem Wort 0xff65, das Ende der Archivdatei wird
durch den Wert 0x0000 gekennzeichnet.

Querverweis: OHEADER
!end_node



!begin_node Buffer-Control-Block (BCB)
!label BCB
Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct _bcb
{
  struct _bcb   *b_link;          /* nÑchster BCB          */
  int16_t       b_negl;           /* auf -1 initialisieren */
  int16_t       b_private[5];     /* unbekannt             */
  void          *b_buf;           /* eigentlicher Puffer   */
} BCB;
!end_verbatim

!end_node


!begin_node CPXINFO

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
    int16_t cdecl (*cpx_call)();
    void cdecl    (*cpx_draw)();
    void cdecl    (*cpx_wmove)();
    void cdecl    (*cpx_timer)();
    void cdecl    (*cpx_key)();
    void cdecl    (*cpx_button)();
    void cdecl    (*cpx_m1)();
    void cdecl    (*cpx_m2)();
    int16_t cdecl (*cpx_hook)();
    void cdecl    (*cpx_close)();
} CPXINFO;
!end_verbatim

Querverweis:
XCONTROL ~  cpx_init
!end_node


!begin_node fcookie

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct f_cookie
{
    struct filesys *fs; /* Filesystem welches diesen Cookie kennt     */
    USHORT dev;         /* Device-Info (z.B. Rwabs GerÑtenummer)      */
    USHORT aux;         /* weitere Daten fÅr das Filesystem           */
    int32_t   index;    /* dient zusammen mit dev zur Identifizierung */
                        /* eines Files */
} fcookie;
!end_verbatim

Querverweis:
FILEPTR ~  FILESYS ~  (!link [XFS-Konzept in MagiC][Das XFS-Konzept von MagiC])
!end_node



!begin_node FILEPTR

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct fileptr
{
    SHORT   links;
    USHORT  flags;
    int32_t    pos;
    int32_t    devinfo;
    fcookie fc;
    struct devdrv *dev;
    struct fileptr *next;
} FILEPTR;
!end_verbatim

Querverweis:
Dcntl ~  DEVDRV
!end_node


!begin_node FlpDrvInfo

Diese Struktur spielt im Zusammenhang mit (!nolink [MagiCMac]) eine Rolle, und ist wie
folgt definiert:

!begin_verbatim
typedef struct
{
   BOOLEAN  inserted;    /* true: disk is inserted and available */
                         /* to GEMDOS/BIOS functions             */
   BOOLEAN  highDensity; /* true: HD disk inserted, false: none  */
                         /* or DD disk inserted                  */
   SHORT    res1;        /* reserved */
   int32_t  res2;        /* reserved */
} FlpDrvInfo;
!end_verbatim

Querverweis:
(!link [Cookie von MagiCMac][Der Cookie von MagiCMac])
!end_node


!begin_node FONT_HDR
!label Bitmap-Fonts, Header bei

Die folgende Struktur beschreibt den Datei-Header fÅr einen Bitmap
Zeichensatz im (!I)Digital Research(!i) Standardformat. In diesem Format
wird der Font als breites, monochromes Rasterbild organisiert; die Breite
des Rasters ist die Summe aller Zeichenbreiten, die Rasterhîhe entspricht
der Hîhe eines einzelnen Zeichens. (!B)Daraus folgt:(!b) Der linke Rand
eines Zeichens muss (!I)nicht(!i) unbedingt auf eine Bytegrenze fallen; nur
am Ende jeder Rasterzeile wird soweit mit Null-Bits aufgefÅllt, bis der
nÑchste Zeilenbeginn wieder auf eine Wortgrenze fÑllt.

!begin_verbatim
typedef struct font_hdr
{
   int16_t     font_id;        /* Zeichensatz-Nummer                    */
   int16_t     point;          /* Grîûe in Punkten                      */
   int8_t     name[32];        /* Name des Zeichensatzes                */
   uint16_t    first_ade;      /* erstes Zeichen im Zeichensatz         */
   uint16_t    last_ade;       /* letztes Zeichen im Zeichensatz        */
   uint16_t    top;            /* Abstand: Topline     <-> Baseline     */
   uint16_t    ascent;         /* Abstand: Ascentline  <-> Baseline     */
   uint16_t    half;           /* Abstand: Halfline    <-> Baseline     */
   uint16_t    descent;        /* Abstand: Descentline <-> Baseline     */
   uint16_t    bottom;         /* Abstand: Bottomline  <-> Baseline     */
   uint16_t    max_char_width; /* grîûte Zeichenbreite                  */
   uint16_t    max_cell_width; /* grîûte Zeichenzellenbreite            */
   uint16_t    left_offset;    /* linker Offset fÅr Kursivschrift       */
   uint16_t    right_offset;   /* rechter Offset fÅr Kursivschrift      */
   uint16_t    thicken;        /* Verbreiterungsfaktor fÅr Fettschrift  */
   uint16_t    ul_size;        /* Dicke der Unterstreichung             */
   uint16_t    lighten;        /* Maske fÅr helle Schrift (0x5555)      */
   uint16_t    skew;           /* Maske fÅr Kursivschrift (0x5555)      */
   uint16_t    flags;          /* verschiedene Flags:
                                  gesetzt falls System-Font
                                  Bit-1: gesetzt falls Horizontal
                                         Offset-Table benutzt wird
                                  Bit-2: gesetzt falls Motorola-Format
                                  Bit-3: gesetzt falls nicht proport.   */
   uint8_t    *hor_table;      /* Zeiger auf Horizontal-Offset-Table    */
   uint16_t    *off_table;     /* Zeiger auf Character-Offset-Table     */
   uint16_t    *dat_table;     /* Zeiger auf Fontimage                  */
   uint16_t    form_width;     /* Breite des Zeichensatz-Image          */
   uint16_t    form_height;    /* Hîhe des Zeichensatz-Image            */
   font_hdr *next_font;        /* Zeiger auf nÑchsten Font-Header       */
} FONT_HDR;
!end_verbatim

(!B)Hinweis:(!b) Da das (!nolink [GEM]) ursprÅnglich auf dem PC entwickelt wurde, liegen
alle Daten normalerweise im (!I)Intel-Format(!i) vor, so daû auf Maschinen
mit Motorola-Prozessoren bei allen Wîrtern oberes und unteres Byte
vertauscht werden mÅssen. (!B)Achtung:(!b) Um das Motorola/Intel-Flag
(Bit-2 der Komponente (!I)flags(!i)) abfragen zu kînnen, muss eigentlich
schon bekannt sein, in welchem Format der Zeichensatz vorliegt. Die Lîsung
des Problems: Davon ausgehen, dass Bit-10 der Flags niemals benutzt sein
wird, und testen, ob Bit-2 im 67-ten Byte des Headers gesetzt ist (denn dann
liegt der Zeichensatz im Motorola-Format vor).

!label Character-Offset-Table
(!B)Die Character-Offset-Table(!b) besitzt EintrÑge von 16-Bit-Werten, die
den horizontalen Pixeloffset fÅr jedes Zeichen innerhalb des Fontrasters
angibt. Als Index muss man also den ASCII-Code abzÅglich des ASCII-Codes des
ersten Zeichens im Zeichensatz benutzen (Komponente (!I)first_ade(!i)). Die
Breite eines Zeichens ergibt sich aus der Differenz zum Offsetwert des
nÑchsthîheren Zeichens; damit diese Formel auch fÅr das letzte Zeichen
funktioniert, enthÑlt die Tabelle Åbrigens stets einen Eintrag mehr, als
Zeichen verfÅgbar sind.

!label Horizontal-Offset-Table
(!B)Die Horizontal-Offset-Table(!b) enthÑlt positive oder negative
Offsetwerte die vor der Ausgabe eines Zeichens auf die x-Position addiert
werden; sie wird allerdings nur bei wenigen ZeichensÑtzen unterstÅtzt.

Last but not least sei darauf hingewiesen, daû sich eine normale Anwendung
niemals mit diesem Format befassen muû; lediglich fÅr Entwickler von
Zeichensatzeditoren oder GDOS-Versionen sind diese Informationen wichtig.

Querverweis: (!nl)
GDOS          ~     NVDI ~           Speedo-GDOS ~
(!link [Vektorfonts][Details zu Vektorschriften])   ~     vst_alignment  ~ vst_load_fonts ~
vst_unload_fonts ~  vqt_fontheader
!end_node



!begin_node GEM_MUPB

Diese Struktur beschreibt den '(!nolink [GEM]) memory usage parameter block', der wie
folgt definiert ist:

!begin_verbatim
typdef struct
{
   int32_t gm_magic;  /* muss 0x87654321 sein                  */
   void *gm_end;      /* Ende des vom GEM benîtigten Speichers */
   void *gm_init;     /* Startadresse von GEM                  */
} GEM_MUPB;
!end_verbatim

Querverweis:
_sysbase ~  OSHEADER ~  (!link [Systemvariablen][Die Systemvariablen]) ~
(!link [Systemvektoren][Die Systemvektoren])
!end_node


!begin_node GRECT

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
   int16_t x;   /* x-Koordinate */
   int16_t y;   /* y-Koordinate */
   int16_t w;   /* Breite       */
   int16_t h;   /* Hîhe         */
} GRECT;
!end_verbatim

Querverweis:
AES ~  GEM  ~ VDI
!end_node



!begin_node HDFUNCS

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
    int32_t dma_begin ( void);
    int32_t dma_end   ( void );
    int32_t dma_wait  ( d0 = int32_t ticks_200hz );
    int32_t ncr_begin ( void );
    int32_t ncr_end   ( void );
    int32_t ncr_wait  ( d0 = int32_t ticks_200hz );
} HDFUNCS;
!end_verbatim

(!B)Hinweis:(!b) Direkt vor der Struktur (2 Bytes vorher) liegt ein int16_t,
das die TabellenlÑnge in int32_ts angibt (in diesem Fall 6). Alle 6 Zeiger
liegen im Systemvariablenbereich und dÅrfen notfalls verÑndert werden. Die
internen Funktionen fÅr die Floppy springen ebenfalls Åber die 6 Zeiger.
(!B)Wichtig:(!b) Der Zeiger (!I)hddrv_functions(!i) im MagX-Cookie darf
(!I)nicht(!i) verÑndert werden.

Querverweis: Hintergrund-DMA in MagiC
!end_node


!begin_node IOREC

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
   void    *ibuf;           /* Zeiger auf den Buffer   */
   int16_t    ibufsiz;      /* Grîûe des Buffers       */
   int16_t    ibufhd;       /* nÑchste Schreibposition */
   int16_t    ibuftl;       /* nÑchste Leseposition    */
   int16_t    ibuflow;      /* Marke fÅr Xon           */
   int16_t    ibufhi;       /* Marke fÅr Xoff          */
} IOREC;
!end_verbatim

(!B)Hinweis:(!b) FÅr die serielle Schnittstelle schlieût sich direkt ein
entsprechender Puffer fÅr die Ausgabe an. Die beiden letzten Zeiger werden
nur fÅr die serielle Schnittstelle im XON/XOFF bzw. RTS/CTS-Betrieb genutzt.

FÑllt nÑmlich der Pegel unter die untere 'Wassermarke', so wird der Sender
aufgefordert weitere Zeichen zu senden; Åbersteigt er hingegen die obere
'Wassermarke' so wird ihm signalisiert, keine Zeichen mehr zu schicken.

Querverweis: Iorec
!end_node


!begin_node LINE

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
    uint8_t   maxlen;        /* max. ZeilenlÑnge     */
    uint8_t   actuallen;     /* aktuelle ZeilenlÑnge */
    int8_t    buffer[255];   /* Zeilen-Puffer        */
} LINE;
!end_verbatim

Querverweis:
Cconrs  ~ GEMDOS
!end_node


!begin_node MacVersion

Diese Struktur spielt im Zusammenhang mit MagiCMac eine Rolle, und ist wie
folgt definiert:

!begin_verbatim
typedef struct /* 'vers' resource definition, see Inside Mac docs */
{
   int8_t vm;       /* first part of version number in BCD */
   int8_t vn;       /* second and third part of version    */
                    /* number in BCD                       */
   int8_t  vt;      /* development: 0x20, alpha: 0x40,     */
                    /* beta: 0x60, release: 0x80           */
   int8_t  vd;      /* stage of prerelease version         */
   SHORT region;    /* region code                         */
   int8_t  str[];   /* two version strings                 */
} MacVersion;
!end_verbatim

Querverweis: (!link [Cookie von MagiCMac][Der Cookie von MagiCMac])
!end_node


!begin_node Memory-Control-Block (MCB)
!label Speicherverwaltung in MagiC
!label MagiC, Speicherverwaltung in
!label MCB
Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
    int32_t mcb_magic;        /* 'ANDR' oder 'KROM' (letzter)    */
    int32_t mcb_len;          /* NettolÑnge                      */
    int32_t mcb_owner;        /* Zeiger auf PD-Struktur          */
    int32_t mcb_prev;         /* vorh. Block oder NULL           */
    int8_t mcb_data[0];
} MCB;
!end_verbatim

(!B)Hinweis:(!b) Die Komponente (!I)mcb_magic(!i) besitzt den Wert 'KROM',
falls kein weiterer MCB folgt, und anderenfalls den Wert 'ANDR'. Im
letzteren Fall liegt der nÑchste MCB (!I)mcb_len(!i) Bytes hinter dem
aktuellen MCB. Die Liste ist per (!I)mcb_prev(!i) rÅckwÑrts verkettet, was
viele Operationen erheblich beschleunigt.

Bei allen Speicheroperationen wird immer die Komponente (!I)mcb_magic(!i)
ÅberprÅft, und das System bei einem Fehler sofort angehalten. Beim Anhalten
aufgrund eines Speicherfehlers werden die Adresse des fehlerhaften MCB sowie
die Daten (4 Langworte) ausgegeben. Anschlieûend wird man gefragt, auf
!label core dump
!label Systemauszug (core dump)
welches Laufwerk man einen (!B)Systemauszug (core dump)(!b) speichern
mîchte. Gibt man ein gÅltiges Laufwerk an, so wird der gesamte ST-Speicher
von 0 bis phystop auf das Wurzelverzeichnis des angegebenen Laufwerks
!label core dump, Name fÅr
geschrieben, und zwar unter dem Namen "_sys_". Die Datei kann natÅrlich je
nach ST-Modell bis zu 4 oder gar 16 MB lang werden.

Speicherresidente Programme (beenden sich Åber Ptermres) arbeiten jetzt im
Gegensatz zu frÅher einfach nur so, daû die Blîcke (!I)nicht(!i) freigegeben
werden, alle MCBs bleiben intakt und werden auch weiterhin benutzt
(jedesmal, wenn man in die MenÅleiste klickt, wird der freie Speicher
ausgegeben, dazu wird die gesamte Liste einmal durchlaufen und dabei alle
MCBs ÅberprÅft).  Wer mîchte, kann also speicherresidente Programme (oder
auch Teile davon) nachtrÑglich freigeben.

Querverweis:
GEMDOS  ~ MagiC ~  (!link [MD][Memory-Deskriptor (MD)]) ~
Speicherverwaltung
!end_node



!begin_node Memory-Deskriptor (MD)
!label Speicherverwaltung in TOS
!label TOS, Speicherverwaltung in

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct md
{
    struct md *m_link;      /* Zeiger auf nÑchsten MD    */
    int32_t      m_start;   /* Anfangsadresse des Blocks */
    int32_t      m_length;  /* LÑnge des Blocks          */
    BASEPAGE  *m_own;       /* Zeiger auf die Basepage   */
} MD;
!end_verbatim

(!B)Hinweis:(!b) Die Komponente (!I)m_own(!i) zeigt dabei auf die Basepage
des Prozesses, dem der Speicherblock gehîrt.

Diese Strukturen werden in der internen Speicherverwaltung von TOS (aber
(!I)nicht(!i) von MagiC!) verwaltet. Diese Deskriptoren, soweit benutzt,
hÑngen in drei Speicherlisten, und zwar fÅr freie Blîcke, belegte Blîcke und
fÅr den nÑchsten zu belegenden Block (mem_rover). Mit dem mem_rover-Konzept
sollte erreicht werden, daû aufeinanderfolgende Malloc-Aufrufe mîglichst
aufeinanderfolgenden Speicher anfordern (wurde an anderer Stelle schon als
Fehler bezeichnet). Damit sollte die Segmentierung verringert werden.

(!B)Diese Idee ist jedoch unbrauchbar, wenn mehrere Programme gleichzeitig
laufen und abwechselnd Mallocs machen(!b). Das von Atari implementierte
Konzept hat den Vorteil, daû es unempfindlich gegen amoklaufende Programme
ist, da die MDs im Systemspeicher liegen, weit weg vom Benutzerspeicher. Ein
bekannter Nachteil des beschriebenen Konzepts ist, daû nur eine sehr
begrenzte Anzahl von (!nolink [Malloc])-Aufrufen mîglich sind, da jeder Aufruf einen MD
des begrenzten Systemspeichers aufzehrt; dieser wird auûerdem noch massiv
von geîffneten Ordnern und Dateien belastet. Ein weiterer Nachteil der
Speicherverwaltung des TOS: Wenn ein Programm einen Speicherblock Åberlaufen
lÑût, d.h. Åber dessen Ende hinausschreibt, bleibt dies i.a. vîllig
unbemerkt.

Besonders im Multitaskingsystem ist die Gefahr eines Åberschriebenen
Speicherblocks ungleich hîher als im TOS. Ferner ist die Anzahl der
benîtigten Speicherblîcke sowie auch die der Ordner (jedes Programm hat
eigene Dateien und Standardverzeichnisse) wesentlich hîher. Aus diesem Grund
hat (!nolink [MagiC]) ein vîllig anderes Konzept; dort gibt es nur noch eine
Speicherliste deren Zeiger auf den ersten MCB zeigt.

Querverweis:
GEMDOS ~  MCB  ~ MPB ~
Speicherverwaltung ~  themd
!end_node



!begin_node MEDIA_SIZE

Diese Struktur dient der Beschreibung eines Papierformates, und ist wie
folgt definiert:

!begin_verbatim
typedef struct _media_size   
{
   struct _media_size *next;   /* Zeiger auf Nachfolger     */
   int32_t        size_id;     /* Kennung des Papierformats */
   int8_t        name[32];     /* Name des Papierformats    */
} MEDIA_SIZE;
!end_verbatim

Querverweis:
Druckdialoge ~  pdlg_add_printers
!end_node



!begin_node MEDIA_TYPE

Diese Struktur dient der Beschreibung eines Papiertyps bzw. Druckmediums,
und ist wie folgt definiert:

!begin_verbatim
typedef struct _media_type        
{
   struct _media_type   *next;   /* Zeiger auf Nachfolger     */
   int32_t        type_id;       /* Kennung des Papierformats */
   int8_t        name[32];       /* Name des Papierformats    */
} MEDIA_TYPE;
!end_verbatim

Querverweis:
Druckdialoge ~  pdlg_add_printers
!end_node



!begin_node MRETS

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
    int16_t x;
    int16_t y;
    int16_t buttons;
    int16_t kstate;
} MRETS;
!end_verbatim

Querverweis:
cpx_button ~  cpx_m1  ~ cpx_m2 ~  XCONTROL
!end_node


!begin_node mutimbuf

Diese Struktur ist wie folgt definiert:

!begin_verbatim
struct mutimbuf
{
   uint16_t actime;     /* Zugriffszeit                 */
   uint16_t acdate;     /* Zugriffsdatum                */
   uint16_t modtime;    /* Uhrzeit der letzten énderung */
   uint16_t moddate;    /* Datum der letzten énderung   */
};
!end_verbatim

Querverweis:
Dcntl  ~ Fcntl ~  GEMDOS
!end_node



!begin_node OHEADER

Diese Struktur beschreibt den Header einer Objektdatei im
(!I)Digital-Research(!i) Format:

!begin_verbatim
typedef struct
{
   int16_t magic;         /* magischer Wert: 0x601a      */
   int32_t tsize;         /* Grîûe des Text-Segments     */
   int32_t dsize;         /* Grîûe des Data-Segments     */
   int32_t bsize;         /* Grîûe der BSS               */
   int32_t ssize;         /* Grîûe der Symboltabelle     */
   int8_t reserved[10];   /* reserviert, auf Null setzen */
} OHEADER;
!end_verbatim

Querverweis:
ARHEADER  ~ BASEPAGE
!end_node



!begin_node OSHEADER
!label SYSHDR

Diese Struktur ist wie folgt definiert:

!label TOS, Versionsnummer von
!begin_verbatim
typedef struct _osheader
{
    uint16_t    os_entry;       /* BRAnch-Instruktion zum Reset-Handler */
    uint16_t    os_version;     /* TOS-Versionsnummer                   */
    void     *reseth;           /* Zeiger auf Reset-Handler             */
    struct _osheader *os_beg;   /* Basisadresse des Betriebssystems     */
    void     *os_end;           /* erstes nicht vom BS benutztes Byte   */
    int32_t     os_rsvl;        /* reserviert                           */
    GEM_MUPB *os_magic;         /* GEM-Memory-Usage-Parameter-Block     */
    int32_t     os_date;        /* TOS-Datum (englisch !) im BCD-Format */
    uint16_t    os_conf;        /* verschiedene Konfigurationsbits      */
    uint16_t    os_dosdate;     /* TOS-Datum im GEMDOS-Format           */
    /* Die folgenden Komponenten stehen erst ab TOS-Version 1.02
       (Blitter-TOS) zur VerfÅgung */
    int8_t     **p_root;        /* Basisadresse des GEMDOS-Pools        */
    int8_t     **pkbshift;      /* Zeiger auf BIOS-Kbshift-Variable     */
    BASEPAGE **p_run;           /* Adresse der Variablen, die einen
                                   Zeiger auf den aktuellen GEMDOS-
                                   Prozess enthÑlt.                     */
    int8_t     *p_rsv2;         /* reserviert                           */
} OSHEADER;
!end_verbatim

Die Struktur tauch auch unter dem Namen SYSHDR auf.

(!B)Hinweis:(!b) Die Komponente (!I)os_conf(!i) enthÑlt im untersten Bit das
sogenannte NTSC/PAL-Flag; ist dieses Bit gesetzt, so handelt es sich um ein
PAL-Videosystem. Die restlichen Bits beinhalten eine LÑnderkennung, die z.B.
dazu dienen kann, die zu benutzende Sprache zu erkennen. Es gilt die
folgende Belegung:

!begin_table [c l]
Wert !! Land
~ !! ~
 0 !! USA
 1 !! Deutschland
 2 !! Frankreich
 3 !! England
 4 !! Spanien
 5 !! Italien
 6 !! Schweden
 7 !! franz. Schweiz
 8 !! deutsche Schweiz
 9 !! TÅrkei
10 !! Finnland
11 !! Norwegen
12 !! DÑnemark
13 !! Saudi-Arabien
14 !! Niederlande
15 !! CSSR
16 !! Ungarn
!end_table

(!B)Achtung:(!b) Um die zu benutzende Sprache zu ermitteln, sollte nach
Mîglichkeit (!I)nicht(!i) auf den OSHEADER, sondern auf den _AKP-Cookie bzw.
auf die Funktion appl_getinfo (Opcode 3) zurÅckgegriffen werden.

Querverweis: 
Kbshift ~  _sysbase ~ 
(!link [Systemvariablen][Die Systemvariablen]) ~
(!link [Systemvektoren][Die Systemvektoren])

!end_node


!begin_node PrintDesc

Diese Struktur spielt im Zusammenhang mit MagiCMac eine Rolle, und ist wie
folgt definiert:

!begin_verbatim
typedef struct
{
    THPrint printHdl;            /* Printer-Konfiguration fÅr NVDI */
    PrSetupProc doPrintSetup;    /* dto.       */
    VoidProcPtr saveSetup;       /* dto.       */
    int32_t        reserved[7];  /* reserviert */
} PrintDesc;
!end_verbatim

Querverweis:  (!link [Cookie von MagiCMac][Der Cookie von MagiCMac])
!end_node



!begin_node RGB_LIST

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
    uint16_t red;     /* Rot-Anteil  in Promille */
    uint16_t green;   /* GrÅn-Anteil in Promille */
    uint16_t blue;    /* Blau-Anteil in Promille */
} RGB_LIST;
!end_verbatim

Querverweis: (!link [XIMG-Format][Das XIMG-Format fÅr Pixelbilder])
!end_node



!begin_node RSHDR
!label Resource-Header
!label Resource-Kopf
!label Header einer Resource-Datei
!label Kopf einer Resource-Datei

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
   uint16_t rsh_vrsn;      /* Null                              */
   uint16_t rsh_object;    /* Position des Objekt-Feldes        */
   uint16_t rsh_tedinfo;   /* Position der TEDINFO-Strukturen   */
   uint16_t rsh_iconblk;   /* Position der ICONBLK-Strukturen   */
   uint16_t rsh_bitblk;    /* Position der BITBLK-Strukturen    */
   uint16_t rsh_frstr;     /* Position der freien Strings       */
   uint16_t rsh_string;    /* unbenutzt                         */
   uint16_t rsh_imdata;    /* Position der Image-Daten          */
   uint16_t rsh_frimg;     /* Position der freien Images        */
   uint16_t rsh_trindex;   /* Position der Objektbaumtabelle    */
   uint16_t rsh_nobs;      /* Gesamtzahl der Objekte            */
   uint16_t rsh_ntree;     /* Gesamtzahl der ObjektbÑume        */
   uint16_t rsh_nted;      /* Gesamtzahl der TEDINFO-Strukturen */
   uint16_t rsh_nib;       /* Gesamtzahl der ICONBLK-Strukturen */
   uint16_t rsh_nbb;       /* Gesamtzahl der BITBLK-Strukturen  */
   uint16_t rsh_nstring;   /* Gesamtzahl der Strings            */
   uint16_t rsh_nimages;   /* Gesamtzahl der Images             */
   uint16_t rsh_rssize;    /* GesamtlÑnge der RSC-Datei         */
} RSHDR;
!end_verbatim

(!B)Hinweis:(!b) Alle Positionsangaben sind relativ zum Dateianfang zu
verstehen. Noch ein Wort zu den 'freien Strings': zu diesen gehîren nicht
nur die Zeichenketten, in denen sich die Daten fÅr die Alarmboxen befinden,
sondern auch alle anderen Strings, die ein Programm zu seiner Arbeit
benutzt. Ein Beispiel dafÅr wÑre der Dateiname einer einzulesenden Datei
oder ein Eintrag, der mit menu_text in einem MenÅ vorgenommen wird.

!label Resourcedateien, Grîûe von
Diesem Kopf folgen die eigentlichen Resource-Daten. Man beachte dabei, daû
eine Resource-Datei aufgrund der Verwendung von 16-Bit-Werten als Zeiger nur
eine Gesamtgrîûe von (!I)maximal 64 Kbyte(!i) erreichen kann. Dateien dieses
Formats werden von allen RCS-Programmen abgespeichert. Anwender des
Programms Interface kînnen auch mit Resource-Dateien > 64 Kbyte arbeiten.
Auch das Betriebssystem MagiC unterstÅtzt ab Version 3 Resourcedateien von
mehr als 64 Kbyte; das Laden der Resource erfolgt wie Åblich per rsrc_load,
der Rest wird vîllig transparent vom System Åbernommen.

Querverweis: rsrc_rcfix
!end_node


!begin_node SHELTAIL

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
    int16_t dummy;       /* ein Nullwort               */
    int32_t magic;       /* 'SHEL', wenn Shell...      */
    int16_t isfirst;     /* erster Aufruf der Shell    */
    int32_t lasterr;     /* letzter Fehler             */
    int16_t wasgr;       /* Programm war Grafikapp.    */
} SHELTAIL;
!end_verbatim

(!B)Hinweis:(!b) Diese Informationen bekommt ein alternatives Desktop von
MagiC beim Programmstart Åbermittelt (per shel_read zu ermitteln). Gibt die
Shell einen negativen Fehlercode zurÅck, so wird MAGXDESK wieder aktiviert.

Wenn die Komponente (!I)isfirst(!i) gesetzt ist, ist der Status etwa aus der
DESKTOP.INF-Datei zu lesen, anderenfalls aus einer temporÑren Datei bzw. dem
Shell-Puffer. Die Komponente (!I)lasterr(!i) entspricht dem RÅckgabewert des
vorher gelaufenen Programms. Wenn dies ein GEM-Programm war, ist der Fehler
bereits per Alertbox angezeigt worden. Das Langwort ist negativ, wenn der
Fehler beim Pexec selbst auftrat; ein Programm-RÅckgabewert besitzt immer
ein High-Word von 0.

Querverweis:
AES  ~ GEM  ~ shel_wdef
!end_node


!begin_node struct tty

Diese Struktur ist wie folgt definiert:

!begin_verbatim
struct tty
{
    SHORT           pgrp;
    SHORT           state;
    SHORT           use_cnt;
    SHORT           res1;
    struct sgttyb   sg;
    struct tchars   tc;
    struct ltchars  ltc;
    struct winsize  wsiz;
    int32_t         rsel;
    int32_t         wsel;
    int8_t          *xkey;
    int32_t         hup_ospeed;
    USHORT          vmin, vtime;
    int32_t         resrvd[1];
};
!end_verbatim

Querverweis:
Dcntl ~  dev_descr ~  (!link [XFS-Konzept in MagiC][Das XFS-Konzept von MagiC])
!end_node



!begin_node THREADINFO

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
   int32_t cdecl (*proc)(void *par);
   void *user_stack;
   uint32_t stacksize;
   int16_t mode;
   int32_t res1;
} THREADINFO;
!end_verbatim

(!B)Hinweis:(!b) Ist die Komponente (!I)user_stack(!i) NULL, so legt das
System selbst den Stack an. Wenn der Thread terminiert, wird der Stack
automatisch vom System wieder freigegeben. Die Komponente (!I)stacksize(!i)
ist in jedem Fall anzugeben, damit das System den Stackpointer des Threads
auf das Ende des Stacks setzen kann. Der Systemstapel (Supervisior-Stack)
wird vom Betriebssystem selbst festgelegt, so daû dessen Grîûe nicht
beeinfluût werden kann.

Die Komponenten (!I)mode(!i) und (!I)res1(!i) sind fÅr zukÅnftige Zwecke
reserviert, und sollten deshalb auf den Wert 0 bzw. 0L gesetzt werden. In
Solaris 2.x kann man damit z.B. einen Thread bis zum endgÅltigen Start
anhalten. Der gestartete Thread fÅhrt die Funktion (!I)proc(!i) aus, der als
Parameter die Komponente (!I)par(!i) (auf dem Stack) Åbergeben wird. Die
CPU-Register d0-d2 und a0-a2 dÅrfen von der Funktion verÑndert werden.

Querverweis:
Threads in MagiC ~  shel_write ~
(!link [Beispiel-Code][Threads, Beispiel-Code zu])
!end_node



!begin_node USERBLK

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
   int16_t cdecl (*ub_code)(PARMBLK *parmblock);
   int32_t ub_parm;
} USERBLK;
!end_verbatim

(!B)Hinweis:(!b) Die Funktion (!I)ub_code(!i) wird bei jedem Aufruf von
objc_draw und objc_change fÅr das entsprechende Objekt aufgerufen. Die
Komponente (!I)ub_parm(!i) kann als optionaler Parameter angesehen werden.
!end_node



!begin_node UTXT_FN

Diese Funktion ist wie folgt deklariert:

!begin_verbatim
typedef void (cdecl *UTXT_FN) (int16_t x, int16_t y, int16_t *clip_rect, 
                               int32_t id, int32_t pt, int32_t ratio, 
                               int8_t *string);
!end_verbatim

Querverweis:
AES  ~ fnts_add ~  FNTS_ITEM  ~ Zeichensatzauswahl
!end_node


!begin_node XAESMSG

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct 
{
   int16_t  dst_apid;       /* ID der Ziel-Applikation    */
   int16_t  unique_flg;     /* Nachrichten Åberschreiben? */
   void     *attached_mem;  /* Zeiger auf Speicherblock   */
   int16_t  *msgbuf;        /* Nachrichenpuffer           */ 
} XAESMSG;
!end_verbatim

(!B)Hinweis:(!b) Die Komponente (!I)unique_flg(!i) gibt an, ob gleichartige
Nachrichten (d.h. solche mit gleichem Nachrichtentyp msgbuf[0]) von der
neuen Nachricht Åberschrieben werden sollen.

Wenn (!I)attached_mem(!i) nicht NULL ist, wird damit ein per Malloc
allozierter Speicherblock angegeben, der die erweiterten
(!nolink [Nachrichten])-Informationen enthÑlt. Die LÑnge dieses Blocks ist beliebig und
fÅr das System uninteressant, sie kînnte z.B. als erstes Langwort des Blocks
oder in (!I)msgbuf(!i) [4,5] Åbergeben werden. Das System weist den
Speicherblock der Zielapplikation zu und Åbermittelt dessen Adresse in
msgbuf[6,7].

(!B)Wichtig:(!b) Die aufrufende Applikation muû davon ausgehen, daû
(!I)msgbuf[6,7](!i) nach dem Aufruf von appl_write zerstîrt sind. Das System
behÑlt sich vor, den Inhalt des Speicherblocks umzukopieren und den
Åbergebenen Block freizugeben. Der Aufrufer darf nach dem (!nolink [appl_write])
(!B)nicht mehr(!b) auf den Block zugreifen und ihn auf gar keinen Fall
freigeben!

Gibt appl_write einen Fehlercode zurÅck, so ist der Block (!I)nicht(!i)
Åbergeben worden und gehîrt nach wie vor der aufrufenden Applikation. Ein
Fehler tritt dann auf, wenn:

!begin_itemize
!item die Zielapplikation ungÅltig (nicht existent oder eingefroren) ist
!item der Nachrichtenpuffer der Zielapplikation voll ist
!item die Zielapplikation kein Prozeû ist (z.B. der (!link [SCRENMGR][Der Screen-Manager]))
      und ein attached memory block angegeben worden ist.
!end_itemize

Querverweis:
AES  ~ appl_write ~  GEM
!end_node


!begin_node XCPB

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
    int16_t        handle;
    int16_t        booting;
    int16_t        reserved;  
    int16_t        SkipRshFix;
    void           *reserve1;
    void           *reserve2;
    void cdecl     (*rsh_fix)();
    void cdecl     (*rsh_obfix)();
    int16_t cdecl  (*Popup)();
    void cdecl     (*Sl_size)();
    void cdecl     (*Sl_x)();
    void cdecl     (*Sl_y)();
    void cdecl     (*Sl_arrow)();
    void cdecl     (*Sl_dragx)();
    void cdecl     (*Sl_dragy)();
    int16_t cdecl  (*Xform_do)();
    GRECT * cdecl  (*GetFirstRect)();
    GRECT * cdecl  (*GetNextRect)();
    void cdecl     (*Set_Evnt_Mask)();
    int16_t cdecl  (*XGen_Alert)();
    int16_t cdecl  (*CPX_Save)();
    void cdecl *   (*Get_Buffer)();
    int16_t cdecl  (*getcookie)();
    int16_t        Country_Code; 
    void cdecl     (*MFsave)();
} XCPB;
!end_verbatim

Querverweis:
cpx_init ~  XCONTROL
!end_node


!begin_node XSHW_COMMAND

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
   int8_t  *command;
   int32_t limit;
   int32_t nice;
   int8_t  *defdir;
   int8_t  *env;
} XSHW_COMMAND;
!end_verbatim

Querverweis: shel_write
!end_node



!begin_node XTED

Diese Struktur wird im Zusammenhang mit scrollbaren Texteditfeldern
benîtigt, und ist wie folgt definiert:

!begin_verbatim
typedef struct _xted
{
   int8_t  *xte_ptmplt;
   int8_t  *xte_pvalid;
   int16_t xte_vislen;
   int16_t xte_scroll;
} XTED;
!end_verbatim

Querverweis:
(!link [Scrollende Eingabefelder][scrollende Eingabefelder]) ~  TEDINFO
!end_node


!end_node

