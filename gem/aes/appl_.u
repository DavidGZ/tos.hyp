## Hypertext zum TOS-Betriebssystem
## entwickelt fÅr den ST-Guide
##
## Last Edit: 29.08.1998
##
## Kapitel 4: AES-Applikationsbibliothek



!begin_node appl_bvset
(!begin_liste) [Beschreibung:]
!item [Name:]
ØApplication Bitvektor-SetÆ - setzt die angeschlossenen logischen
Laufwerke fÅr die Dateiauswahlbox
!item [AES-Nummer:]
16
!item [Binding:]
(!link [Bindings fÅr appl_bvset] [Bindings fÅr appl_bvset])
!item [Beschreibung:]
Die Funktion informiert das GEM Åber die vorhandenen logischen Laufwerke,
die u.a. fÅr die Dateiauswahl-box (Fileselector) benîtigt werden. Es gilt:
!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [bvdisk]
Bitvektor der vorhandenen Diskettenlaufwerke (Bit-15 = Laufwerk-A etc).
!item [bvhard]
Bitvektor der vorhandenen Festplattenlaufwerke (Bit-15 = Laufwerk-A etc).
!end_xlist
(!B)Hinweis:(!b) Die Funktion steht erst ab PC-GEM Version 2.0 zur VerfÅgung.
!item [Ergebnis:]
Der RÅckgabewert der Funktion ist z.Zt. nicht bekannt.
!item [Gruppe:]
Applikationen
!item [Querverweis:]
Dsetdrv
(!ende_liste)



!begin_node Bindings fÅr appl_bvset
!ignore_index
(!begin_liste) [Implementierung:]
!item [C:]
WORD appl_bvset ( UWORD bvdisk, UWORD bvhard );
!item [Implementierung:]
!begin_verbatim
WORD appl_bvset (UWORD bvdisk, UWORD bvhard)
{
   int_in[0]  = bvdisk;
   int_in[1]  = bvhard;
   return ( crys_if(16) );	
}
!end_verbatim
!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
control !! control[0] !! 16    Opcode der Funktion
control+2 !! control[1] !! 2     # EintrÑge in int_in
control+4 !! control[2] !! 1     # EintrÑge in int_out
control+6 !! control[3] !! 0     # EintrÑge in addr_in
control+8 !! control[4] !! 0     # EintrÑge in addr_out
int_in !! int_in[0] !! bvdisk
int_in+2 !! int_in[1] !! bvhard
int_out !! int_out[0] !! Return-Wert
!end_table
(!ende_liste)
!end_node
!end_node



!begin_node appl_control
(!begin_liste) [Beschreibung:]
!item [Name:]
Gezieltes Steuern von Anwendungen.
!item [AES-Nummer:]
129
!item [Binding:]
(!link [Bindings fÅr appl_control] [Bindings fÅr appl_control])
!item [Beschreibung:]
Die Funktion erlaubt ein gezieltes Steurern von Anwendungen.
!begin_xlist [Parameter]
!item [Parameter]
Bedeutung

!item [ap_cid]
Die Applikationsidentifikation (apid) der Anwendung, die gesteuert
werden soll.

!item [ap_cwhat]
Die Art der Steuerung:

!begin_xlist [APC_WIDGETS ]

!item [0 bis 9]              reserviert fÅr N.AES

!label APC_HIDE
!item [APC_HIDE (10)]         Applikation ausblenden (!nl)
                     Wird fÅr ap_cid -1 Åbergeben, so wird die 
                     aktuelle Anwendung ausgeblendet.

!label APC_SHOW
!item [APC_SHOW (11)]         Applikation einblenden (!nl)
                     Wird fÅr ap_cid -1 Åbergeben, so werden alle
                     ausgeblendeten Anwendungen eingeblendet.

!label APC_TOP
!item [APC_TOP (12)]          Applikation in den Vordergrund bringen (zur 
                     aktuellen Anwendung machen).

!label APC_HIDENOT
!item [APC_HIDENOT(13)]      Ausblenden aller Anwendungen bis auf die in 
                     ap_cid angegebene, welche zur neuen aktu- 
                     ellen Anwendung wird.
                     Wird fÅr ap_cid -1 Åbergeben, so werden alle
                     Anwendungen bis auf die aktuelle 
                     ausgeblendet.

!label APC_INFO
!item [APC_INFO(14)]         Abfragen von Applikationsparametern der An- 
                     wendung ap_cid. Wird fÅr ap_cid -1 
                     Åbergeben, so werden die Parameter der aktu-
                     ellen Anwendung geliefert.

                     FÅr ap_cout ist ein Zeiger auf einen Integer
                     zu Åbergeben. N.AES hinterlegt hier die 
                     Applikationsparameter in Form einer 
                     Bitmaske:

										 !begin_xlist  [APCI_HIDD]
										 !label APCI_HIDDEN
                     !item [APCI_HIDDEN (1)]     Bit 0 ist gesetzt, wenn 
                                        die Applikation 
                                        ausgeblendet ist.

										 !label APCI_HASMBAR
                     !item [APCI_HASMBAR (2)]    Bit 1 ist gesetzt, wenn 
                                        die Applikation eine 
                                        MenÅleiste besitzt.

										 !label APCI_HASDESK
                     !item [APCI_HASDESK (4)]    Bit 2 ist gesetzt, wenn 
                                        die Applikation einen 
                                         eigenen Desktop besitzt.
										!end_xlist
!label APC_MENU
!item [APC_MENU(15)]         Liefert die Adresse des MenÅbaums, den die 
                     Anwendung ap_cid zuletzt angemeldet hat. 
                     Hierzu ist fÅr ap_cout ein Zeiger auf einen 
                     OBJECT-Zeiger zu Åbergeben; letzterer wird 
                     vom N.AES mit der gesuchten MenÅbaumadresse 
                     gefÅllt.

                     Wird fÅr ap_cid -1 Åbergeben, so wird die 
                     MenÅbaumadresse der aktuellen Anwendung 
                     geliefert. öbergibt man fÅr ap_cid den Wert 
                     0, so wird die Adresse des vom (!nolink [N.AES]) intern 
                     verwalteten SystemmenÅs geliefert. Dies ist 
                     die MenÅbox, die aufklappt, wenn man den am 
                     weitesten links stehenden MenÅtitel anwÑhlt 
                     und welche die Liste aller beim N.AES 
                     angemeldeten Anwendungen und Accessories 
                     enthÑlt.

                     Hat die abgefragte Anwendung keine 
                     MenÅleiste angemeldet oder existiert keine 
                     Anwendung mit der Identifikation ap_cid, so 
                     wird ein Nullzeiger nach ap_cout 
                     geschrieben.

                     Der RÅckgabewert von appl_control, Modus 
                                    APC_MENU ist immer der Wert 1.

                                    Hinweis:
                                    Wenn man diesen Modus verwendet, sollte man 
                                    sich ganz sicher sein, was man tut! Das 
                                    VerÑndern des gelieferten MenÅbaums kann zu 
                                    undefinierten SystemzustÑnden fÅhren. Bei 
                                    aktivem MiNT-Speicherschutz kann bereits ein
                                    Lesezugriff auf den MenÅbaum den Abbruch der
                                    Anwendung bewirken.

!label APC_WIDGETS
!item [APC_WIDGETS (16)]      Erfragt oder setzt die 'default' Positionen 
                                    der Fensterobjekte. (!I)ap_cout(!i) ist ein Zeiger 
!label MINWINOBJ
                                    auf einen MINWINOBJ(12) groûen (WORD) 
                                    Buffer, der zum abfragen der 
                                    Objektreihenfolge komplett mit -1 gefÅllt 
                                    sein muû. Das letzte Word muû eine 0 sein. 
                                    Wird eine Fehlermeldung zurÅckgeliefert 
                                    reicht der Buffer nicht fÅr alle Objekte und
                                    sollte vergrîûert werden. Im Buffer liegen 
                                    als erstes die Objekte der Titelleiste von 
                                    links nach rechts, danach die Objekte des 
                                    Vertikalsliders von oben nach unten und dann
                                    die Objekte des Horizontalsliders von links 
                                    nach rechts. Abgeschlossen wird die Liste 
                                    mit einem 0 Word. Zum setzen der Positionen 
                                    mÅûen die ersten Objekte vom Typ topwidgets 
                                    sein (von links nach rechts), danach die 
                                    Objekte des Typs rightwidgets (von oben nach 
                                    unten) und dann die Objekte des Typs 
                                    bottomwidgets (von links nach rechts). 
                                    Sollten Objekte doppelt oder falsch gesetzt 
                                    sein wird ein Fehler gemeldet.
!end_xlist

!item [ap_cout]     Wird abhÑngig von (!I)ap_cwhat(!i) gefÅllt oder gelesen und hat nur fÅr 
              APC_INFO, APC_MENU und APC_WIDGETS eine Bedeutung. In den anderen 
              FÑllen wird dieser Parameter ignoriert, die öbergabe eines 
              Nullzeigers ist dann mîglich.

!end_xlist

(!B)Hinweis:(!b)
Ausgeblendeten Anwendungen wird in der MenÅleiste ein '*' vorangestellt, es sei 
denn, sie hatten im Moment der Ausblendung kein Fenster offen. In diesem Fall 
wird nur die Anwendung gewechselt.

Der '*' vor dem Namen bedeutet genau: Einige oder alle geîffneten Fenster dieser
Anwendung sind ausgeblendet.

Das Vorhandensein der Funktion ist Åber (!link [appl_getinfo][%apgi_65]) (Opcode 65)
nachprÅfbar.

!item [Ergebnis:]
~0 = ein Fehler ist aufgetreten (!nl)
>0 = kein Fehler aufgetreten

!item [Gruppe:]
(!link [Applikationen][Applikationsfunktionen])

#!item [Querverweis:]
(!ende_liste)



!begin_node Bindings fÅr appl_control
!ignore_index
(!begin_liste) [Implementierung:]
!item [C:]
WORD appl_control ( WORD ap_cid, WORD ap_cwhat, VOID *ap_cout);

!item [Implementierung:]
!begin_verbatim
WORD appl_control ( WORD ap_cid, WORD ap_cwhat, VOID *ap_cout);
{
   int_in[0]  = ap_cid;
   int_in[1]  = ap_cwhat;
   addr_in[0] = ap_cout;
		   
   return ( crys_if(129) );	
}
!end_verbatim
!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
control !! control[0] !! 129    Opcode der Funktion
control+2 !! control[1] !! 2     # EintrÑge in int_in
control+4 !! control[2] !! 1     # EintrÑge in int_out
control+6 !! control[3] !! 1     # EintrÑge in addr_in
control+8 !! control[4] !! 0     # EintrÑge in addr_out
int_in !! int_in[0] !! ap_cid
int_in+2 !! int_in[1] !! ap_cwhat
addr_in  !! addr_in[0] !! ap_cout
int_out !! int_out[0] !! ap_creturn
!end_table
(!ende_liste)
!end_node
!end_node


!begin_node appl_exit
(!begin_liste) [Beschreibung:]
!item [Name:]
ØApplication exitÆ - meldet eine Applikation vom (!nolink [AES]) ab.
!item [AES-Nummer:]
19
!item [Binding:]
(!link [Bindings fÅr appl_exit] [Bindings fÅr appl_exit])
!item [Beschreibung:]
Meldet eine Applikation beim AES wieder ab und gibt deren Applikations-ID
frei.
!item [Ergebnis:]
Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis 0 zurÅckgegeben wird.
!item [Gruppe:]
(!link [Applikationen][Applikationsfunktionen])
!item [Querverweis:]
appl_init
(!ende_liste)



!begin_node Bindings fÅr appl_exit
!ignore_index
(!begin_liste) [Implementierung:]
!item [C:]
WORD appl_exit ( VOID );
!item [Implementierung:]
!begin_verbatim
WORD appl_exit (VOID)
{
   return ( crys_if(19) );	
} 
!end_verbatim
!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
control !! control[0] !! 19    Opcode der Funktion
control+2 !! control[1] !! 0     # EintrÑge in int_in
control+4 !! control[2] !! 1     # EintrÑge in int_out
control+6 !! control[3] !! 0     # EintrÑge in addr_in
control+8 !! control[4] !! 0     # EintrÑge in addr_out
int_out !! int_out[0] !! Return-Wert
!end_table
(!ende_liste)
!end_node
!end_node



!begin_node appl_find
(!begin_liste) [Beschreibung:]
!item [Name:]
ØApplication findÆ - ermittelt die Applikationsnummer einer
(!nolink [AES])-Anwendung.
!item [AES-Nummer:]
13
!item [Binding:]
(!link [Bindings fÅr appl_find] [Bindings fÅr appl_find])
!item [Beschreibung:]
Diese Funktion ermittelt die Applikationsidentifikation einer anderen,
parallel laufenden Applikation. Dabei zeigt (!I)ap_fpname(!i) auf den Namen
der Applikation deren Identifikator gefunden werden soll.

(!B)Wichtig:(!b) Der Name muû unbedingt acht Zeichen lang sein, ist er
kÅrzer, so muû er mit Leerzeichen aufgefÅllt werden.

In MagiC und AES 4.0 kann man zusÑtzlich durch öbergabe eines Nullpointers
die ID der aktuellen Applikation ermitteln. DarÅber hinaus ist es mîglich,
die AES-ID einer Applikation in die MiNT-ID umzurechnen und umgekehrt, und
zwar wie folgt:
!begin_xlist !short [von ap_fpname ]
!item [High-Word] Bedeutung
!item [von ap_fpname] ~
!item [~]
~
!item [-1]
Die Funktion erwartet im Low-Word die MiNT-ID einer Applikation und liefert
nach dem Aufruf die (!nolink [AES])-ID dieser Applikation zurÅck.

!item [-2]
Die Funktion erwartet im Low-Word die (!nolink [AES])-ID einer Applikation und liefert
nach dem Aufruf die MiNT-ID dieser Applikation zurÅck.
!item [-3]
Es wird die (!nolink [AES])-ID der obersten Applikation geliefert. Das Low-Word spielt
dabei keine rolle und kann 0 sein. Steht nur unter N.AES zur VerfÅgung.
!end_xlist

(!B)Hinweis:(!b) Die Funktion arbeitet nur dann korrekt, wenn das
betreffende Programm per (!I)shel_write(!i) gestartet worden ist. Es sei
ferner darauf hingewiesen, daû Threads Åber diese Funktion (!I)nicht(!i)
gefunden werden kînnen.

Das Vorhandensein der zusÑtzlichen Features ist Åber (!link [appl_getinfo][%apgi_4]) (Opcode 4)
nachprÅfbar.
!item [Ergebnis:]
Ein RÅckgabewert kleiner Null kennzeichnet einen aufgetretenen Fehler.
!item [Gruppe:]
(!link [Applikationen][Applikationsfunktionen])
!item [Querverweis:]
appl_search ~ (!link [Screen-Manager][Der Screen-Manager])
(!ende_liste)



!begin_node Bindings fÅr appl_find
!ignore_index
(!begin_liste) [Implementierung:]
!item [C:]
WORD appl_find ( CONST BYTE *ap_fpname );
!item [Implementierung:]
!begin_verbatim
WORD appl_find (CONST BYTE *ap_fpname)
{
   addr_in[0] = ap_fpname;
   return ( crys_if(13) );	
} 
!end_verbatim
!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
control !! control[0] !! 13    Opcode der Funktion
control+2 !! control[1] !! 0     # EintrÑge in int_in
control+4 !! control[2] !! 1     # EintrÑge in int_out
control+6 !! control[3] !! 1     # EintrÑge in addr_in
control+8 !! control[4] !! 0     # EintrÑge in addr_out
addr_in   !! addr_in[0] !! ap_fpname
int_out !! int_out[0] !! Return-Wert
!end_table
(!ende_liste)
!end_node
!end_node



!begin_node appl_getinfo
(!begin_liste) [Beschreibung:]
!item [Name:]
ØApplication get informationÆ - Informationen Åber vorhandene
Funktionsaufrufe und Eigenschaften erfragen.
!item [AES-Nummer:]
130
!item [Binding:]
(!link [Bindings fÅr appl_getinfo] [Bindings fÅr appl_getinfo])
!item [Beschreibung:]
Mit dieser Funktion lassen sich gezielt Eigenschaften des Betriebssystems
zur Laufzeit erfragen.

(!I)ap_gtype(!i) bestimmt die Art der Informationen, die erfragt werden
sollen. Es bedeutet:

!label %apgi_0
(!B)0: Informationen Åber den normalen AES-Zeichensatz(!b)
!begin_xlist !short [ap_gout1:]
!item [ap_gout1:]
Fonthîhe
!item [ap_gout2:]
Font-ID
!item [ap_gout3:]
Font-Typ (0=system, 1=FSM)
!end_xlist

!label %apgi_1
(!B)1: Informationen Åber den kleinen Zeichensatz(!b)
!begin_xlist !short [ap_gout1:]
!item [ap_gout1:]
Fonthîhe
!item [ap_gout2:]
Font-ID
!item [ap_gout3:]
Font-Typ (0=system, 1=FSM)
!end_xlist

!label %apgi_2
!label VDI-GerÑtenummer
!label GerÑtenummer des VDI
!label Resource-Format, neues
!label Farbicons vorhanden?
!label Icons vorhanden?, Farb-
(!B)2: Farben(!b)
!begin_xlist !short [ap_gout1:]
!item [ap_gout1:]
VDI-GerÑtenummer (device id)
!item [ap_gout2:]
Farben fÅr OBJECTs
!item [ap_gout3:]
Farbicons vorhanden (1) bzw. nicht (0)
!item [ap_gout4:]
neues RSC-Format vorhanden (1) oder nicht (0)
!end_xlist

!label %apgi_3
!label Sprache des Betriebssystems
(!B)3: Sprache(!b)
!begin_xlist !short [ap_gout1:]
!item [ap_gout1:]
!begin_table [l l l]
0 !! - !! Englisch
1 !! - !! Deutsch
2 !! - !! Franzîsisch
3 !! - !! reserviert
4 !! - !! Spanisch
5 !! - !! Italienisch
6 !! - !! Schwedisch
!end_table
!end_xlist

!label %apgi_4
!label Multitasking preemptive?
!label PrÑemptives Multitasking?
!label Preemptives Multitasking?
(!B)4: allgemeine Informationen-1(!b)
!begin_xlist !short [ap_gout1:]
!item [ap_gout1:]
Multitasking prÑemptiv (1) oder nicht (0)
!item [ap_gout2:]
appl_find konvertiert MiNT/(!nolink [AES])-ID's (1) oder nicht (0)
!item [ap_gout3:]
appl_search vorhanden (1) oder nicht (0)
!item [ap_gout4:]
rsrc_rcfix vorhanden (1) oder nicht (0)
!end_xlist

!label %apgi_5
(!B)5: allgemeine Informationen-2(!b)
!begin_xlist !short [ap_gout1:]
!item [ap_gout1:]
objc_xfind vorhanden (1) oder nicht (0)
!item [ap_gout2:]
reserviert, immer 0
!item [ap_gout3:]
menu_click vorhanden (1) oder nicht (0)
!item [ap_gout4:]
shel_r/wdef vorhanden (1) oder nicht (0)
!end_xlist

!label %apgi_6
(!B)6: allgemeine Informationen-3(!b)
!begin_xlist !short [ap_gout1:]
!item [ap_gout1:]
appl_read (-1) vorhanden (1) oder nicht (0)
!item [ap_gout2:]
shel_get (-1) vorhanden (1) oder nicht (0)
!item [ap_gout3:]
menu_bar (-1) vorhanden (1) oder nicht (0)
!item [ap_gout4:]
menu_bar (100) (MagiC) vorhanden (1) oder nicht (0)
!end_xlist

!label %apgi_7
(!B)7: reserviert fÅr (!nolink [MagiC]) und andere Erweiterungen, MultiTOS setzt alle
RÅckgabewerte immer auf 0. In MagiC gilt:(!b)
!begin_xlist !short [ap_gout1:]
!item [ap_gout1:]
!begin_xlist !short
!item [Bit-0 =]
wdlg_xx()-Funktionen vorhanden (1) 
!item [Bit-1 =]
lbox_xx()-Funktionen vorhanden (1)
!item [Bit-2 =]
fnts_xx()-Funktionen vorhanden (1)
!item [Bit-3 =]
fslx_xx()-Funktionen vorhanden (1)
!item [Bit-4 =]
pdlg_xx()-Funktionen vorhanden (1)
!end_xlist
!item [ap_gout2:]
reserviert 
!item [ap_gout3:]
reserviert
!item [ag_gout4:]
reserviert
!end_xlist

!label %apgi_8
!label Mausformverwaltung, Art der
!label Verwaltung der Mausform
(!B)8: Maus(!b)
!begin_xlist !short [ap_gout1:]
!item [ap_gout1:]
graf_mouse Modi (258-260) vorhanden (1) oder nicht (0)
!item [ap_gout2:]
Mausform vom (!nolink [AES]) fÅr jede Applikation verwaltet (1) oder nicht (0)
!end_xlist

!label %apgi_9
(!B)9: MenÅs(!b)
!begin_xlist !short [ap_gout1:]
!item [ap_gout1:]
MultiTOS-SubmenÅs vorhanden (1) oder nicht (0)
!item [ap_gout2:]
MultiTOS-Popups vorhanden (1) oder nicht (0)
!item [ap_gout3:]
MultiTOS-ScrollmenÅs vorhanden (1) oder nicht (0)
!item [ap_gout4:]
erweiterte MN_SELECTED-Nachricht vorhanden (1) oder nicht (0)
!end_xlist

!label %apgi_10
(!B)10: shel_write(!b)
!begin_xlist !short [ap_gout1:]
!item [ap_gout1:]
vorhandene Modi
!begin_xlist !short [Bit 8..15:]
!item [Bit 0..7:]
hîchster zulÑssiger Wert fÅr sh_wdoex & 0x00ff
!item [Bit 8..15:]
Bits von sh_wdoex & 0xff00, die wie in MultiTOS behandelt werden.
!end_xlist
!item [ap_gout2:]
!begin_xlist !short [0:]
!item [1:]
(!nolink [shel_write]) (0) macht vorherige (!nolink [shel_write]) Aufrufe ungÅltig (d.h. das Desktop
wird Nachfolgeprogramm) (TOS 1.04 und MagiC)
!item [0:]
startet Programm (MultiTOS)
!end_xlist
!item [ap_gout3:]
!begin_xlist !short [0:]
!item [1:]
(!nolink [shel_write]) (1) startet Programm nach Beendigung des laufenden (TOS 1.04 und
(!nolink [MagiC]))
!item [0:]
startet Programm sofort (MultiTOS)
!end_xlist
!item [ap_gout4:]
ARGV via sh_wiscr unterstÅtzt (1) oder nicht (0)
!end_xlist

!label %apgi_11
(!B)11: Fenster(!b)
!begin_xlist !short [ap_gout1:]
!item [ag_gout1:]
gesetzte Bits sind unterstÅtzte Funktionen:
!begin_xlist !short [Bit 0:]
!item [Bit 0:]
WF_TOP liefert zweitoberstes Fenster
!item [1:]
(!nolink [wind_get]) (WF_NEWDESK)
!item [2:]
wind_g/set (WF_COLOR)
!item [3:]
wind_g/set (WF_DCOLOR)
!item [4:]
(!nolink [wind_get]) (WF_OWNER)
!item [5:]
wind_g/set (WF_BEVENT)
!item [6:]
WF_BOTTOM
!item [7:]
WF_ICONIFY
!item [8:]
WF_UNICONIFY
!item [9..15:]
reserviert, immer 0
!end_xlist

!item [ap_gout2:]
!begin_xlist !short [Bit 0:]
!item [Bit 0:]
(!nolink [wind_get])/set (WF_WIDGETS), N.AES
!item [1..15:]
reserviert
!end_xlist
!item [ap_gout3:]
vorhandene Fensterbuttons
!begin_xlist !short [Bit 0:]
!item [Bit 0:]
Iconifier
!item [1:]
Backdrop-Button (MagiC)
!item [2:]
Shift-Click fÅr Backdrop
!item [3:]
"Hot" Closebox (GEM/3 und MagiC)
!item [4..15:]
reserviert, 0
!end_xlist
!item [ap_gout4:]
wind_update 'check and set' vorhanden (1) oder nicht (0)
!end_xlist

!label %apgi_12
(!B)12: Nachrichten(!b)
!begin_xlist !short [ap_gout1:]
!item [ap_gout1:]
gesetzte Bits sind unterstÅtzte Nachrichten:
!begin_xlist !short [Bit 0:]
!item [Bit 0:]
WM_NEWTOP
!item [1:]
WM_UNTOPPED
!item [2:]
WM_ONTOP
!item [3:]
AP_TERM
!item [4:]
MultiTOS-Auflîsungswechsel
!item [5:]
CH_EXIT
!item [6:]
WM_BOTTOM
!item [7:]
WM_ICONIFY
!item [8:]
WM_UNICONIFY
!item [9:]
WM_ALLICONIFY
!end_xlist
!item [ap_gout2:]
reserviert, alle 0
!item [ap_gout3:]
WM_ICONIFY liefert Koordinaten (1) oder nicht (0)
!end_xlist

!label %apgi_13
(!B)13: OBJECTs(!b)
!begin_xlist !short [ap_gout1:]
!item [ap_gout1:]
3D-Objekte Åber ob_flags vorhanden (1) oder nicht (0)
!item [ap_gout2:]
objc_sysvar vorhanden (1) oder nicht (0)
!item [ap_gout3:]
Speedo- und GDOS-Fonts im TEDINFO erlaubt (1) oder nicht (0)
!item [ap_gout4:]
reserviert fÅr MagiC und andere Erweiterungen, MultiTOS setzt alle
RÅckgabewerte immer auf 0. In (!nolink [MagiC]) und N.AES gilt:
!begin_xlist !short [Bit 0:]
!item [Bit 0:]
G_SWBUTTON vorhanden
!item [1:]
G_POPUP vorhanden
!item [2:]
WHITEBAK steuert Unterstriche und Buttons
!item [3:]
G_SHORTCUT vorhanden
!end_xlist
!end_xlist

!label %apgi_14
!label Flydials vorhanden?
!label Tastaturtabellen vorhanden?
!label MagiC-Flydials vorhanden?
!label MagiC-Tastaturtab. vorhanden?
!label Cursorposition, RÅckgabe der
(!B)14: Formulare ((!nolink [MagiC]) form_xdo und form_xdial)(!b)
!begin_xlist !short [ap_gout1:]
!item [ap_gout1:]
(!nolink [MagiC])-Flydials vorhanden (1) oder nicht (0)
!item [ap_gout2:]
(!nolink [MagiC])-Tastaturtabellen vorhanden (1) oder nicht (0)
!item [ap_gout3:]
letzte Cursorposition wird zurÅckgegeben (1) oder nicht (0)
!item [ap_gout4:]
reserviert, 0
!end_xlist

!label %apgi_64
(!B)64: Erweiterte Funktionen(!b)
!begin_xlist !short [ap_gout1:]
!item [ap_gout1:]
shel_write(10) mit AP_AESTERM mîglich (1) oder nicht (0)
!item [ap_gout2:]
extended (!nolink [shel_write])() SHW_SHUTDOWN(4)/SHW_RESCHANGE(5) vorhanden (1)
oder nicht (0)
!item [ap_gout3:]
appl_search() mit Langnamen vorhanden (1) oder nicht (0)
!item [ap_gout4:]
form_error() mit allen GEMDOS-Fehlercodes vorhanden (1) oder nicht (0)
!end_xlist

!label %apgi_65
(!B)65: ZusÑtzliche N.(!nolink [AES]) Funktionen(!b)
!begin_xlist !short [ap_gout1:]
!item [ap_gout1:] appl_control() vorhanden (1) oder nicht (0)
!item [ap_gout2:] hîchster Opcode fÅr appl_control()
!item [ap_gout3:] shel_help() vorhanden (1) oder nicht (0)
!item [ap_gout4:] wind_draw() vorhanden (1) oder nicht (0)
!end_xlist

(!B)Hinweis:(!b) Ein Problem dieser Funktion besteht darin, festzustellen,
wann sie Åberhaupt aufgerufen werden darf. Zwar sollte sie ab AES-Version
4.0 vorhanden sein, MagiC 2.0 (und auch MagiC 3.0) besitzt
aber beispielsweise die Version 3.99. Aus diesem Grund definieren viele
Programmierer die Funktion appl_xgetinfo, in der ÅberprÅft wird, ob
appl_getinfo in der aktuellen Systemumgebung vorhanden ist.
!item [Ergebnis:]
Ein RÅckgabewert von 0 zeigt einen Fehler an; bei einem Wert von 1 ist kein
Fehler aufgetreten.
!item [Gruppe:]
(!link [Applikationen][Applikationsfunktionen])
!item [Querverweis:]
(!ende_liste)



!begin_node Bindings fÅr appl_getinfo
!ignore_index
(!begin_liste) [Implementierung:]
!item [C:]
WORD appl_getinfo ( WORD ap_gtype, WORD *ap_gout1, WORD *ap_gout2,
                    WORD *ap_gout3, WORD *ap_gout4 );
!item [Implementierung:]
!begin_verbatim
WORD appl_getinfo (WORD ap_gtype, WORD *ap_gout1, WORD *ap_gout2,
                   WORD *ap_gout3, WORD *ap_gout4)
{
   int_in[0] = ap_gtype;

   crys_if (130);

   *ap_gout1 = int_out[1];
   *ap_gout2 = int_out[2];
   *ap_gout3 = int_out[3];
   *ap_gout4 = int_out[4];

   return ( int_out[0] );	
} 
!end_verbatim
!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
control !! control[0] !! 130   Opcode der Funktion
control+2 !! control[1] !! 1     # EintrÑge in int_in
control+4 !! control[2] !! 5     # EintrÑge in int_out
control+6 !! control[3] !! 0     # EintrÑge in addr_in
control+8 !! control[4] !! 0     # EintrÑge in addr_out
int_in !! int_in[0] !! ap_gtype
int_out !! int_out[0] !! Return-Wert
int_out+2 !! int_out[1] !! ap_gout1
int_out+4 !! int_out[2] !! ap_gout2
int_out+6 !! int_out[3] !! ap_gout3
int_out+8 !! int_out[4] !! ap_gout4
!end_table
(!ende_liste)
!end_node



!begin_node appl_xgetinfo
!label appl_getinfo, Existenz von
!begin_verbatim
/* Der folgende Code testet, ob appl_getinfo in der aktuellen
   Systemumgebung zur VerfÅgung steht, und ruft im positiven
   Fall die besagte Funktion auf.
   
   Es bietet sich an, statt appl_getinfo nur appl_xgetinfo
   in eigenen Programmen zu verwenden. */
   
   
GLOBAL WORD appl_xgetinfo ( WORD type, WORD *out1, WORD *out2,
                            WORD *out3, WORD *out4 )
{

   BOOLEAN has_agi = FALSE;

   has_agi = ((_GemParBlk.global[0] == 0x399 && (is_MagiC() >= 0x0200))
             || (_GemParBlk.global[0] >= 0x400)
             || (appl_find ("?AGI") >= 0));

   if (has_agi)
      return (appl_getinfo (type, out1, out2, out3, out4));
   else
      return (0);
} /* appl_xgetinfo */
!end_verbatim

Die Abfrage is_MagiC ist eine Funktion, welche den (!nolink [MagiC])-Cookie
auswertet und die
Versionsnummer zurÅckliefert. Dies ist notwendig da bereits (!nolink [MagiC]) 2
die Funktion
(!nolink [appl_getinfo]) kennt, allerdings noch nicht die Abfrage per "?AGI" erlaubt.

Querverweis: (!link [Applikationen][Applikationsfunktionen]) ~  GEM ~
Style-Guidelines
!end_node
!end_node



!begin_node appl_init
(!begin_liste) [Beschreibung:]
!item [Name:]
ØApplication InitializationÆ - meldet die Applikation unter (!nolink [AES]) an.
!item [AES-Nummer:]
10
!item [Binding:]
(!link [Bindings fÅr appl_init] [Bindings fÅr appl_init])
!item [Beschreibung:]
Die Funktion meldet das Programm beim AES an, und initialisiert die
internen ParameterÅbergabefelder.

(!B)Hinweis:(!b) Die Versionsnummer des AES lÑût sich nach diesem Aufruf
Åber das Globalfeld (global[0]) erfragen.

!label Auto-Ordner, Start aus dem
Um zu testen, ob ein Programm aus dem Auto-Ordner heraus gestartet worden
ist, bietet sich folgendes Verfahren an:
!begin_xlist !short
!item [˘]
Wert 0 in (!nolink [global])[0] schreiben
!item [˘]
Funktion appl_init aufrufen
!item [˘]
Globalfeld ((!nolink [global])[0]) inspizieren: steht dort immer noch eine Null, so ist
das (!nolink [AES]) noch nicht betriebsbereit, und das Programm wurde aus dem
Auto-Ordner heraus gestartet.
!end_xlist
Dieses Verfahren ist zwar nicht offiziell dokumentiert, wird aber auch im
Mausbeschleuniger MACCEL von Atari so angewendet.
!item [Ergebnis:]
Die Funktion liefert die ID der Applikation zurÅck. Im Fehlerfall wird der
Wert -1 zurÅckgegeben.
!item [Gruppe:]
(!link [Applikationen][Applikationsfunktionen])
!item [Querverweis:] appl_find ~ appl_search ~ appl_exit
(!ende_liste)



!begin_node Bindings fÅr appl_init
!ignore_index
(!begin_liste) [Implementierung:]
!item [C:]
WORD appl_init ( VOID );
!item [Implementierung:]
!begin_verbatim
EXTERN AESPB c;

WORD appl_init (VOID)
{
   c.cb_pcontrol = control;
   c.cb_pglobal  = global;
   c.cb_pintin   = int_in;
   c.cb_pintout  = int_out;
   c.cb_padrin   = addr_in;
   c.cb_padrout  = addr_out;

   control[4] = 0;
   crys_if (10);

   return (int_out[0]);
} 
!end_verbatim
!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
control !! control[0] !! 10    Opcode der Funktion
control+2 !! control[1] !! 0     # EintrÑge in int_in
control+4 !! control[2] !! 1     # EintrÑge in int_out
control+6 !! control[3] !! 0     # EintrÑge in addr_in
control+8 !! control[4] !! 0     # EintrÑge in addr_out
int_out !! int_out[0] !! Return-Wert
!end_table
(!ende_liste)
!end_node
!end_node



!begin_node appl_read
(!begin_liste) [Beschreibung:]
!item [Name:]
ØApplication readÆ - empfÑngt eine Mitteilung einer anderen Applikation.
!item [AES-Nummer:]
11
!item [Binding:]
(!link [Bindings fÅr appl_read] [Bindings fÅr appl_read])
!item [Beschreibung:]
Die Funktion liest eine Anzahl von Bytes aus der Message-Pipe. Es gilt:
!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [ap_rid]
ID der Applikation, aus deren Ereignispuffer gelesen werden soll.
!item [ap_rlength]
Anzahl der zu lesenden Bytes
!item [ap_rpbuff]
Adresse des Puffers, in dem die Daten abgelegt werden sollen
!end_xlist
Die Funktion wartet ggfs. bis die angeforderte Anzahl an Bytes tatsÑchlich
zur VerfÅgung steht. In MagiC und MultiTOS ist die Funktion so erweitert
worden, daû sie mit einer entsprechenden Meldung zurÅckkehrt, wenn keine
Daten vorhanden sind ((!I)ap_rid:(!i) -1).

(!B)Hinweis:(!b) appl_read arbeitet destruktiv, d.h. daû Nachrichten nach
dem Auslesen aus der Message-Pipe entfernt werden. Dies macht es notwendig,
die gelesene Nachricht so auszuwerten, wie es beispielsweise nach einem
evnt_multi-Aufruf geschieht.

Das Vorhandensein des erweiterten Feature kann Åber appl_getinfo (Opcode 6)
abgefragt werden.
!item [Ergebnis:]
Wird eine Null zurÅckgegeben, so ist ein Fehler aufgetreten, sonst wird
eine positive Zahl als Ergebnis zurÅckgegeben.
!item [Gruppe:]
(!link [Applikationen][Applikationsfunktionen])
!item [Querverweis:]
appl_init ~  appl_write ~  evnt_mesag ~  evnt_multi
(!ende_liste)



!begin_node Bindings fÅr appl_read
!ignore_index
(!begin_liste) [Implementierung:]
!item [C:]
WORD appl_read ( WORD ap_rid, WORD ap_rlength, VOID *ap_rpbuff );
!item [Implementierung:]
!begin_verbatim
WORD appl_read (WORD ap_rid, WORD ap_rlength, VOID *ap_rpbuff)
{
   int_in[0]  = ap_rid;
   int_in[1]  = ap_rlength;
   addr_in[0] = ap_rpbuff;

   return ( crys_if(11) );	
} 
!end_verbatim
!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
control !! control[0] !! 11    Opcode der Funktion
control+2 !! control[1] !! 2     # EintrÑge in int_in
control+4 !! control[2] !! 1     # EintrÑge in int_out
control+6 !! control[3] !! 1     # EintrÑge in addr_in
control+8 !! control[4] !! 0     # EintrÑge in addr_out
int_in !! int_in[0]  !! ap_rid
int_in+2  !! int_in[1]  !! ap_rlength
addr_in !! addr_in[0] !! ap_rpbuff
int_out !! int_out[0] !! Return-Wert
!end_table
(!ende_liste)
!end_node
!end_node



!begin_node appl_search
(!begin_liste) [Beschreibung:]
!item [Name:]
ØApplication searchÆ - im System vorhandene Applikationen suchen.
!item [AES-Nummer:]
18
!item [Binding:]
(!link [Bindings fÅr appl_search] [Bindings fÅr appl_search])
!item [Beschreibung:]
Je nach Parameter sucht die Funktion verschiedene im System vorhandene
Applikationen. Es bedeuten:
!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [ap_smode]
(!B)Suche(!b)
!begin_table [l l l]
0 !! = !! erste Applikation
1 !! = !! nÑchste Applikation
2 !! = !! System Shell
!end_table
!item [ap_sname]
Puffer der den Namen der gefundenen Applikation aufnimmt (mindestens
9 Bytes).
!item [ap_stype]
(!B)Typ des Prozesses als Bitvektor(!b)
!begin_table [l l l]
Bit-0 !! = !! System-Prozeû
Bit-1 !! = !! Applikation
Bit-2 !! = !! Accessory
Bit-3 !! = !! System Shell
!end_table
!item [ap_sid]
ID der gefundenen Applikation
!end_xlist

Bei N.AES kann der Langname einer Applikation ermittelt werden, wenn 
man ihre Applikations-ID kennt.

Der Langname ist derjenige, der von der Applikation bei einem menu_register()- 
Aufruf Åbergeben wurde und auch in der MenÅleiste dargestellt wird.

Kennt man die Applikations-ID apid einer Anwendung, so wird ihr Langname vom 
(!nolink [N.AES]) durch folgenden Aufruf von appl_search in den Buffer langname
Åbertragen:

     appl_search(-apid, &langname[0], &typ, &pid)

typ ist hierbei die auch normalerweise gelieferte Bitmaske des Applikationstyps,
pid die MiNT-pid (nicht: apid) der Applikation.

Als erster Parameter ist also der negative Wert der Applikations-ID zu 
Åbergeben, um den Langnamen eben dieser Applikation zu ermitteln. Dieser Name 
kann maximal 32 Zeichen lang sein (31 Zeichen plus ein Nullbyte), man sollte 
also einen entsprechend groûen Buffer fÅr langname reservieren.

(!B)Hinweis:(!b) Mit dieser Routine kînnen (!I)keine(!i) Threads gefunden
werden. Das Vorhandensein dieser Funktion kann per (!link [appl_getinfo][%apgi_4])
(Opcode 4)
festgestellt werden. Die Ermittlung des Langname erkennt man an
(!link [appl_getinfo][%apgi_64]) (Opcode 64).
!item [Ergebnis:]
Die Funktion liefert den Wert 1, wenn kein Fehler aufgetreten ist, bzw. den
Wert 0, wenn keine weiteren Applikationen vorhanden sind.
!item [Gruppe:]
(!link [Applikationen][Applikationsfunktionen])
!item [Querverweis:]
appl_find ~  appl_getinfo ~  (!link [Broadcasting][AES-Broadcasting])
(!ende_liste)



!begin_node Bindings fÅr appl_search
!ignore_index
(!begin_liste) [Implementierung:]
!item [C:]
WORD appl_search ( WORD ap_smode, BYTE *ap_sname, WORD *ap_stype,
                   WORD *ap_sid );
!item [Implementierung:]
!begin_verbatim
WORD appl_search (WORD ap_smode, BYTE *ap_sname, WORD *ap_stype,
                  WORD *ap_sid)
{
   int_in[0]  = ap_smode;
   addr_in[0] = ap_sname;

	crys_if(18);
	
	*ap_stype = int_out[1];
	*ap_sid   = int_out[2];
	
   return ( int_out[0] );	
} 
!end_verbatim
!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
control !! control[0] !! 18    Opcode der Funktion
control+2 !! control[1] !! 1     # EintrÑge in int_in
control+4 !! control[2] !! 3     # EintrÑge in int_out
control+6 !! control[3] !! 1     # EintrÑge in addr_in
control+8 !! control[4] !! 0     # EintrÑge in addr_out
int_in !! int_in[0]  !! ap_smode
addr_in !! addr_in[0] !! ap_sname
int_out !! int_out[0] !! Return-Wert
int_out+2 !! int_out[1] !! ap_stype
int_out+4 !! int_out[2] !! ap_sid
!end_table
(!ende_liste)
!end_node
!end_node



!begin_node appl_tplay
(!begin_liste) [Beschreibung:]
!item [Name:]
ØApplication playÆ - spielt aufgezeichnete (!nolink [AES])-Ereignisse ab.
!item [AES-Nummer:]
14
!item [Binding:]
(!link [Bindings fÅr appl_tplay] [Bindings fÅr appl_tplay])
!item [Beschreibung:]
Die Funktion bietet die Mîglichkeit, aufgezeichnete Benutzeraktionen wieder
abzuspielen. Es gilt:
!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [ap_tpmem]
Adresse des Puffers, in welchem sich die abzuspielenden Ereignisse befinden
!item [ap_tpnum]
Anzahl der auszufÅhrenden Ereignisse
!item [ap_tpscale]
Geschwindigkeitsfaktor fÅr das Abspielen der Ereignisse. Ein Wert von 100
steht fÅr normale Geschwindigkeit
!end_xlist
!item [Ergebnis:]
Als Ergebnis wird immer der Wert 1 zurÅckgegeben.
!item [Gruppe:]
(!link [Applikationen][Applikationsfunktionen])
!item [Querverweis:]
appl_trecord
(!ende_liste)



!begin_node Bindings fÅr appl_tplay
!ignore_index
(!begin_liste) [Implementierung:]
!item [C:]
WORD appl_tplay ( APPLRECORD *ap_tpmem, WORD ap_tpnum, WORD ap_tpscale );
!item [Implementierung:]
!begin_verbatim
WORD appl_tplay (APPLRECORD *ap_tpmem, WORD ap_tpnum, WORD ap_tpscale)
{
   int_in[0]  = ap_tpnum;
   int_in[1]  = ap_tpscale;
   addr_in[0] = ap_tpmem;

   return ( crys_if(14) );	
} 
!end_verbatim
!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
control !! control[0] !! 14    Opcode der Funktion
control+2 !! control[1] !! 2     # EintrÑge in int_in
control+4 !! control[2] !! 1     # EintrÑge in int_out
control+6 !! control[3] !! 1     # EintrÑge in addr_in
control+8 !! control[4] !! 0     # EintrÑge in addr_out
int_in !! int_in[0] !! ap_tpnum
int_in+2  !! int_in[1] !! ap_tpscale
addr_in !! addr_in[0] !! ap_tpmem
int_out !! int_out[0] !! Return-Wert
!end_table
(!ende_liste)
!end_node
!end_node



!begin_node appl_trecord
(!begin_liste) [Beschreibung:]
!item [Name:]
ØApplication recordÆ - nimmt (!nolink [AES])-Ereignisse auf.
!item [AES-Nummer:]
15
!item [Binding:]
(!link [Bindings fÅr appl_trecord] [Bindings fÅr appl_trecord])
!item [Beschreibung:]
Die Funktion dient zum Speichern von Benutzeraktionen, um diese spÑter
wieder abzuspielen. Es gilt:
!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [ap_tbuffer]
Adresse des Speicherbereichs, in dem die Ereignisse abgelegt werden sollen
!item [ap_trcount]
Anzahl der zu speichernden Ereignisse
!end_xlist
(!B)Hinweis:(!b) Die Funktion ist erst ab GEM-Version 1.2 richtig
implementiert.
!item [Ergebnis:]
Als Ergebnis wird die Anzahl der tatsÑchlich aufgezeichneten Ereignisse
zurÅckgeliefert.
!item [Gruppe:]
(!link [Applikationen][Applikationsfunktionen])
!item [Querverweis:]
appl_tplay
(!ende_liste)    



!begin_node Bindings fÅr appl_trecord
!ignore_index
(!begin_liste) [Implementierung:]
!item [C:]
WORD appl_trecord ( APPLRECORD *ap_tbuffer, WORD ap_trcount );
!item [Implementierung:]
!begin_verbatim
WORD appl_trecord (APPLRECORD *ap_tbuffer, WORD ap_trcount)
{
   int_in[0]  = ap_trcount;
   addr_in[0] = ap_tbuffer;

   return ( crys_if(15) );	
} 
!end_verbatim
!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
control !! control[0] !! 15    Opcode der Funktion
control+2 !! control[1] !! 1     # EintrÑge in int_in
control+4 !! control[2] !! 1     # EintrÑge in int_out
control+6 !! control[3] !! 1     # EintrÑge in addr_in
control+8 !! control[4] !! 0     # EintrÑge in addr_out
int_in !! int_in[0] !! ap_trcount
addr_in !! addr_in[0] !! ap_tbuffer
int_out !! int_out[0] !! Return-Wert
!end_table
(!ende_liste)       
!end_node
!end_node


                        
!begin_node appl_write
(!begin_liste) [Beschreibung:]
!item [Name:]
ØApplication writeÆ - sendet eine Mitteilung an eine andere Applikation.
!item [AES-Nummer:]
12
!item [Binding:]
(!link [Bindings fÅr appl_write] [Bindings fÅr appl_write])
!item [Beschreibung:]
Die Funktion schreibt eine Anzahl von Bytes in eine Message-Pipe. Es gilt:
!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [ap_wid]
ID der Applikation, zu der die Nachricht geschickt werden soll
!item [ap_wlength]
Anzahl der zu sendenden Bytes
!item [ap_wpbuff]
Adresse des Puffers mit der zu Åbertragenden Nachricht
!end_xlist
(!B)Hinweis:(!b) Durch diese Funktion besitzt eine Applikation auch die
Mîglichkeit, sich selbst eine Redraw-Nachricht zukommen zu lassen. Ab MagiC
Version 4.0 gilt: besitzt der Parameter (!I)ap_wid(!i) den Wert -2, so zeigt
(!I)ap_wpbuff(!i) auf eine XAESMSG-Struktur.
!item [Ergebnis:]
Wird eine Null zurÅckgegeben, so ist ein Fehler aufgetreten, sonst wird
eine positive Zahl als Ergebnis zurÅckgegeben.
!item [Gruppe:]
(!link [Applikationen][Applikationsfunktionen])
!item [Querverweis:]
appl_init  ~ appl_read ~  appl_find ~  Nachrichten
(!ende_liste)



!begin_node Bindings fÅr appl_write
!ignore_index
(!begin_liste) [Implementierung:]
!item [C:]
WORD appl_write ( WORD ap_wid, WORD ap_wlength, VOID *ap_wpbuff );
!item [Implementierung:]
!begin_verbatim
WORD appl_write (WORD ap_wid, WORD ap_wlength, VOID *ap_wpbuff)
{
   int_in[0]  = ap_wid;
   int_in[1]  = ap_wlength;
   addr_in[0] = ap_wpbuff;

   return ( crys_if(12) );	
} 
!end_verbatim
!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
control !! control[0] !! 12    Opcode der Funktion
control+2 !! control[1] !! 2     # EintrÑge in int_in
control+4 !! control[2] !! 1     # EintrÑge in int_out
control+6 !! control[3] !! 1     # EintrÑge in addr_in
control+8 !! control[4] !! 0     # EintrÑge in addr_out
int_in !! int_in[0] !! ap_wid
int_in+2 !! int_in[1] !! ap_wlength
addr_in !! addr_in[0] !! ap_wpbuff
int_out !! int_out[0] !! Return-Wert
!end_table
(!ende_liste)
!end_node
!end_node



!begin_node appl_yield
(!begin_liste) [Beschreibung:]
!item [Name:]
ØApplication yieldÆ - Prozeûwechsel erzwingen
!item [AES-Nummer:]
17
!item [Binding:]
(!link [Bindings fÅr appl_yield] [Bindings fÅr appl_yield])
!item [Beschreibung:]
Mit Hilfe dieser Funktion kann ein AES-Prozeûwechsel erzwungen werden.

(!B)Hinweis:(!b) Dies kann analog durch einen kurzen Aufruf der Funktion
evnt_timer erreicht werden. Die Funktion steht nur unter PC-GEM sowie MagiC
(jeweils) ab Version 2.0 und N.AES zur VerfÅgung.
!item [Ergebnis:]
Der RÅckgabewert der Funktion ist z.Zt. nicht bekannt.
!item [Gruppe:]
(!link [Applikationen][Applikationsfunktionen])
!item [Querverweis:]
evnt_timer
(!ende_liste)



!begin_node Bindings fÅr appl_yield
!ignore_index
(!begin_liste) [Implementierung:]
!item [C:]
WORD appl_yield ( VOID );
!item [Implementierung:]
!begin_verbatim
WORD appl_yield (VOID)
{
   return ( crys_if(17) );	
} 
!end_verbatim
!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
control !! control[0] !! 17    Opcode der Funktion
control+2 !! control[1] !! 0     # EintrÑge in int_in
control+4 !! control[2] !! 1     # EintrÑge in int_out
control+6 !! control[3] !! 0     # EintrÑge in addr_in
control+8 !! control[4] !! 0     # EintrÑge in addr_out
int_out !! int_out[0] !! Return-Wert
!end_table
(!ende_liste)
!end_node
!end_node
