!iflang [english]

!begin_node XAESMSG

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct 
{
   int16_t  dst_apid;       /* ID der Ziel-Applikation    */
   int16_t  unique_flg;     /* Nachrichten Åberschreiben? */
   void     *attached_mem;  /* Zeiger auf Speicherblock   */
   int16_t  *msgbuf;        /* Nachrichenpuffer           */ 
} XAESMSG;
!end_verbatim

(!B)Hinweis:(!b) Die Komponente (!I)unique_flg(!i) gibt an, ob gleichartige
Nachrichten (d.h. solche mit gleichem Nachrichtentyp msgbuf[0]) von der
neuen Nachricht Åberschrieben werden sollen.

Wenn (!I)attached_mem(!i) nicht NULL ist, wird damit ein per Malloc
allozierter Speicherblock angegeben, der die erweiterten
(!nolink [Nachrichten])-Informationen enthÑlt. Die LÑnge dieses Blocks ist beliebig und
fÅr das System uninteressant, sie kînnte z.B. als erstes Langwort des Blocks
oder in (!I)msgbuf(!i) [4,5] Åbergeben werden. Das System weist den
Speicherblock der Zielapplikation zu und Åbermittelt dessen Adresse in
msgbuf[6,7].

(!B)Wichtig:(!b) Die aufrufende Applikation muû davon ausgehen, daû
(!I)msgbuf[6,7](!i) nach dem Aufruf von appl_write zerstîrt sind. Das System
behÑlt sich vor, den Inhalt des Speicherblocks umzukopieren und den
Åbergebenen Block freizugeben. Der Aufrufer darf nach dem (!nolink [appl_write])
(!B)nicht mehr(!b) auf den Block zugreifen und ihn auf gar keinen Fall
freigeben!

Gibt appl_write einen Fehlercode zurÅck, so ist der Block (!I)nicht(!i)
Åbergeben worden und gehîrt nach wie vor der aufrufenden Applikation. Ein
Fehler tritt dann auf, wenn:

!begin_itemize
!item die Zielapplikation ungÅltig (nicht existent oder eingefroren) ist
!item der Nachrichtenpuffer der Zielapplikation voll ist
!item die Zielapplikation kein Prozeû ist (z.B. der (!link [SCRENMGR][Der Screen-Manager]))
      und ein attached memory block angegeben worden ist.
!end_itemize

See Also:
AES  ~ appl_write ~  GEM
!end_node

!else

!begin_node XAESMSG

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct 
{
   int16_t  dst_apid;       /* ID der Ziel-Applikation    */
   int16_t  unique_flg;     /* Nachrichten Åberschreiben? */
   void     *attached_mem;  /* Zeiger auf Speicherblock   */
   int16_t  *msgbuf;        /* Nachrichenpuffer           */ 
} XAESMSG;
!end_verbatim

(!B)Hinweis:(!b) Die Komponente (!I)unique_flg(!i) gibt an, ob gleichartige
Nachrichten (d.h. solche mit gleichem Nachrichtentyp msgbuf[0]) von der
neuen Nachricht Åberschrieben werden sollen.

Wenn (!I)attached_mem(!i) nicht NULL ist, wird damit ein per Malloc
allozierter Speicherblock angegeben, der die erweiterten
(!nolink [Nachrichten])-Informationen enthÑlt. Die LÑnge dieses Blocks ist beliebig und
fÅr das System uninteressant, sie kînnte z.B. als erstes Langwort des Blocks
oder in (!I)msgbuf(!i) [4,5] Åbergeben werden. Das System weist den
Speicherblock der Zielapplikation zu und Åbermittelt dessen Adresse in
msgbuf[6,7].

(!B)Wichtig:(!b) Die aufrufende Applikation muû davon ausgehen, daû
(!I)msgbuf[6,7](!i) nach dem Aufruf von appl_write zerstîrt sind. Das System
behÑlt sich vor, den Inhalt des Speicherblocks umzukopieren und den
Åbergebenen Block freizugeben. Der Aufrufer darf nach dem (!nolink [appl_write])
(!B)nicht mehr(!b) auf den Block zugreifen und ihn auf gar keinen Fall
freigeben!

Gibt appl_write einen Fehlercode zurÅck, so ist der Block (!I)nicht(!i)
Åbergeben worden und gehîrt nach wie vor der aufrufenden Applikation. Ein
Fehler tritt dann auf, wenn:

!begin_itemize
!item die Zielapplikation ungÅltig (nicht existent oder eingefroren) ist
!item der Nachrichtenpuffer der Zielapplikation voll ist
!item die Zielapplikation kein Prozeû ist (z.B. der (!link [SCRENMGR][Der Screen-Manager]))
      und ein attached memory block angegeben worden ist.
!end_itemize

Querverweis:
AES  ~ appl_write ~  GEM
!end_node

!endif
