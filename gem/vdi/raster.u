## Hypertext zum TOS-Betriebssystem
## entwickelt fÅr den ST-Guide
##
## Last Edit: 08.11.1997
##
## Kapitel 5: VDI-Rasterfunktionen



!begin_node v_get_pixel

(!begin_liste) [Beschreibung:]

!item [Name:]
ØGet PixelÆ - liefert den Farbwert eines Pixels.

!item [VDI-Nummer:]
105

!item [Binding:]
(!link [Bindings fÅr v_get_pixel] [Bindings fÅr v_get_pixel])

!item [Beschreibung:]
Die Funktion ermittelt den Pixelwert und den Farbindex eines Pixels bei
Auflîsungen bis zu 256 Farben (8 Planes). Es gilt:

!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation
!item [x]
x-Koordinate
!item [y]
y-Koordinate des Pixels
!item [pel]
Wert des Pixels
!item [index]
Farbindex des Pixels
!end_xlist

(!B)Hinweis:(!b) Unter dem Farbindex versteht man die Nummer, die man bei
den Attributfunktionen des VDI angeben kann. Der Pixelwert gibt hingegen den
tatsÑchlichen Inhalt des Bildspeichers wieder.

Bei HiColor (15- oder 16-Bit) enthÑlt (!I)pel(!i) den Pixelwert und
(!I)index(!i) ist (meistens) -1, da er nicht einwandfrei zuzuordnen ist. Bei
TrueColor enthÑlt (!I)pel(!i) das Low-Word des Pixelwerts und (!I)index(!i)
das High-Word.

!item [Ergebnis:]
Die Funktion liefert kein Ergebnis.

!item [Gruppe:]
Rasterfunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fÅr v_get_pixel]) ~  Rasterformate

(!ende_liste)
!end_node



!begin_node Bindings fÅr v_get_pixel
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
VOID v_get_pixel ( WORD handle, WORD x, WORD y, WORD *pel, WORD *index );

!item [Implementierung:]
!begin_verbatim
VOID v_get_pixel (WORD handle, WORD x, WORD y, WORD *pel, WORD *index)
{
   ptsin[0]  = x;
   ptsin[1]  = y;
   contrl[0] = 105;
   contrl[1] = 1;
   contrl[3] = 0;
   contrl[6] = handle;

   vdi ();

   *pel   = intout[0];
   *index = intout[1];
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0] !! 105   Opcode der Funktion
contrl+2  !! contrl[1] !! 1     # EintrÑge in ptsin
contrl+4  !! contrl[2] !! 0     # EintrÑge in ptsout
contrl+6  !! contrl[3] !! 0     # EintrÑge in intin
contrl+8  !! contrl[4] !! 2     # EintrÑge in intout
contrl+12 !! contrl[6] !! handle
ptsin     !! ptsin[0]  !! x
ptsin+2   !! ptsin[1]  !! y
intout    !! intout[0] !! pel
intout+2  !! intout[1] !! index
!end_table

(!ende_liste)
!end_node



!begin_node vq_hilite_color

(!begin_liste) [Beschreibung:]

!item [Name:]
ØInquire Hilite ColorÆ - Hervorhebungsfarbe ermitteln.

!item [VDI-Nummer:]
209 (Unterfunktion 0)

!item [Binding:]
(!link [Bindings fÅr vq_hilite_color] [Bindings fÅr vq_hilite_color])

!item [Beschreibung:]
Diese Funktion erfragt die Hervorhebungsfarbe.

!begin_xlist !short [hilite_color]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation

!item [hilite_color]
COLOR_ENTRY der Hervorhebungsfarbe.

!end_xlist

!item [Ergebnis:]
eingestellter Farbraum

!item [VerfÅgbar:]
ab NVDI 5.00

!item [Gruppe:]
Rasterfunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fÅr vq_hilite_color])

(!ende_liste)
!end_node



!begin_node Bindings fÅr vq_hilite_color
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
LONG vq_hilite_color( WORD handle, COLOR_ENTRY *hilite_color );

!item [Implementierung:]
!begin_verbatim
LONG vq_hilite_color( WORD handle,
                      COLOR_ENTRY *hilite_color )
{
   contrl[0] = 209;
   contrl[1] = 0;
   contrl[3] = 0;
   contrl[5] = 0;
   contrl[6] = handle;

   vdi ();
   
   hilite_color = intout[2..5];

   return ( intout[0..1] );
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0]    !! 209   Opcode der Funktion
contrl+2  !! contrl[1]    !! 0     # EintrÑge in ptsin
contrl+4  !! contrl[2]    !! 0     # EintrÑge in ptsout
contrl+6  !! contrl[3]    !! 0     # EintrÑge in intin
contrl+8  !! contrl[4]    !! 6     # EintrÑge in intout
contrl+10 !! contrl[5]    !! 0
contrl+12 !! contrl[6]    !! handle
intout    !! intout[0..1] !! RÅckgabewert
intout+4  !! intout[2..5] !! hilite_color
!end_table

(!ende_liste)
!end_node




!begin_node vq_max_color

(!begin_liste) [Beschreibung:]

!item [Name:]
ØInquire Maximum ColorÆ - 

!item [VDI-Nummer:]
209 (Unterfunktion 2)

!item [Binding:]
(!link [Bindings fÅr vq_max_color] [Bindings fÅr vq_max_color])

!item [Beschreibung:]
Diese Funktion erfragt den maximalen Farbwert fÅr eine additive Rasteroperation.


!begin_xlist !short [max_color]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation

!item [max_color]
COLOR_ENTRY des maximalen Farbwerts fÅr T_ADD.

!end_xlist

!item [Ergebnis:]
eingestellter Farbraum

!item [VerfÅgbar:]
ab NVDI 5.00

!item [Gruppe:]
Rasterfunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fÅr vq_max_color])

(!ende_liste)
!end_node



!begin_node Bindings fÅr vq_max_color
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
LONG vq_max_color( WORD handle, COLOR_ENTRY *max_color );

!item [Implementierung:]
!begin_verbatim
LONG vq_max_color( WORD handle, COLOR_ENTRY *max_color )
{
   contrl[0] = 209;
   contrl[1] = 0;
   contrl[3] = 0;
   contrl[5] = 2;
   contrl[6] = handle;

   vdi ();
   
   max_color = intout[2..5];
   return ( intout[0..1] );
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0]    !! 209   Opcode der Funktion
contrl+2  !! contrl[1]    !! 0     # EintrÑge in ptsin
contrl+4  !! contrl[2]    !! 0     # EintrÑge in ptsout
contrl+6  !! contrl[3]    !! 0     # EintrÑge in intin
contrl+8  !! contrl[4]    !! 6     # EintrÑge in intout
contrl+10 !! contrl[5]    !! 2
contrl+12 !! contrl[6]    !! handle
intout    !! intout[0..1] !! RÅckgabewert
intout+4  !! intout[2..5] !! max_color
!end_table

(!ende_liste)
!end_node




!begin_node vq_min_color

(!begin_liste) [Beschreibung:]

!item [Name:]
ØInquire Minimum ColorÆ - 

!item [VDI-Nummer:]
209 (Unterfunktion 1)

!item [Binding:]
(!link [Bindings fÅr vq_min_color] [Bindings fÅr vq_min_color])

!item [Beschreibung:]
Diese Funktion erfragt den minimalen Farbwert fÅr die Subtraktionsfunktion (T_SUB).


!begin_xlist !short [min_color]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation

!item [min_color]
COLOR_ENTRY des minimalen Farbwerts fÅr T_SUB.

!end_xlist

!item [Ergebnis:]
eingestellter Farbraum

!item [VerfÅgbar:]
ab NVDI 5.00

!item [Gruppe:]
Rasterfunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fÅr vq_min_color])

(!ende_liste)
!end_node



!begin_node Bindings fÅr vq_min_color
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
LONG vq_min_color( WORD handle, COLOR_ENTRY *min_color );

!item [Implementierung:]
!begin_verbatim
LONG vq_min_color( WORD handle, COLOR_ENTRY *min_color )
{
   contrl[0] = 209;
   contrl[1] = 0;
   contrl[3] = 0;
   contrl[5] = 1;
   contrl[6] = handle;

   vdi ();
   
   min_color = intout[2..5];
   return ( intout[0..1] );
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0]    !! 209   Opcode der Funktion
contrl+2  !! contrl[1]    !! 0     # EintrÑge in ptsin
contrl+4  !! contrl[2]    !! 0     # EintrÑge in ptsout
contrl+6  !! contrl[3]    !! 0     # EintrÑge in intin
contrl+8  !! contrl[4]    !! 6     # EintrÑge in intout
contrl+10 !! contrl[5]    !! 1
contrl+12 !! contrl[6]    !! handle
intout    !! intout[0..1] !! RÅckgabewert
intout+4  !! intout[2..5] !! min_color
!end_table

(!ende_liste)
!end_node




!begin_node vq_weight_color

(!begin_liste) [Beschreibung:]

!item [Name:]
ØInquire Weight ColorÆ - 

!item [VDI-Nummer:]
209 (Unterfunktion 3)

!item [Binding:]
(!link [Bindings fÅr vq_weight_color] [Bindings fÅr vq_weight_color])

!item [Beschreibung:]
Diese Funktion erfragt die Gewichtung fÅr die Blendfunktion (T_BLEND).


!begin_xlist !short [weight_color]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation

!item [weight_color]
COLOR_ENTRY der Gewichtung fÅr T_BLEND

!end_xlist

!item [Ergebnis:]
eingestellter Farbraum

!item [VerfÅgbar:]
ab NVDI 5.00

!item [Gruppe:]
Rasterfunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fÅr vq_weight_color])

(!ende_liste)
!end_node



!begin_node Bindings fÅr vq_weight_color
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
LONG vq_weight_color( WORD handle, COLOR_ENTRY *weight_color );

!item [Implementierung:]
!begin_verbatim
LONG vq_weight_color( WORD handle, COLOR_ENTRY *weight_color )
{
   contrl[0] = 209;
   contrl[1] = 0;
   contrl[3] = 0;
   contrl[5] = 3;
   contrl[6] = handle;

   vdi ();
   
   weight_color = intout[2..5];
   return ( intout[0..1] );
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0]    !! 209   Opcode der Funktion
contrl+2  !! contrl[1]    !! 0     # EintrÑge in ptsin
contrl+4  !! contrl[2]    !! 0     # EintrÑge in ptsout
contrl+6  !! contrl[3]    !! 0     # EintrÑge in intin
contrl+8  !! contrl[4]    !! 6     # EintrÑge in intout
contrl+10 !! contrl[5]    !! 3
contrl+12 !! contrl[6]    !! handle
intout    !! intout[0..1] !! RÅckgabewert
intout+4  !! intout[2..5] !! weight_color
!end_table

(!ende_liste)
!end_node




!begin_node vr_clip_rects_by_dst

(!begin_liste) [Beschreibung:]

!item [Name:]
ØClip Rects By Destination RectangleÆ 

!item [VDI-Nummer:]
171 (Unterfunktion 0)

!item [Binding:]
(!link [Bindings fÅr vr_clip_rects_by_dst] [Bindings fÅr vr_clip_rects_by_dst])

!item [Beschreibung:]
Zielrechteck mit einem Clipping-Rechteck schneiden und das Quellrechteck anpassen.

!begin_xlist !short [clipped_src_rect]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation

!item [dst_clip_rect]
(!nolink [Clipping])-Rechteck fÅr das Ziel (diskrete Koordinaten)

!item [src_rect]
Quellrechteck  (diskrete Koordinaten)

!item [dst_rect]
Zielrechteck  (diskrete Koordinaten)

!item [clipped_src_rect]
geschnittenes Quellrechteck (diskrete Koordinaten)

!item [clipped_dst_rect]
geschnittenes Zielrechteck (diskrete Koordinaten)

!end_xlist


!item [Ergebnis:]
0: kein Schnitt der Rechtecke (!nl)
1: alles in Ordnung

!item [VerfÅgbar:]
ab NVDI 5.02

Wenn der Treiber die neuen Clipfunktionen,
anbietet, ist bei den erweiterten Parametern von vq_extnd in
work_out[30] Bit 2 gesetzt.

!item [Gruppe:]
Rasterfunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fÅr vr_clip_rects_by_dst])

(!ende_liste)
!end_node



!begin_node Bindings fÅr vr_clip_rects_by_dst
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
WORD vr_clip_rects_by_dst ( WORD handle, RECT16 *dst_clip_rect,
                            RECT16 *src_rect, RECT16 *dst_rect,
                            RECT16 *clipped_src_rect,
                            RECT16 *clipped_dst_rect );

!item [Implementierung:]
!begin_verbatim
WORD vr_clip_rects_by_dst ( WORD handle, RECT16 *dst_clip_rect,
                            RECT16 *src_rect, RECT16 *dst_rect,
                            RECT16 *clipped_src_rect,
                            RECT16 *clipped_dst_rect )
{
   ptsin[0..3] = dst_clip_rect; 
   ptsin[4..7] = src_rect; 
   ptsin[8..11] = dst_rect; 

   contrl[0] = 171;
   contrl[1] = 6;
   contrl[3] = 0;
   contrl[5] = 0;
   contrl[6] = handle;

   vdi ();

   clipped_src_rect = ptsout[0..3];   
   clipped_dst_rect = ptsout[4..7];   

   return ( intout[0] );
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0]    !! 171   Opcode der Funktion
contrl+2  !! contrl[1]    !! 6     # EintrÑge in ptsin
contrl+4  !! contrl[2]    !! 4    # EintrÑge in ptsout
contrl+6  !! contrl[3]    !! 0     # EintrÑge in intin
contrl+8  !! contrl[4]    !! 1     # EintrÑge in intout
contrl+10 !! contrl[5]    !! 0
contrl+12 !! contrl[6]    !! handle
ptsin     !! ptsin[0..3]  !! dst_clip_rect
ptsin+8   !! ptsin[4..7]  !! src_rect
ptsin+16  !! ptsin[8..11] !! dst_rect
ptsout    !! ptsout[0..3] !! clipped_src_rect
ptsout+8  !! ptsout[4..7] !! clipped_dst_rect
intout    !! intout[0]    !! RÅckgabewert
!end_table

(!ende_liste)
!end_node




!begin_node vr_clip_rects_by_src

(!begin_liste) [Beschreibung:]

!item [Name:]
ØClip Rects By Source RectangleÆ 

!item [VDI-Nummer:]
171 (Unterfunktion 1)

!item [Binding:]
(!link [Bindings fÅr vr_clip_rects_by_src] [Bindings fÅr vr_clip_rects_by_src])

!item [Beschreibung:]
Quellrechteck mit einem Clipping-Rechteck schneiden und das
Zielrechteck anpassen (die Funktion berÅcksichtigt das
Rundungsverhalten von vr_transfer_bits).

!begin_xlist !short [clipped_src_rect]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation

!item [src_clip_rect]
(!nolink [Clipping])-Rechteck fÅr das Quelle (diskrete Koordinaten)

!item [src_rect]
Quellrechteck  (diskrete Koordinaten)

!item [dst_rect]
Zielrechteck  (diskrete Koordinaten)

!item [clipped_src_rect]
geschnittenes Quellrechteck (diskrete Koordinaten)

!item [clipped_dst_rect]
geschnittenes Zielrechteck (diskrete Koordinaten)

!end_xlist


!item [Ergebnis:]
0: kein Schnitt der Rechtecke (!nl)
1: alles in Ordnung

!item [VerfÅgbar:]
ab NVDI 5.02

Wenn der Treiber die neuen Clipfunktionen,
anbietet, ist bei den erweiterten Parametern von vq_extnd in
work_out[30] Bit 2 gesetzt.

!item [Gruppe:]
Rasterfunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fÅr vr_clip_rects_by_src]) ~ vr_transfer_bits

(!ende_liste)
!end_node



!begin_node Bindings fÅr vr_clip_rects_by_src
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
WORD vr_clip_rects_by_src ( WORD handle, RECT16 *src_clip_rect,
                            RECT16 *src_rect, RECT16 *dst_rect,
                            RECT16 *clipped_src_rect,
                            RECT16 *clipped_dst_rect );

!item [Implementierung:]
!begin_verbatim
WORD vr_clip_rects_by_src ( WORD handle, RECT16 *src_clip_rect,
                            RECT16 *src_rect, RECT16 *dst_rect,
                            RECT16 *clipped_src_rect,
                            RECT16 *clipped_dst_rect )
{
   ptsin[0..3] = src_clip_rect; 
   ptsin[4..7] = src_rect; 
   ptsin[8..11] = dst_rect; 

   contrl[0] = 171;
   contrl[1] = 6;
   contrl[3] = 0;
   contrl[5] = 1;
   contrl[6] = handle;

   vdi ();

   clipped_src_rect = ptsout[0..3];   
   clipped_dst_rect = ptsout[4..7];   

   return ( intout[0] );
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0]    !! 171   Opcode der Funktion
contrl+2  !! contrl[1]    !! 6     # EintrÑge in ptsin
contrl+4  !! contrl[2]    !! 4    # EintrÑge in ptsout
contrl+6  !! contrl[3]    !! 0     # EintrÑge in intin
contrl+8  !! contrl[4]    !! 1     # EintrÑge in intout
contrl+10 !! contrl[5]    !! 1
contrl+12 !! contrl[6]    !! handle
ptsin     !! ptsin[0..3]  !! src_clip_rect
ptsin+8   !! ptsin[4..7]  !! src_rect
ptsin+16  !! ptsin[8..11] !! dst_rect
ptsout    !! ptsout[0..3] !! clipped_src_rect
ptsout+8  !! ptsout[4..7] !! clipped_dst_rect
intout    !! intout[0]    !! RÅckgabewert
!end_table

(!ende_liste)
!end_node




!begin_node vr_clip_rects32_by_dst

(!begin_liste) [Beschreibung:]

!item [Name:]
ØClip Rects By Destination RectangleÆ 

!item [VDI-Nummer:]
171 (Unterfunktion 2)

!item [Binding:]
(!link [Bindings fÅr vr_clip_rects32_by_dst] [Bindings fÅr vr_clip_rects32_by_dst])

!item [Beschreibung:]
Zielrechteck mit einem Clipping-Rechteck schneiden und das
Quellrechteck anpassen.

!begin_xlist !short [clipped_src_rect]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation

!item [dst_clip_rect]
(!nolink [Clipping])-Rechteck fÅr das Ziel (kontinuierliche Koordinaten)

!item [src_rect]
Quellrechteck  (kontinuierliche Koordinaten)

!item [dst_rect]
Zielrechteck  (kontinuierliche Koordinaten)

!item [clipped_src_rect]
geschnittenes Quellrechteck (kontinuierliche Koordinaten)

!item [clipped_dst_rect]
geschnittenes Zielrechteck (kontinuierliche Koordinaten)

!end_xlist


!item [Ergebnis:]
0: kein Schnitt der Rechtecke (!nl)
1: alles in Ordnung

!item [VerfÅgbar:]
ab NVDI 5.02

Wenn der Treiber die neuen Clipfunktionen,
anbietet, ist bei den erweiterten Parametern von vq_extnd in
work_out[30] Bit 2 gesetzt.

!item [Gruppe:]
Rasterfunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fÅr vr_clip_rects32_by_dst])

(!ende_liste)
!end_node



!begin_node Bindings fÅr vr_clip_rects32_by_dst
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
WORD vr_clip_rects32_by_dst ( WORD handle, RECT32 *dst_clip_rect,
                            RECT32 *src_rect, RECT16 *dst_rect,
                            RECT32 *clipped_src_rect,
                            RECT32 *clipped_dst_rect );

!item [Implementierung:]
!begin_verbatim
WORD vr_clip_rects32_by_dst ( WORD handle, RECT32 *dst_clip_rect,
                              RECT32 *src_rect, RECT16 *dst_rect,
                              RECT32 *clipped_src_rect,
                              RECT32 *clipped_dst_rect )
{
   ptsin[0..7] = dst_clip_rect; 
   ptsin[8..15] = src_rect; 
   ptsin[16..23] = dst_rect; 

   contrl[0] = 171;
   contrl[1] = 12;
   contrl[3] = 0;
   contrl[5] = 2;
   contrl[6] = handle;

   vdi ();

   clipped_src_rect = ptsout[0..7];   
   clipped_dst_rect = ptsout[8..15];   

   return ( intout[0] );
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0]    !! 171   Opcode der Funktion
contrl+2  !! contrl[1]    !! 12     # EintrÑge in ptsin
contrl+4  !! contrl[2]    !! 8    # EintrÑge in ptsout
contrl+6  !! contrl[3]    !! 0     # EintrÑge in intin
contrl+8  !! contrl[4]    !! 1     # EintrÑge in intout
contrl+10 !! contrl[5]    !! 2
contrl+12 !! contrl[6]    !! handle
ptsin     !! ptsin[0..7]  !! dst_clip_rect
ptsin+16  !! ptsin[8..15] !! src_rect
ptsin+32  !! ptsin[16..23]!! dst_rect
ptsout    !! ptsout[0..7] !! clipped_src_rect
ptsout+16 !! ptsout[8..15] !! clipped_dst_rect
intout    !! intout[0]    !! RÅckgabewert
!end_table

(!ende_liste)
!end_node




!begin_node vr_clip_rects32_by_src

(!begin_liste) [Beschreibung:]

!item [Name:]
ØClip Rects By Source RectangleÆ 

!item [VDI-Nummer:]
171 (Unterfunktion 3)

!item [Binding:]
(!link [Bindings fÅr vr_clip_rects32_by_src] [Bindings fÅr vr_clip_rects32_by_src])

!item [Beschreibung:]
Quellrechteck mit einem Clipping-Rechteck schneiden und das
Zielrechteck anpassen (die Funktion berÅcksichtigt das
Rundungsverhalten von vr_transfer_bits).

!begin_xlist !short [clipped_src_rect]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation

!item [src_clip_rect]
(!nolink [Clipping])-Rechteck fÅr das Quelle (kontinuierliche Koordinaten)

!item [src_rect]
Quellrechteck  (kontinuierliche Koordinaten)

!item [dst_rect]
Zielrechteck  (kontinuierliche Koordinaten)

!item [clipped_src_rect]
geschnittenes Quellrechteck (kontinuierliche Koordinaten)

!item [clipped_dst_rect]
geschnittenes Zielrechteck (kontinuierliche Koordinaten)

!end_xlist


!item [Ergebnis:]
0: kein Schnitt der Rechtecke (!nl)
1: alles in Ordnung

!item [VerfÅgbar:]
ab NVDI 5.02

Wenn der Treiber die neuen Clipfunktionen,
anbietet, ist bei den erweiterten Parametern von vq_extnd in
work_out[30] Bit 2 gesetzt.

!item [Gruppe:]
Rasterfunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fÅr vr_clip_rects32_by_src]) ~ vr_transfer_bits

(!ende_liste)
!end_node



!begin_node Bindings fÅr vr_clip_rects32_by_src
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
WORD vr_clip_rects32_by_src ( WORD handle, RECT32 *src_clip_rect,
                            RECT32 *src_rect, RECT16 *dst_rect,
                            RECT32 *clipped_src_rect,
                            RECT32 *clipped_dst_rect );

!item [Implementierung:]
!begin_verbatim
WORD vr_clip_rects32_by_src ( WORD handle, RECT32 *src_clip_rect,
                              RECT32 *src_rect, RECT16 *dst_rect,
                              RECT32 *clipped_src_rect,
                              RECT32 *clipped_dst_rect )
{
   ptsin[0..7] = src_clip_rect; 
   ptsin[8..15] = src_rect; 
   ptsin[16..23] = dst_rect; 

   contrl[0] = 171;
   contrl[1] = 12;
   contrl[3] = 0;
   contrl[5] = 3;
   contrl[6] = handle;

   vdi ();

   clipped_src_rect = ptsout[0..7];   
   clipped_dst_rect = ptsout[8..15];   

   return ( intout[0] );
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0]    !! 171   Opcode der Funktion
contrl+2  !! contrl[1]    !! 12     # EintrÑge in ptsin
contrl+4  !! contrl[2]    !! 8    # EintrÑge in ptsout
contrl+6  !! contrl[3]    !! 0     # EintrÑge in intin
contrl+8  !! contrl[4]    !! 1     # EintrÑge in intout
contrl+10 !! contrl[5]    !! 3
contrl+12 !! contrl[6]    !! handle
ptsin     !! ptsin[0..7]  !! src_clip_rect
ptsin+16  !! ptsin[8..15] !! src_rect
ptsin+32  !! ptsin[16..23]!! dst_rect
ptsout    !! ptsout[0..7] !! clipped_src_rect
ptsout+16 !! ptsout[8..15] !! clipped_dst_rect
intout    !! intout[0]    !! RÅckgabewert
!end_table

(!ende_liste)
!end_node




!begin_node vr_transfer_bits

(!begin_liste) [Beschreibung:]

!item [Name:]
ØTransfer BitmapÆ - VerknÅpft zweier Bitmaps

!item [VDI-Nummer:]
170 (Unterfunktion 0)

!item [Binding:]
(!link [Bindings fÅr vr_transfer_bits] [Bindings fÅr vr_transfer_bits])

!item [Beschreibung:]
Diese Funktion erfragt die Gewichtung fÅr die Blendfunktion (T_BLEND).


!begin_xlist !short [dst_rect]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation

!item [src_bm]
Quellbitmap

!item [dst_bm]
Zielbitmap

!item [src_rect]
Quellrechteck

!item [dst_rect]
Zielrechteck

!item [mode]
Modus der Transferfunktion

!end_xlist


Die Funktion TRANSFER BITMAP verknÅpft die Quellbitmap
(!I)src_bm(!i) mit der Zielbitmap (!I)dst_bm(!i), wobei (!I)mode(!i)
die Transferfunktion angibt. Das Quellrechteck wird in
(!I)src_rect(!i) und das Zielrechteck in (!I)dst_rect(!i)
Åbergeben. Die Koordinaten werden dabei (wie bei allen anderen
VDI-Funktionen) als diskrete Werte angegeben.

Wenn das Quell- und das Zielrechteck nicht die gleichen
Ausmaûe haben, skaliert TRANSFER BITMAP die Quellbitmap.
Bei Verkleinerungen werden die Bitmapdaten interpoliert, wenn
die Quelle direkte Farbwerte enthÑlt (16 oder 32 Bit) oder wenn
die Ausgabe mit Dithern erfolgt.

Falls die Quell- und die Zielbitmap nicht das gleiche Pixelformat
oder die gleiche Farbtiefe haben, werden die Quelldaten automatisch in
das Zielformat umgesetzt (die Quellbitmap bleibt dabei natÅrlich
unverÑndert).

Wenn (!I)src_bm(!i) oder (!I)dst_bm(!i) 0 ist, wird als Quelle
bzw. Ziel der Operation die Bitmap der Workstation(!I)handle(!i)
benutzt. Bei Ausgaben auf dem Bildschirm sollte ein Programm auf jeden
Fall 0 fÅr(!I)dst_bm(!i) Åbergeben und nicht versuchen,
eine eigene Bitmapbeschreibung aufzubauen. Clipping erfolgt nur
fÅr die Zielbitmap (und das nur, wenn die Zielbitmap die Bitmap
der Workstation ist).


Transfermodi

In der folgenden Liste sind die Konstanten fÅr die in
(!I)mode(!i) Åbergebenen Transfermodi definiert. In den
Kommentaren ist dabei die Art der Operation in symbolischer
Schreibweise aufgefÅhrt (src ist das Quellpixel,
dst ist das Zielpixel, bg_col ist der Pixelwert der
Hintergrundfarbe, hilite_col ist der Pixelwert der Farbe
fÅr Hervorhebungen):

!begin_verbatim
/* logische Transfermodi */
#define T_LOGIC_COPY         0  /* dst = src;                      */
#define T_LOGIC_OR           1  /* dst = src OR dst;               */
#define T_LOGIC_XOR          2  /* dst = src XOR dst;              */
#define T_LOGIC_AND          3  /* dst = src AND dst;              */
#define T_LOGIC_NOT_COPY     4  /* dst = ( NOT src );              */
#define T_LOGIC_NOT_OR       5  /* dst = ( NOT src ) OR dst;       */
#define T_LOGIC_NOT_XOR      6  /* dst = ( NOT src ) XOR dst;      */
#define T_LOGIC_NOT_AND      7  /* dst = ( NOT src ) AND dst;      */

/* Zeichenmodi */
#define T_REPLACE            32 /* dst = src;                      */
#define T_TRANSPARENT        33 /* if ( src != bg_col ) dst = src; */
#define T_HILITE             34 /* if ( src != bg_col )            */
                                /* {                               */
                                /*    if ( dst == bg_col )         */
                                /*       dst = hilite_col;         */
                                /*    else if ( dst == hilite_col )*/
                                /*       dst = bg_col;             */
                                /* }                               */
#define T_REVERS_TRANSPARENT 35 /* if ( src == bg_col ) dst = src; */
!end_verbatim

Hinweis: Bei den arithmetischen Transfermodi werden Quelle
und Ziel nicht anhand ihres Pixelwerts verknÅpft, sondern ihre
(RGB-) Farbwerte werden je nach VerknÅpfung addiert oder
subtrahiert, ...

In der symbolischen Beschreibung ist RGB( x ) der RGB-Farbwert
eines Pixels und PIXELWERT( rgb ) ist der Pixelwert eines
RGB-Farbwerts. MAX( rgb_a, rgb_b ) liefert die maximalen Komponenten
zweier RGB- Farbwerte; MIN( rgb_a, rgb_b ) liefert dementsprechend die
minimalen Komponenten zurÅck. <max_rgb> ist ein maximaler
RGB-Farbwert, <min_rgb> ist ein minimaler RGB-Farbwert.
<Gewichtung> ist ein Wert zwischen 0 und 1.0, der die Mischung
von Quell- und Zielfarbe angibt.

!begin_verbatim
/* arithmetische Transfermodi */
#define T_BLEND           64 /* Quell- und Zielfarbe mischen     */
                             /* rgb = RGB( src ) * Gewichtung ); */
                             /* rgb += RGB( dst ) * (1-Gewichtung));*/
                             /* dst = PIXELWERT( rgb );          */
#define T_ADD             65 /* Quell- und Zielfarbe addieren    */
                             /* rgb = RGB( src ) + RGB( dst )    */
                             /* if ( rgb > max_rgb )             */
                             /*    rgb = max_rgb;                */
                             /* dst = PIXELWERT( rgb );          */
#define T_ADD_OVER        66 /* Quell- und Zielfarbe addieren,   */
                             /* Åberlauf nicht abfangen          */
                             /* rgb = RGB( src ) + RGB( dst )    */
                             /* dst = PIXELWERT( rgb );          */
#define T_SUB             67 /* Quell- von Zielfarbe subtrahieren   */
                             /* rgb = RGB( dst ) - RGB( src )    */
                             /* if ( rgb < min_rgb )             */
                             /*    rgb = min_rgb;                */
                             /* dst = PIXELWERT( rgb );          */
#define T_MAX             69 /* maximale RGB-Komponenten         */
                             /* rgb = MAX(RGB( dst ), RGB( src ))*/
                             /* dst = PIXELWERT( rgb );          */
#define T_SUB_OVER        70 /* Quell- von Zielfarbe subtrahieren,  */
                             /* Åberlauf nicht abfangen          */
                             /* rgb = RGB( dst ) - RGB( src )    */
                             /* dst = PIXELWERT( rgb );          */
#define T_MIN             71 /* minimale RGB-Komponenten         */
                             /* rgb = MIN(RGB( dst ), RGB( src ))*/
                             /* dst = PIXELWERT( rgb );          */
!end_verbatim

FÅr alle Transfermodi kann man auûerdem durch Addition
einer der beiden folgenden Konstanten die Art der VerknÅpfung
beeinflussen.

 #define T_COLORIZE        16    /* Quelle einfÑrben */ (!nl)
 #define T_DITHER_MODE     128   /* Quelldaten dithern */

Dithern

<T_DITHER_MODE> fÅhrt dazu, daû eine
Fehlerverteilungsfunktion benutzt wird, wenn die Zielbitmap 256 oder
weniger Farben hat (auûerdem wird bei Verkleinerungen in diesem
Fall interpoliert, damit die Details in der Verkleinerung nicht
vollkommen verloren gehen).

Falls die Quell- und Zielpalette gleich sind (oder die
Quellpalette eine Untermenge der Systemfarbpalette ist), verwendet
NVDI intern (automatisch) eine schnellere Transferfunktion ohne
Dither.

EinfÑrbung
!begin_itemize
!item  Wenn ein logischer Modus mit <T_COLORIZE> aufgerufen wird,
erfolgt die Art der EinfÑrbung abhÑngig vom Modus:
!begin_verbatim
T_LOGIC_COPY

Blende bei allen gesetzen Bits im Farbwert die
Hintergrundfarbe ein und bei allen gelîschten Bits
die Vordergrundfarbe:
rgb = (( NOT RGB( src )) &amp; RGB( fg_col )) OR
      ( RGB( src ) AND RGB( bg_col ));
dst = PIXELWERT( rgb );

T_LOGIC_NOT_COPY

Blende bei allen gesetzen Bits im Farbwert die
Vordergrundfarbe ein und bei allen gelîschten Bits die
Hintergrundfarbe:
rgb = ( RGB( src ) &amp; RGB( fg_col )) OR
      ((( NOT RGB( src )) AND RGB( bg_col ));
dst = PIXELWERT( rgb );

T_LOGIC_OR

Åberall dort, wo Quellbits gesetzt sind, wird beim Ziel
( src AND fg_col) eingeblendet:
dst = ( src AND fg_col ) OR (( NOT src ) AND dst );

T_LOGIC_NOT_OR

Åberall dort, wo Quellbits gelîscht sind, wird beim Ziel
((NOT src ) AND fg_col) eingeblendet:
dst = (( NOT src ) AND fg_col ) OR ( src AND dst );

T_LOGIC_XOR
T_LOGIC_NOT_XOR

Die XOR-VerknÅpfung ignoriert die EinfÑrbung.

T_LOGIC_AND

Åberall dort, wo Quellbits gelîscht sind, wird beim Ziel
((NOT src ) AND bg_col) eingeblendet:
dst = ((NOT src ) AND bg_col ) OR ( src AND dst );

T_LOGIC_NOT_AND

Åberall dort, wo Quellbits gesetzt sind, wird beim Ziel
( src AND bg_col) eingeblendet:
dst = ( src AND bg_col ) OR ((NOT src ) AND dst );
!end_verbatim


!item  Bei den Modi T_REPLACE, T_TRANSPARENT, T_HILITE und
T_REVERS_TRANSPARENT wirkt die EinfÑrbung nicht binÑr auf
die Farb- oder Pixelwerte, sondern die Farbwerte werden skaliert. Das
folgende Beispiel zeigt, wie ein Farbwert eingefÑrbt wird;
<bg_col>, <fg_col>, <src> und <dst> sind
RGB-Farbwerte (zwischen 0 und 65535):
&nbsp;

!begin_verbatim
red_range = bg_col.red - fg_col.red;
green_range = bg_col.green - fg_col.green;
blue_range = bg_col.blue - fg_col.blue;

dst.red = fg_col.red + ( src_color.red * red_range / 65535 );
dst.green = fg_col.green + ( src_color.green * green_range / 65535 );
dst.blue = fg_col.blue + ( src_color.blue * blue_range / 65535 );
!end_verbatim

Hinweis: Momentan wird die EinfÑrbung in den Modi
T_REPLACE, T_TRANSPARENT, T_HILITE und T_REVERS_TRANSPARENT nur
fÅr Quellbitmaps mit bis zu 256 Farben unterstÅtzt. FÅr
Quellbitmaps mit 16 oder 32 Bit wird in diesen Modi zur Zeit keine
EinfÑrbung unterstÅtzt.
&nbsp;

!item Die arithmetischen Transfermodi unterstÅtzen keine
EinfÑrbung.
!end_itemize


Bitmaps

Statt eines antiquierten MFDBs erwartet diese Funktion eine
GCBITMAP-Struktur, um die Bitmaps zu beschreiben.


Wenn <ctab> 0L ist, wird die der Bittiefe entsprechende
Systemfarbtabelle fÅr den Aufruf benutzt (wenn die Bitmap mehr
als 8 Bit pro Pixel hat, d.h. direkte Farbwerte benutzt, kann
<ctab> ebenfalls auf 0L gesetzt werden).

Quellbitmaps benîtigen keine inverse Farbtabelle, hier kann
<itab> auf 0L gesetzt werden. Bei einer selbst verwalteten
Zielbitmap muû man vom VDI eine Referenz auf eine inverse
Farbtabelle anfordern (und irgendwann spÑter auch wieder
freigeben).

Vereinfachte SonderfÑlle

Damit Bitmaps im Format des Bildschirms auch ohne Anforderung
einer Farbtabelle und einer Referenz auf eine inverse Farbtabelle
Ñhnlich unkompliziert wie bei vro_cpyfm kopiert werden
kînnen, gibt es einige vereinfachte SonderfÑlle bei
vr_transfer_bits:
!begin_itemize

!item Wenn die Quelle keine Farbtabelle hat (0L), wird die Farbtabelle
des GerÑts genommen, wenn dieses die gleiche Bittiefe hat. Ist
das nicht der Fall, wird die Systemfarbtabelle fÅr die Bittiefe
der Quelle benutzt.

!item Wenn das Ziel keine (inverse) Farbtabelle hat (0L), wird die
(inverse) Farbtabelle des GerÑts genommen, wenn dieses die
gleiche Bittiefe hat. Ist das nicht der Fall, wird die
Systemfarbtabelle fÅr die Bittiefe des Ziels benutzt und fÅr
den Aufruf wird extra intern eine inverse Farbtabelle
aufgebaut. D.h. Zielbitmaps sollten, wenn sie keine inverse
Farbtabelle haben, umbedingt die gleiche Bittiefe wie das zum
VDI-Handle gehîrende GerÑt haben.
!end_itemize

Hinweis: Es empfiehlt sich, fÅr Bitmaps
auûerhalb des Bildschirms mit v_open_bm oder v_opnbm eine
Bitmap vom (!nolink [VDI]) erzeugen zu lassen, da man sich in diesem Fall nicht um
die Verwaltung von Farbtabellen und inversen Farbtabellen kÅmmern
muû.



Pixelformate

Um Bitmaps zwischen verschiedenen Bittiefen und Pixelformaten
wandeln zu kînnen, benîtigt TRANSFER BITMAP eine
Beschreibung des Pixelformats, die im Strukturelement
<px_format> enthalten ist. Der Aufbau dieses Bitvektors wird in
der folgenden Liste beschrieben; fÅr Programmierer dÅrften
aber vor allem die vordefinierten Formate interessant sein:


!begin_verbatim
/* Konstanten fÅr Pixelformate */
#define  PX_1COMP    0x01000000L /* Pixel besteht aus einer benutzten Komponente: Farbindex */
#define  PX_3COMP    0x03000000L /* Pixel besteht aus drei benutzten Komponenten, z.B. RGB */
#define  PX_4COMP    0x04000000L /* Pixel besteht aus vier benutzten Komponenten, z.B. CMYK */
#define  PX_REVERSED 0x00800000L /* Pixel wird in umgekehrter Bytereihenfolge ausgegeben */
#define  PX_xFIRST   0x00400000L /* unbenutzte Bits liegen vor den benutzen (im Motorola-Format betrachtet) */
#define  PX_kFIRST   0x00200000L /* K liegt vor CMY (im Motorola-Format betrachtet) */
#define  PX_aFIRST   0x00100000L /* Alphakanal liegen vor den Farbbits (im Motorola-Format betrachtet) */
#define  PX_PACKED   0x00020000L /* Bits sind aufeinanderfolgend abgelegt */
#define  PX_PLANES   0x00010000L /* Bits sind auf mehrere Ebenen verteilt (Reihenfolge: 0, 1, ..., n) */
#define  PX_IPLANES  0x00000000L /* Bits sind auf mehrere Worte verteilt (Reihenfolge: 0, 1, ..., n) */
#define  PX_USES1    0x00000100L /* 1 Bit des Pixels wird benutzt */
#define  PX_USES2    0x00000200L /* 2 Bit des Pixels werden benutzt */
#define  PX_USES3    0x00000300L /* 3 Bit des Pixels werden benutzt */
#define  PX_USES4    0x00000400L /* 4 Bit des Pixels werden benutzt */
#define  PX_USES8    0x00000800L /* 8 Bit des Pixels werden benutzt */
#define  PX_USES15   0x00000f00L /* 15 Bit des Pixels werden benutzt */
#define  PX_USES16   0x00001000L /* 16 Bit des Pixels werden benutzt */
#define  PX_USES24   0x00001800L /* 24 Bit des Pixels werden benutzt */
#define  PX_USES32   0x00002000L /* 32 Bit des Pixels werden benutzt */
#define  PX_USES48   0x00003000L /* 48 Bit des Pixels werden benutzt */
#define  PX_1BIT     0x00000001L /* Pixel besteht aus 1 Bit */
#define  PX_2BIT     0x00000002L /* Pixel besteht aus 2 Bit */
#define  PX_3BIT     0x00000003L /* Pixel besteht aus 3 Bit */
#define  PX_4BIT     0x00000004L /* Pixel besteht aus 4 Bit */
#define  PX_8BIT     0x00000008L /* Pixel besteht aus 8 Bit */
#define  PX_16BIT    0x00000010L /* Pixel besteht aus 16 Bit */
#define  PX_24BIT    0x00000018L /* Pixel besteht aus 24 Bit */
#define  PX_32BIT    0x00000020L /* Pixel besteht aus 32 Bit */
#define  PX_48BIT    0x00000030L /* Pixel besteht aus 48 Bit */
#define  PX_CMPNTS   0x0f000000L /* Maske fÅr Anzahl der Pixelkomponenten */
#define  PX_FLAGS    0x00f00000L /* Maske fÅr diverse Flags */
#define  PX_PACKING  0x00030000L /* Maske fÅr Pixelformat */
#define  PX_USED     0x00003f00L /* Maske fÅr Anzahl der benutzten Bits */
#define  PX_BITS     0x0000003fL /* Maske fÅr Anzahl der Bits pro Pixel */
/* Pixelformate fÅr ATARI-Grafik */
#define  PX_ATARI1   ( PX_PACKED + PX_1COMP + PX_USES1 + PX_1BIT )
#define  PX_ATARI2   ( PX_IPLANES + PX_1COMP + PX_USES2 + PX_2BIT )
#define  PX_ATARI4   ( PX_IPLANES + PX_1COMP + PX_USES4 + PX_4BIT )
#define  PX_ATARI8   ( PX_IPLANES + PX_1COMP + PX_USES8 + PX_8BIT )
#define  PX_FALCON15 ( PX_PACKED + PX_3COMP + PX_USES16 + PX_16BIT )
/* Pixelformate fÅr Mac */
#define  PX_MAC1     ( PX_PACKED + PX_1COMP + PX_USES1 + PX_1BIT )
#define  PX_MAC4     ( PX_PACKED + PX_1COMP + PX_USES4 + PX_4BIT )
#define  PX_MAC8     ( PX_PACKED + PX_1COMP + PX_USES8 + PX_8BIT )
#define  PX_MAC15    ( PX_xFIRST + PX_PACKED + PX_3COMP + PX_USES15 + PX_16BIT )
#define  PX_MAC32    ( PX_xFIRST + PX_PACKED + PX_3COMP + PX_USES24 + PX_32BIT )
/* Pixelformate fÅr Grafikkarten */
#define  PX_VGA1     ( PX_PACKED + PX_1COMP + PX_USES1 + PX_1BIT )
#define  PX_VGA4     ( PX_PLANES + PX_1COMP + PX_USES4 + PX_4BIT )
#define  PX_VGA8     ( PX_PACKED + PX_1COMP + PX_USES8 + PX_8BIT )
#define  PX_VGA15    ( PX_REVERSED + PX_xFIRST + PX_PACKED + PX_3COMP + PX_USES15 + PX_16BIT )
#define  PX_VGA16    ( PX_REVERSED + PX_PACKED + PX_3COMP + PX_USES16 + PX_16BIT )
#define  PX_VGA24    ( PX_REVERSED + PX_PACKED + PX_3COMP + PX_USES24 + PX_24BIT )
#define  PX_VGA32    ( PX_REVERSED + PX_xFIRST + PX_PACKED + PX_3COMP + PX_USES24 + PX_32BIT )
#define  PX_MATRIX16 ( PX_PACKED + PX_3COMP + PX_USES16 + PX_16BIT )
#define  PX_NOVA32   ( PX_PACKED + PX_3COMP + PX_USES24 + PX_32BIT )
/* Pixelformate fÅr Drucker */
#define  PX_PRN1     ( PX_PACKED + PX_1COMP + PX_USES1 + PX_1BIT )
#define  PX_PRN8     ( PX_PACKED + PX_1COMP + PX_USES8 + PX_8BIT )
#define  PX_PRN32    ( PX_xFIRST + PX_PACKED + PX_3COMP + PX_USES24 + PX_32BIT )
/* bevorzugte (schnelle) Pixelformate fÅr Bitmaps */
#define  PX_PREF1    ( PX_PACKED + PX_1COMP + PX_USES1 + PX_1BIT )
#define  PX_PREF2    ( PX_PACKED + PX_1COMP + PX_USES2 + PX_2BIT )
#define  PX_PREF4    ( PX_PACKED + PX_1COMP + PX_USES4 + PX_4BIT )
#define  PX_PREF8    ( PX_PACKED + PX_1COMP + PX_USES8 + PX_8BIT )
#define  PX_PREF15   ( PX_xFIRST + PX_PACKED + PX_3COMP + PX_USES15 + PX_16BIT )
#define  PX_PREF32   ( PX_xFIRST + PX_PACKED + PX_3COMP + PX_USES24 + PX_32BIT )
!end_verbatim

FÅr Programme, die selber Bitmaps erzeugen (oder laden) und
anschlieûend auf dem Bildschirm ausgeben wollen, sind besonders
die zuletzte angegeben Formate PX_PREFx zu empfehlen, da sie
bei einem anderen Pixelformat des Bidlschirms mit geringerem Aufwand
als einige andere Formate gewandelt werden kînnen.


!item [Ergebnis:]
Die Funktion liefert kein Ergebnis.

!item [VerfÅgbar:]
ab NVDI 5.00

Wenn der Treiber die neuen Rasterfunktionen,
anbietet, ist bei den erweiterten Parametern von vq_extnd in
work_out[30] Bit 1 gesetzt.
!item [Gruppe:]
Rasterfunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fÅr vr_transfer_bits])

(!ende_liste)
!end_node



!begin_node Bindings fÅr vr_transfer_bits
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
VOID vr_transfer_bits( WORD handle, GCBITMAP *src_bm, GCBITMAP *dst_bm,
                       RECT16 *src_rect, RECT16 *dst_rect, WORD mode );
!item [Implementierung:]
!begin_verbatim
VOID vr_transfer_bits( WORD handle, GCBITMAP *src_bm,
                       GCBITMAP *dst_bm, RECT16 *src_rect,
                       RECT16 *dst_rect, WORD mode )
{
   intin[o] = mode;
   intin[1] = 0;
   intin[2] = 0;
   intin[3] = 0;

   ptsin[0..3] = src_rect; 
   ptsin[4..7] = dst_rect; 

   contrl[0] = 170;
   contrl[1] = 4;
   contrl[3] = 4;
   contrl[5] = 0;
   contrl[6] = handle;
   contrl[7..8] = src_bm;
   contrl[9..10] = dst_bm;
   contrl[11..12] = 0;

   vdi ();
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0]    !! 170   Opcode der Funktion
contrl+2  !! contrl[1]    !! 4     # EintrÑge in ptsin
contrl+4  !! contrl[2]    !! 0     # EintrÑge in ptsout
contrl+6  !! contrl[3]    !! 4     # EintrÑge in intin
contrl+8  !! contrl[4]    !! 0     # EintrÑge in intout
contrl+10 !! contrl[5]    !! 0
contrl+12 !! contrl[6]    !! handle
contrl+14 !! contrl[7..8]    !! src_bm
contrl+18 !! contrl[9..10]    !! dst_bm
contrl+22 !! contrl[11..12]    !! 0
intin     !! intin[0] !! mode
intin+2   !! intin[1] !! 0
intin+4   !! intin[2] !! 0
ptsin     !! ptsin[0..3] !! src_rect
ptsin+8   !! ptsin[4..7] !! dst_rect
!end_table

(!ende_liste)
!end_node




!begin_node vr_trnfm

(!begin_liste) [Beschreibung:]

!item [Name:]
ØTransform FormÆ - wandelt ein Rasterbild um.

!item [VDI-Nummer:]
110

!item [Binding:]
(!link [Bindings fÅr vr_trnfm] [Bindings fÅr vr_trnfm])

!item [Beschreibung:]
Die Funktion transformiert ein Raster vom Standardformat in das
gerÑtespezifische Format oder umgekehrt. Es gilt:

!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation
!item [psrcMFDB]
Zeiger auf (!nolink [MFDB]) des Quellrasters
!item [pdesMFDB]
Zeiger auf (!nolink [MFDB]) des Zielrasters
!end_xlist

Beim Standardformat handelt es sich um ein plattformunabhÑngiges
Datenformat, welches daher zum Austausch von Dateien zwischen verschiedenen
GEM-Systemen benutzt werden kann.

(!B)Hinweis:(!b) Man kann dem VDI die Arbeit erleichtern, indem in
Quell/Ziel-MFDB unterschiedliche Rasteradressen angegeben werden;
anderenfalls kann eine Transformation durchaus mehrere Minuten in Anspruch
nehmen.

!item [Ergebnis:]
Die Funktion liefert kein Ergebnis.

!item [Gruppe:]
Rasterfunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fÅr vr_trnfm])  ~ vro_cpyfm ~  vrt_cpyfm ~  Rasterformate

(!ende_liste)
!end_node



!begin_node Bindings fÅr vr_trnfm
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
VOID vr_trnfm ( WORD handle, MFDB *psrcMFDB, MFDB *pdesMFDB );

!item [Implementierung:]
!begin_verbatim
VOID vr_trnfm (WORD handle, MFDB *psrcMFDB, MFDB *pdesMFDB)
{
   iptr (psrcMFDB);
   iptr_2 (pdesMFDB);

   contrl[0] = 110;
   contrl[1] = 0;
   contrl[3] = 0;
   contrl[6] = handle;

   vdi ();
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0]    !! 110   Opcode der Funktion
contrl+2  !! contrl[1]    !! 0     # EintrÑge in ptsin
contrl+4  !! contrl[2]    !! 0     # EintrÑge in ptsout
contrl+6  !! contrl[3]    !! 0     # EintrÑge in intin
contrl+8  !! contrl[4]    !! 0     # EintrÑge in intout
contrl+12 !! contrl[6]    !! handle
contrl+14 !! contrl[7,8]  !! psrcMFDB
contrl+18 !! contrl[9,10] !! pdesMFDB
!end_table

(!ende_liste)
!end_node



!begin_node vro_cpyfm

(!begin_liste) [Beschreibung:]

!item [Name:]
ØCopy Raster, OpaqueÆ - kopiert einen Speicherbereich.

!item [VDI-Nummer:]
109

!item [Binding:]
(!link [Bindings fÅr vro_cpyfm] [Bindings fÅr vro_cpyfm])

!item [Beschreibung:]
Die Funktion kopiert einen Quellspeicherbereich an ein Ziel und verknÅpft
dabei die Quelle und das Ziel durch die in (!I)vr_mode(!i) decodierte
logische VerknÅpfung. Es gilt:

!begin_xlist !short [pxyarray+0+]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation
!item [vr_mode]
eine von 16 logischen VerknÅpfungen zwischen den Pixeln des Quell- und
Zielraster
!begin_table [l l l]
ALL_WHITE  !! 0  !! D := 0
S_AND_D    !! 1  !! D := S AND D
S_AND_NOTD !! 2  !! D := S AND (NOT D)
S_ONLY     !! 3  !! D := S
NOTS_AND_D !! 4  !! D := (NOT S) AND D
D_ONLY     !! 5  !! D := D
S_XOR_D    !! 6  !! D := S XOR D
S_OR_D     !! 7  !! D := S OR D
NOT_SORD   !! 8  !! D := NOT (S OR D)
NOT_SXORD  !! 9  !! D := NOT (S XOR D)
D_INVERT   !! 10 !! D := NOT D
NOT_D      !! 11 !! D := S OR (NOT D)
S_OR_NOTD  !! 12 !! D := NOT S
NOTS_OR_D  !! 13 !! D := (NOT S) OR D
NOT_SANDD  !! 14 !! D := NOT (S AND D)
ALL_BLACK  !! 15 !! D := 1  
!end_table
!item [pxyarray[0!]]
x-Koordinate
!item [(!nolink [pxyarray])[1!]]
y-Koordinate eines Eckpunktes des Quellrasters
!item [(!nolink [pxyarray])[2!]]
x-Koordinate
!item [(!nolink [pxyarray])[3!]]
y-Koordinate des diagonal gegenÅberliegenden Eckpunktes des Quellrasters
!item [(!nolink [pxyarray])[4!]]
x-Koordinate
!item [(!nolink [pxyarray])[5!]]
y-Koordinate eines Eckpunktes des Zielrasters
!item [(!nolink [pxyarray])[6!]]
x-Koordinate
!item [(!nolink [pxyarray])[7!]]
y-Koordinate des diagonal gegenÅberliegenden Eckpunktes des Zielrasters
!item [psrcMFDB]
Zeiger auf den MFDB der Quelle
!item [pdesMFDB]
Zeiger auf den (!nolink [MFDB]) des Ziels
!end_xlist

(!B)Hinweis:(!b) Falls die Grîûen beider Raster nicht Åbereinstimmen, wird
die Grîûe des Quellrasters benutzt. Die Adresse des Zielrasters dient in
diesem Fall lediglich als Zeiger. Stimmen die Adressen von Quell- und
Zielbereich Åberein (und sind diese ungleich 0), und Åberlappen sich die
beiden Bereiche, so wird das Quellrechteck nicht verÑndert bis das
Zielrechteck fertig kopiert ist.

Normalerweise ignoriert die Funktion die Breite und Hîhe des Zielrasters und
geht von den Maûen des Quellrasters aus. Wenn ein Raster skaliert werden
soll,  muss daher das oberste Bit im VerknÅpfungsmodus gesetzt werden
((!I)vr_mode(!i)|0x8000). Die Funktion beachtet dann unterschiedliche
Ausmaûe und skaliert das Raster. Ob der jeweilige Treiber Raster skalieren
kann, sollte per vq_extnd ((!I)work_out(!i)[30]) ermittelt werden; das
oberste Bit im VerknÅpfungsmodus darf nur gesetzt werden, wenn der Treiber
Åber diese FÑhigkeit verfÅgt.

(!B)Wichtig:(!b) Raster im Standardformat (!I)kînnen und dÅrfen(!i) nicht
kopiert werden, da man im allgemeinen keine Informationen Åber das
gerÑtespezifische Format hat. Daher sollte ggfs. die Funktion vr_trnfm
benutzt werden.

(!B)Hinweis zu NVDI:(!b) In Ñlteren Druckertreibern hat diese Funktion
leider einen Fehler, der dazu fÅhrt, daû Bitmaps, die nur eine Zeile hoch
sind, evtl. nicht ausgegeben werden. Aus diesem Grund sollte die Åbergebene
Bitmap mindestens zwei Zeilen hoch sein.

!item [Ergebnis:]
Die Funktion liefert kein Ergebnis.

!item [Gruppe:]
Rasterfunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fÅr vro_cpyfm]) ~  vrt_cpyfm ~  vr_trnfm ~  Rasterformate

(!ende_liste)
!end_node



!begin_node Bindings fÅr vro_cpyfm
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
VOID vro_cpyfm ( WORD handle, WORD vr_mode, WORD *pxyarray, MFDB *psrcMFDB,
                 MFDB *pdesMFDB );

!item [Implementierung:]
!begin_verbatim
VOID vro_cpyfm (WORD handle, WORD vr_mode, WORD *pxyarray,
                MFDB *psrcMFDB, MFDB *pdesMFDB)
{
   intin[0]    = vr_mode;
   ptsin[0..7] = pxyarray[0..7];
   iptr (psrcMFDB);
   iptr2 (pdesMFDB);

   contrl[0] = 109;
   contrl[1] = 4;
   contrl[3] = 1;
   contrl[6] = handle;

   vdi ();
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0]    !! 109   Opcode der Funktion
contrl+2  !! contrl[1]    !! 4     # EintrÑge in ptsin
contrl+4  !! contrl[2]    !! 0     # EintrÑge in ptsout
contrl+6  !! contrl[3]    !! 1     # EintrÑge in intin
contrl+8  !! contrl[4]    !! 0     # EintrÑge in intout
contrl+12 !! contrl[6]    !! handle
contrl+14 !! contrl[7,8]  !! psrcMFDB
contrl+18 !! contrl[9,10] !! pdesMFDB
intin     !! intin[0]     !! vr_mode
ptsin     !! ptsin[0..7]  !! pxyarray[0..7]
!end_table

(!ende_liste)
!end_node



!begin_node vrt_cpyfm

(!begin_liste) [Beschreibung:]

!item [Name:]
ØCopy Raster, TransparentÆ - kopiert ein Monochromraster auf ein Farbraster.

!item [VDI-Nummer:]
121

!item [Binding:]
(!link [Bindings fÅr vrt_cpyfm] [Bindings fÅr vrt_cpyfm])

!item [Beschreibung:]
Die Funktion kopiert ein monochromes, rechteckiges Raster unter Beachtung
der Schreibmodi auf ein anderes (auch farbiges) rechteckiges Raster. Es
gilt:

!begin_xlist !short [color_index+0+]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation
!item [vr_mode]
Schreibmodus
!begin_xlist !short
!item [1 =]
Replace
!item [2 =]
Transparent
!item [3 =]
XOR
!item [4 =]
Reverse Transparent
!end_xlist
!item [pxyarray[0!]]
x-Koordinate
!item [(!nolink [pxyarray])[1!]]
y-Koordinate des Eckpunktes des Quellrasters
!item [(!nolink [pxyarray])[2!]]
x-Koordinate
!item [(!nolink [pxyarray])[3!]]
y-Koordinate der diagonal gegenÅber liegenden Ecke des Quellrasters
!item [(!nolink [pxyarray])[4!]]
x-Koordinate
!item [(!nolink [pxyarray])[5!]]
y-Koordinate des Eckpunktes des Zielrasters
!item [(!nolink [pxyarray])[6!]]
x-Koordinate
!item [(!nolink [pxyarray])[7!]]
y-Koordinate der diagonal gegenÅber liegenden Ecke des Zielrasters
!item [psrcMFDB]
Zeiger auf den MFDB der Quelle
!item [pdesMFDB]
Zeiger auf den (!nolink [MFDB]) des Ziels
!item [color_index[0!]]
Farbnummer der Farbe, die als gesetzt interpretiert werden soll
!item [color_index[1!]]
Farbnummer der Farbe, die als nicht gesetzt interpretiert werden soll
!end_xlist

(!B)Hinweis:(!b) Sollten die Grîûen beider Raster nicht Åbereinstimmen, so
werden die Grîûe des Quellrasters und die obere linke Ecke des Zielrasters
als Startpunkt benutzt. Der Bildschirm darf (!I)niemals(!i) als Quellraster
angegeben werden.

Normalerweise ignoriert die Funktion die Breite und Hîhe des Zielrasters und
geht von den Maûen des Quellrasters aus. Wenn ein Raster skaliert werden
soll, muss daher das oberste Bit im Schreibmodus gesetzt werden
((!I)vr_mode(!i)|0x8000). Die Funktion beachtet dann unterschiedliche
Ausmaûe und skaliert das Raster. Ob der jeweilige Treiber Raster skalieren
kann, sollte per vq_extnd ((!I)work_out(!i)[30]) ermittelt werden; das
oberste Bit im (!nolink [Schreibmodus]) darf nur gesetzt werden, wenn der Treiber Åber
diese FÑhigkeit verfÅgt.

(!B)Achtung:(!b) In Ñlteren NVDI-Druckertreibern hat diese Funktion leider
einen Fehler, der dazu fÅhrt, daû Bitmaps, die nur eine Zeile hoch sind,
evtl. nicht ausgegeben werden. Aus diesem Grund sollte die Åbergebene Bitmap
mindestens zwei Zeilen hoch sein.

!item [Ergebnis:]
Die Funktion liefert kein Ergebnis.

!item [Gruppe:]
Rasterfunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fÅr vrt_cpyfm]) ~  vro_cpyfm ~  vswr_mode ~  Rasterformate

(!ende_liste)
!end_node



!begin_node Bindings fÅr vrt_cpyfm
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
VOID vrt_cpyfm ( WORD handle, WORD vr_mode, WORD *pxyarray, MFDB *psrcMFDB,
                 MFDB *pdesMFDB, WORD *color_index );

!item [Implementierung:]
!begin_verbatim
VOID vrt_cpyfm (WORD handle, WORD vr_mode, WORD *pxyarray,
                MFDB *psrcMFDB, MFDB *pdesMFDB, WORD *color_index)
{
   intin[0]    = vr_mode;
   intin[1]    = *color_index++;
   intin[2]    = *color_index;
   ptsin[0..7] = pxyarray[0..7];

   iptr (psrcMFDB);
   iptr_2 (pdesMFDB);

   contrl[0] = 121;
   contrl[1] = 4;
   contrl[3] = 3;
   contrl[6] = handle;

   vdi ();
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0]    !! 121   Opcode der Funktion
contrl+2  !! contrl[1]    !! 4     # EintrÑge in ptsin
contrl+4  !! contrl[2]    !! 0     # EintrÑge in ptsout
contrl+6  !! contrl[3]    !! 3     # EintrÑge in intin
contrl+8  !! contrl[4]    !! 0     # EintrÑge in intout
contrl+12 !! contrl[6]    !! handle
contrl+14 !! contrl[7,8]  !! psrcMFDB
contrl+18 !! contrl[9,10] !! pdesMFDB
intin     !! intin[0]     !! vr_mode
intin+2   !! intin[1..2]  !! color_index[0..1]
ptsin     !! ptsin[0..7]  !! pxyarray[0..7]
!end_table

(!ende_liste)
!end_node




!begin_node vs_hilite_color

(!begin_liste) [Beschreibung:]

!item [Name:]
ØSet Hilite ColorÆ - setzt die Hervorhebungsfarbe.

!item [VDI-Nummer:]
207 (Unterfunktion 0)

!item [Binding:]
(!link [Bindings fÅr vs_hilite_color] [Bindings fÅr vs_hilite_color])

!item [Beschreibung:]
Diese Funktion setzt die Hervorhebungsfarbe.

!begin_xlist !short [hilite_color]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation

!item [color_space]
Farbraum (z.Zt.nur 0 fÅr eingestellten Farbraum oder CSPACE_RGB)

!item [hilite_color]
COLOR_ENTRY der Hervorhebungsfarbe

!end_xlist

!item [Ergebnis:]
-1 = falsche Unterfunktionsnummer (!nl)
~0 = Funktion nicht vorhanden (!nl)
~1 = alles in Ordnung

!item [VerfÅgbar:]
ab NVDI 5.00

!item [Gruppe:]
Rasterfunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fÅr vs_hilite_color])

(!ende_liste)
!end_node



!begin_node Bindings fÅr vs_hilite_color
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
WORD  vs_hilite_color( WORD handle, LONG color_space,
       COLOR_ENTRY *hilite_color );

!item [Implementierung:]
!begin_verbatim
WORD  vs_hilite_color( WORD handle, LONG color_space,
       COLOR_ENTRY *hilite_color )
{
   intin[0..1]    = color_space;
   intin[2..5]    = hilite_color;

   contrl[0] = 207;
   contrl[1] = 0;
   contrl[3] = 6;
   contrl[5] = 0;
   contrl[6] = handle;

   vdi ();
   
   return ( intout[0] );
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0]    !! 207   Opcode der Funktion
contrl+2  !! contrl[1]    !! 0     # EintrÑge in ptsin
contrl+4  !! contrl[2]    !! 0     # EintrÑge in ptsout
contrl+6  !! contrl[3]    !! 6     # EintrÑge in intin
contrl+8  !! contrl[4]    !! 1     # EintrÑge in intout
contrl+10 !! contrl[5]    !! 0
contrl+12 !! contrl[6]    !! handle
intin     !! intin[0..1]  !! color_space
intin+4   !! intin[2..5]  !! hilite_color
intout    !! intout[0]    !! RÅckgabewert
!end_table

(!ende_liste)
!end_node




!begin_node vs_max_color

(!begin_liste) [Beschreibung:]

!item [Name:]
ØSet Maximum ColorÆ - maximalen Farbwert fÅr eine additive Rasteroperation.

!item [VDI-Nummer:]
207 (Unterfunktion 2)

!item [Binding:]
(!link [Bindings fÅr vs_vs_max_colormin_color] [Bindings fÅr vs_max_color])

!item [Beschreibung:]
Diese Funktion setzt den maximalen Farbwert fÅr eine additive Rasteroperation.

!begin_xlist !short [color_space]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation

!item [color_space]
Farbraum (z.Zt.nur 0 fÅr eingestellten Farbraum oder CSPACE_RGB)

!item [max_color]
COLOR_ENTRY des maximalen Farbwerts fÅr T_SUB.

!end_xlist

!item [Ergebnis:]
-1 = falsche Unterfunktionsnummer (!nl)
~0 = Funktion nicht vorhanden (!nl)
~1 = alles in Ordnung

!item [VerfÅgbar:]
ab NVDI 5.00

!item [Gruppe:]
Rasterfunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fÅr vs_max_color])

(!ende_liste)
!end_node



!begin_node Bindings fÅr vs_max_color
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
WORD  vs_max_color( WORD handle, LONG color_space,
       COLOR_ENTRY *max_color );

!item [Implementierung:]
!begin_verbatim
WORD  vs_max_color( WORD handle, LONG color_space,
       COLOR_ENTRY *max_color )
{
   intin[0..1]    = color_space;
   intin[2..5]    = max_color;

   contrl[0] = 207;
   contrl[1] = 0;
   contrl[3] = 6;
   contrl[5] = 2;
   contrl[6] = handle;

   vdi ();
   
   return ( intout[0] );
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0]    !! 207   Opcode der Funktion
contrl+2  !! contrl[1]    !! 0     # EintrÑge in ptsin
contrl+4  !! contrl[2]    !! 0     # EintrÑge in ptsout
contrl+6  !! contrl[3]    !! 6     # EintrÑge in intin
contrl+8  !! contrl[4]    !! 1     # EintrÑge in intout
contrl+10 !! contrl[5]    !! 2
contrl+12 !! contrl[6]    !! handle
intin     !! intin[0..1]  !! color_space
intin+4   !! intin[2..5]  !! max_color
intout    !! intout[0]    !! RÅckgabewert
!end_table

(!ende_liste)
!end_node




!begin_node vs_min_color

(!begin_liste) [Beschreibung:]

!item [Name:]
ØSet Minimum ColorÆ - minimalen Farbwert fÅr eine subtraktive Rasteroperation.

!item [VDI-Nummer:]
207 (Unterfunktion 1)

!item [Binding:]
(!link [Bindings fÅr vs_min_color] [Bindings fÅr vs_min_color])

!item [Beschreibung:]
Diese Funktion setzt den minimalen Farbwert fÅr eine 
subtraktive Rasteroperation.

!begin_xlist !short [hilite_color]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation

!item [color_space]
Farbraum (z.Zt.nur 0 fÅr eingestellten Farbraum oder CSPACE_RGB)

!item [min_color]
COLOR_ENTRY des minimalen Farbwerts fÅr T_SUB.

!end_xlist

!item [Ergebnis:]
-1 = falsche Unterfunktionsnummer (!nl)
~0 = Funktion nicht vorhanden (!nl)
~1 = alles in Ordnung

!item [VerfÅgbar:]
ab NVDI 5.00

!item [Gruppe:]
Rasterfunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fÅr vs_min_color])

(!ende_liste)
!end_node



!begin_node Bindings fÅr vs_min_color
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
WORD  vs_min_color( WORD handle, LONG color_space,
       COLOR_ENTRY *min_color );

!item [Implementierung:]
!begin_verbatim
WORD  vs_min_color( WORD handle, LONG color_space,
       COLOR_ENTRY *min_color )
{
   intin[0..1]    = color_space;
   intin[2..5]    = min_color;

   contrl[0] = 207;
   contrl[1] = 0;
   contrl[3] = 6;
   contrl[5] = 1;
   contrl[6] = handle;

   vdi ();
   
   return ( intout[0] );
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0]    !! 207   Opcode der Funktion
contrl+2  !! contrl[1]    !! 0     # EintrÑge in ptsin
contrl+4  !! contrl[2]    !! 0     # EintrÑge in ptsout
contrl+6  !! contrl[3]    !! 6     # EintrÑge in intin
contrl+8  !! contrl[4]    !! 1     # EintrÑge in intout
contrl+10 !! contrl[5]    !! 1
contrl+12 !! contrl[6]    !! handle
intin     !! intin[0..1]  !! color_space
intin+4   !! intin[2..5]  !! min_color
intout    !! intout[0]    !! RÅckgabewert
!end_table

(!ende_liste)
!end_node




!begin_node vs_weight_color

(!begin_liste) [Beschreibung:]

!item [Name:]
ØSet Weight ColorÆ - Gewichtung fÅr die Blend-Funktion.

!item [VDI-Nummer:]
207 (Unterfunktion 3)

!item [Binding:]
(!link [Bindings fÅr vs_weight_color] [Bindings fÅr vs_weight_color])

!item [Beschreibung:]
Diese Funktion setzt die Gewichtung fÅr die Blend-Funktion.

!begin_xlist !short [weight_color]
!item [Parameter]
Bedeutung
!item [~]
~
!item [handle]
Kennung der Workstation

!item [color_space]
Farbraum (z.Zt.nur 0 fÅr eingestellten Farbraum oder CSPACE_RGB)

!item [weight_color]
COLOR_ENTRY der Gewichtung fÅr T_SUB.

!end_xlist

!item [Ergebnis:]
-1 = falsche Unterfunktionsnummer (!nl)
~0 = Funktion nicht vorhanden (!nl)
~1 = alles in Ordnung

!item [VerfÅgbar:]
ab NVDI 5.00

!item [Gruppe:]
Rasterfunktionen

!item [Querverweis:]
(!link [Binding] [Bindings fÅr vs_weight_color])

(!ende_liste)
!end_node



!begin_node Bindings fÅr vs_weight_color
!ignore_index

(!begin_liste) [Implementierung:]

!item [C:]
WORD  vs_weight_color( WORD handle, LONG color_space,
       COLOR_ENTRY *weight_color );

!item [Implementierung:]
!begin_verbatim
WORD  vs_weight_color( WORD handle, LONG color_space,
       COLOR_ENTRY *weight_color )
{
   intin[0..1]    = color_space;
   intin[2..5]    = weight_color;

   contrl[0] = 207;
   contrl[1] = 0;
   contrl[3] = 6;
   contrl[5] = 3;
   contrl[6] = handle;

   vdi ();
   
   return ( intout[0] );
}
!end_verbatim

!item [GEM-Arrays:]
!begin_table [l l l]
Adresse !! Feldelement !! Belegung
!hline
contrl    !! contrl[0]    !! 207   Opcode der Funktion
contrl+2  !! contrl[1]    !! 0     # EintrÑge in ptsin
contrl+4  !! contrl[2]    !! 0     # EintrÑge in ptsout
contrl+6  !! contrl[3]    !! 6     # EintrÑge in intin
contrl+8  !! contrl[4]    !! 1     # EintrÑge in intout
contrl+10 !! contrl[5]    !! 3
contrl+12 !! contrl[6]    !! handle
intin     !! intin[0..1]  !! color_space
intin+4   !! intin[2..5]  !! weight_color
intout    !! intout[0]    !! RÅckgabewert
!end_table

(!ende_liste)
!end_node
