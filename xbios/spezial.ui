!begin_node Blitmode
(!begin_liste) [Beschreibung:]
!item [Name:]
Øblitter modeÆ - Blitter-Chip konfigurieren.
!item [Xbiosnummer:]
64
!item [Binding:]
(!link [Bindings fÅr Blitmode] [Bindings fÅr Blitmode])
!item [Beschreibung:]
Blitmode ist eine XBIOS-Routine um den Blitter einzuschalten oder seine
Existenz festzustellen. Wenn im Parameter (!I)mode(!i) der Wert -1
angegeben wird, dann erhÑlt man den Status des Blitter-Chips. Bei allen
anderen Werten wird der Blitter konfiguriert:
!begin_table [r|l]
Bit !! Beschreibung
!hline
0 !! 0 = Blitter aus
~ !! 1 = Blitter ein
1-14 !! reserviert
15 !! muss immer 0 sein
!end_table
(!B)Hinweis:(!b) Lt. Atari darf die Funktion ohne Versions!-abfrage benutzt
werden (obwohl sie beispielsweise im TOS 1.0 nicht vorhanden ist).
Ermîglicht wird dies durch einen Seiteneffekt im
(!link [Dispatcher des XBIOS][Dispatcher, XBIOS-]).
Besser ist es allerdings, sich nicht darauf zu verlassen, da der
entsprechende Trap ja von anderen Programmen verbogen werden kann, und
dann evtl. nicht der richtige (!nolink [Return])-Wert zurÅckgeliefert wird.

Offiziell ist diese Funktion erst ab TOS-Version 1.02 vorhanden.
!item [Ergebnis:]
Die Funktion liefert als Ergebnis durch gesetzte Bits Eigenschaften des
Blitters-Chips:
!begin_table [c|l]
Bit !! Bedeutung
!hline
0 !! 0: Blitter aus
~ !! 1: Blitter an
~ !! ~
1 !! 0: Blitter nicht vorhanden
~ !! 1: Blitter vorhanden
~ !! ~
15 !! immer 0
!end_table
Alle weiteren Bits sind reserviert.
!item [Gruppe:]
Spezialbefehle
!item [Querverweis:]    (!link [Binding] [Bindings fÅr Blitmode])
(!ende_liste)
!end_node


!begin_node Bindings fÅr Blitmode
!ignore_index
(!begin_liste) [Assembler:]
!item [C:]
 #include <portab.h> (!nl)
 #include <tos.h>

WORD Blitmode ( WORD mode );
!item [Assembler:]
!begin_verbatim
move.w    mode,-(sp)   ; Offset 2
move.w    #64,-(sp)    ; Offset 0
trap      #14          ; XBIOS aufrufen
addq.l    #4,sp        ; Stack korrigieren
!end_verbatim
!ifdest [html]
!item [GFA-Basic]
!begin_raw
<A HREF="http://www.milanstation.de/at/gfahutil/gfau7xbi.htm">GFA-H-Util XBios</A>
!end_raw
!endif
(!ende_liste)
!end_node


!begin_node CacheCtrl
(!begin_liste) [Beschreibung:]
!item [Name:]
ØCacheCtrlÆ - CPU Cacheverwaltung
!item [Xbiosnummer:]
160
!item [Binding:]
(!link [Bindings fÅr CacheCtrl] [Bindings fÅr CacheCtrl])
!item [Beschreibung:]
Die XBIOS-Routine CacheCtrl dient zur Verwaltung der CPU-Caches
!begin_table [c|l]
 OpCode  !! Beschreibung
!hline
    0    !! Liefert 0 zurÅck, wenn die Funktion vorhanden ist.
    1    !! ZurÅckschreiben des Datencaches
    2    !! ZurÅckschreiben des Befehlscaches
    3    !! ZurÅckschreiben des Daten- und Befehlscaches
    4    !! Abfrage, ob Datencache aktiv ist
    5    !! Aktivieren/Deaktivieren des Datencaches
~~       !! (!I)mode(!i)= 0, ausschalten
~~       !! (!I)mode(!i)= 1, einschalten
~~       !! ZurÅckschreiben des Caches falls notwendig
    6    !! Abrage, ob Befehlscache aktiv ist
    7    !! Aktivieren/Deaktivieren des Befehlscaches
~~       !! (!I)mode(!i)= 0, ausschalten
~~       !! (!I)mode(!i)= 1, einschalten
~~       !! ZurÅckschreiben des Caches falls notwendig
!end_table

(!B)Note:(!b) (!nl)
Under the CT60 (!nolink [XBIOS]), OpCode 5/7 has the same effect : (!nl)
mode: 0 = disable all caches. (!nl)
~~~~~ 1 = enable all caches.  (!nl)
All caches ares : Data Cache, Store Buffer, Branch Cache, 
Instruction Cache.

!item [Ergebnis:]
Im Erfolgsfall liefert die Funktion den Wert 0 oder EBADRQ, wenn fÅr
(!I)OpCode(!i) ein Wert grîûer sieben Åbergeben wird.

!item [VerfÅgbar]
Die Funktion ist auf dem Milan seit TOS 4.06 verfÅgbar. Im CT60 (!nolink [XBIOS])
ab Version v0.98a.

Als Alternative steht auch der Treiber "CPU Cache Control Driver v1.10" von
Robert Federle und Thomas Tempelmann fÅr andere Rechner zur VerfÅgung.

!item [Gruppe:]
Spezialbefehle
!item [Querverweis:]    (!link [Binding] [Bindings fÅr CacheCtrl])
(!ende_liste)
!end_node


!begin_node Bindings fÅr CacheCtrl
!ignore_index
(!begin_liste) [Assembler:]
!item [C:]
LONG CacheCtrl ( WORD OpCode, WORD Param );
!item [Assembler:]
!begin_verbatim
move.w    Param,-(sp)  ; Offset 4
move.w    OpCode,-(sp) ; Offset 2
move.w    #160,-(sp)   ; Offset 0
trap      #14          ; XBIOS aufrufen
addq.l    #6,sp        ; Stack korrigieren
!end_verbatim
(!ende_liste)
!end_node




!begin_node CJar
(!begin_liste) [Beschreibung:]
!item [Name:]
ØCJarÆ - Erzeugen, Abfragen  und  Lîschen von Cookies
!item [Xbiosnummer:]
17226 (0x434A)
!item [Binding:]
(!link [Bindings fÅr CJar] [Bindings fÅr CJar])
!item [Beschreibung:]
Die XBIOS-Routine CJar dient auf komfortabele Weise zum Erzeugen, Abfragen  und  Lîschen
von Cookies.

!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [mode]
Modus 0: (!nl)
     Ermittelt  den  Wert  des  Kekses  und legt in an der angegebenen
     Adresse ab. öbergibt man fÅr 'value' einen NULL Pointer, so  wird
     lediglich die Existenz des Kekses ÅberprÅft. (!nl)
     Bei  erfolgreicher  Ermittlung  des  Kekses,  liefert  der Aufruf
     0x6172 (="CJar_OK") zurÅck sonst einen anderen Wert.

(!nl)

    Modus 1: (!nl)
     Erzeugt einen neuen Keks (cookie). (!I)Value(!i) (!B)zeigt(!b) auf einen Wert der
     in  den  Jar  eingetragen  wird.  WICHTIG!  Es wird nicht 'value'
     eingetragen  sondern  der  Wert  auf  den  'value'  weist!  Bei
     öbergabe eines NULL-Pointers wird 0 als Kekswert eingetragen.
     Existiert   der   Keks   bereits,   so  wird  sein  alter  Inhalt
     Åberschrieben! (!nl)
     Die Funktion liefert "CJar_OK" bei erfolgreicher  Eintragung.  -1
     wird fÅr den Fall geliefert, daû der Cookie-Jar voll ist!

(!nl)

Modus 2: (!nl)
     Entfernt  den Keks 'cookie' aus dem Jar. Der Wert von 'value' ist
     egal. Liefert bei erfolgreicher Entfernung "CJar_OK" sonst  einen
     anderen Wert.
     
     Ist nur VerfÅgbar wenn die  System!-erweiterung Liberty (Cookie 'Lity')
     installiert ist.

!item [cookie]
Cookiebezeichnung
!item [value]
Adresse des Puffers, in dem die Daten abgelegt werden sollen.
!end_xlist

!item [Ergebnis:]
Im Erfolgsfall liefert die Funktion den Wert CJar_OK (0x6172) zurÅck.

!item [VerfÅgbar]
Die Funktion ist verfÅgbar, wenn der Cookie 'CJar' ($434A6172) vorhanden ist.
Dieser wird von JARxxx (Cookie Jar Manager) oder Liberty erzeugt.
!item [Gruppe:]
Spezialbefehle
!item [Querverweis:]    (!link [Binding] [Bindings fÅr CJar])
(!ende_liste)
!end_node


!begin_node Bindings fÅr CJar
!ignore_index
(!begin_liste) [Assembler:]
!item [C:]
LONG CJar ( WORD mode, LONG cookie, LONG *value );
!item [Assembler:]
!begin_verbatim
pea       value          ; Offset 8
move.l    cookie,-(sp)   ; Offset 4
move.w    mode,-(sp)     ; Offset 2
move.w    #17226,-(sp)   ; Offset 0
trap      #14            ; XBIOS aufrufen
lea       12(sp),sp      ; Stack korrigieren
!end_verbatim
(!ende_liste)
!end_node




!begin_node Dbmsg
(!begin_liste) [Beschreibung:]
!item [Name:]
ØDbmsgÆ - 
!item [Xbiosnummer:]
11 
!item [Binding:]
(!link [Bindings fÅr Dbmsg] [Bindings fÅr Dbmsg])
!item [Beschreibung:]
Dbmsg() allows special debugging messages to be sent to a resident debugger
application.

Availability: The only debugger that currently supports this call is the Atari
Debugger.

(!I)srsrvd(!i) is currently reserved and should always be 5.

(!I)msg_num(!i) is themessage number which you want to send to the debugging host.
Values of 0x0000 to 0xEFFF are reserved for applications to define. Values of 0xF000
to 0xFFFF are reserved for special debugging messages. If (!I)msg_num(!i) is in the application
defined range, it and the LONG contained in (!I)msg_arg(!i) will be displayed by the
debugger and the application will be halted. If (!I)msg_num(!i) is between 0xF001 and
0xF0FF inclusive then (!I)msg_arg(!i) is interpreted as a character pointer pointing
to a string to be output by the debugger and debugging to halt. The string length
is determined by the low byte of (!I)msg_num(!i). (!nl)
If (!I)msg_num(!i) is DB_NULLSTRING (0xF000),
the string will be output until a NULL is reached. (!nl)
If (!I)msg_num(!i) is DB_COMMAND
(0xF100), (!I)msg_arg(!i) is interpreted as a character pointer to a string containing
a debugger command. The command format is specific to the debugger which you
are running. A useful example of this format when running under the Atari
debugger allows a string to be output to the debugger without terminating
debugging as shown in the following example:

Dbmsg( 5, DB_COMMAND, "echo 'Debugging Message';g" );

The Atari Debugger only understands the value DB_COMMAND (0xF100)
for (!I)msg_num(!i) as of version 3. Though it is normally harmless to run an
application with embedded debugging messages when no debugger is present in
the system, distribution versions of applications should have these instructions
removed.

!item [Ergebnis:]

!item [Gruppe:]
Spezialbefehle
!item [Querverweis:]    (!link [Binding] [Bindings fÅr Dbmsg])
(!ende_liste)
!end_node


!begin_node Bindings fÅr Dbmsg
!ignore_index
(!begin_liste) [Implementierung:]
!item [C:]
 #include <portab.h> (!nl)
 #include <tos.h>

VOID Dbmsg( WORD rsrvd, WORD msg_num, LONG msg_arg )
!item [Assembler:]
!begin_verbatim
move.l    msg_arg,-(sp)  ; Offset 6
move.w    msg_num,-(sp)  ; Offset 4
move.w    srsrvd,-(sp)   ; Offset 2
move.w    #11,-(sp)      ; Offset 0
trap      #14            ; XBIOS aufrufen
addq.l    #10,sp         ; Stack korrigieren
!end_verbatim
(!ende_liste)
!end_node


!begin_node Puntaes
(!begin_liste) [Beschreibung:]
!item [Name:]
Øpunt (!nolink [AES])Æ - AES abschalten.
!item [Xbiosnummer:]
39
!item [Binding:]
(!link [Bindings fÅr Puntaes] [Bindings fÅr Puntaes])
!item [Beschreibung:]
Die XBIOS-Routine Puntaes schaltet das (!nolink [AES])-Betriebs!-system ab. Diese
Funktion darf nicht verwendet werden, wenn sich das AES im ROM befindet.
!item [Ergebnis:]
Die Funktion liefert kein Ergebnis.
!item [Gruppe:]
Spezialbefehle
!item [Querverweis:]    (!link [Binding] [Bindings fÅr Puntaes])
(!ende_liste)
!end_node



!begin_node Bindings fÅr Puntaes
!ignore_index
(!begin_liste) [Assembler:]
!item [C:]
 #include <portab.h> (!nl)
 #include <tos.h>

VOID Puntaes ( VOID );
!item [Assembler:]
!begin_verbatim
move.w    #39,-(sp)    ; Offset 0
trap      #14          ; XBIOS aufrufen
addq.l    #2,sp        ; Stack korrigieren
!end_verbatim
!ifdest [html]
!item [GFA-Basic]
!begin_raw
<A HREF="http://www.milanstation.de/at/gfahutil/gfau7xbi.htm">GFA-H-Util XBios</A>
!end_raw
!endif
(!ende_liste)
!end_node


!begin_node Random
(!begin_liste) [Beschreibung:]
!item [Name:]
Ørandom generatorÆ - Zufallsgenerator.
!item [Xbiosnummer:]
17
!item [Binding:]
(!link [Bindings fÅr Random] [Bindings fÅr Random])
!item [Beschreibung:]
Die XBIOS-Routine Random liefert (basierend auf einem Zeitgeber des
Rechners) eine 24-Bit-Zufallszahl zurÅck.

(!B)Hinweis:(!b) Es handelt sich bei dieser Funktion (!I)nicht(!i) um einen
Hardware-Zufallszahlengenerator, sondern um eine Software-Version, die den
folgenden Algorithmus benutzt:
!begin_verbatim
X = (X * 3.1415926...) + 1
!end_verbatim
ZurÅckgeliefert wird der um 8 Bits nach rechts verschobene Wert X. Das
Verhalten fÅr die gesamte Zahl ist Åbrigens recht gut, die Abfrage
einzelner Bits im Sinne einer verminderten ZufÑlligkeit jedoch (!I)nicht(!i)
ratsam.
!item [Ergebnis:]
Die Funktion liefert als Ergebnis eine 24-Bit-Zufallszahl.
!item [Gruppe:]
Spezialbefehle
!item [Querverweis:]    (!link [Binding] [Bindings fÅr Random])
(!ende_liste)
!end_node


!begin_node Bindings fÅr Random
!ignore_index
(!begin_liste) [Assembler:]
!item [C:]
 #include <portab.h> (!nl)
 #include <tos.h>

LONG Random ( VOID ) ;
!item [Assembler:]
!begin_verbatim
move.w    #17,-(sp)    ; Offset 0
trap      #14          ; XBIOS aufrufen
addq.l    #2,sp        ; Stack korrigieren
!end_verbatim
!ifdest [html]
!item [GFA-Basic]
!begin_raw
<A HREF="http://www.milanstation.de/at/gfahutil/gfau7xbi.htm">GFA-H-Util XBios</A>
!end_raw
!endif
(!ende_liste)
!end_node


!begin_node Ssbrk
(!begin_liste) [Beschreibung:]
!item [Name:]
Øset memory break pointÆ - Speicherplatz reservieren.
!item [Xbiosnummer:]
1
!item [Binding:]
(!link [Bindings fÅr Ssbrk] [Bindings fÅr Ssbrk])
!item [Beschreibung:]
Die XBIOS-Routine Ssbrk reserviert Speicherplatz. Die Anzahl der Bytes muû
dabei in (!I)count(!i) Åbergeben werden. Diese Funktion muû vor der
Initialisierung des Betriebssystems aufgerufen werden, und sollte daher in
Anwenderprogrammen (!I)nicht(!i) verwendet werden. In allen
Atari-ROM-Versionen ist diese Funktion lediglich als Dummy-Routine
implementiert.
!item [Ergebnis:]
Die Funktion liefert die Anfangsadresse des allozierten Speicherbereiches
zurÅck.
!item [Gruppe:]
Spezialbefehle
!item [Querverweis:]    (!link [Binding] [Bindings fÅr Ssbrk])
(!ende_liste)
!end_node


!begin_node Bindings fÅr Ssbrk
!ignore_index
(!begin_liste) [Assembler:]
!item [C:]
 #include <portab.h> (!nl)
 #include <tos.h>

VOID *Ssbrk ( WORD count );
!item [Assembler:]
!begin_verbatim
move.w    count,-(sp)  ; Offset 2
move.w    #1,-(sp)     ; Offset 0
trap      #14          ; XBIOS aufrufen
addq.l    #4,sp        ; Stack korrigieren
!end_verbatim
!ifdest [html]
!item [GFA-Basic]
!begin_raw
<A HREF="http://www.milanstation.de/at/gfahutil/gfau7xbi.htm">GFA-H-Util XBios</A>
!end_raw
!endif
(!ende_liste)
!end_node


!begin_node Supexec
(!begin_liste) [Beschreibung:]
!item [Name:]
Øsupervisor executeÆ - fÅhrt Routine im Supervisor-Modus aus.
!item [Xbiosnummer:]
38
!item [Binding:]
(!link [Bindings fÅr Supexec] [Bindings fÅr Supexec])
!item [Beschreibung:]
Die XBIOS-Routine Supexec fÅhrt die Routine unter (!I)func(!i) im
Supervisor-Modus aus.
!item [Ergebnis:]
Die Funktion liefert den (!nolink [Return])-Wert der aufgerufenen Funktion zurÅck.
!item [Gruppe:]
Spezialbefehle
!item [Querverweis:]    (!link [Binding] [Bindings fÅr Supexec])  ~  Super
(!ende_liste)
!end_node


!begin_node Bindings fÅr Supexec
!ignore_index
(!begin_liste) [Assembler:]
!item [C:]
 #include <portab.h> (!nl)
 #include <tos.h>

LONG Supexec ( LONG (*func)( ) );
!item [Assembler:]
!begin_verbatim
pea       func         ; Offset 2
move.w    #38,-(sp)    ; Offset 0
trap      #14          ; XBIOS aufrufen
addq.l    #6,sp        ; Stack korrigieren
!end_verbatim
!ifdest [html]
!item [GFA-Basic]
!begin_raw
<A HREF="http://www.milanstation.de/at/gfahutil/gfau7xbi.htm">GFA-H-Util XBios</A>
!end_raw
!endif
(!ende_liste)
!end_node


!begin_node Trapper
(!begin_liste) [Beschreibung:]
!item [Name:]
ØTrapperÆ
!item [Xbiosnummer:]
555
!item [Binding:]
(!link [Bindings fÅr Trapper] [Bindings fÅr Trapper])
!item [Beschreibung:]
Mit Hilfe von Trapper kînnen sich andere Programme effektiv und
einfach vor und hinter Systemaufrufe hÑngen, diese sogar ganz
ersetzen, oder dem System neue Systemaufrufe hinzufÅgen.

Bei Trapper handelt sich es um ein externes Programm! Zu finden 
auf: http://www.mani.de/

Mehr Information in der dortigen Anleitung.

!item [Ergebnis:]
Die Funktion ist nur auf Computern vorhanden bei denen das Programm Trapper
installiert ist.
!item [Gruppe:]
Spezialbefehle
!item [Querverweis:]    (!link [Binding] [Bindings fÅr Trapper])
(!ende_liste)
!end_node


!begin_node Bindings fÅr Trapper
!ignore_index
(!begin_liste) [Assembler:]
!item [C:]
 #include <portab.h> (!nl)
 #include <tos.h>

LONG xbios ( 555, WORD layer, WORD install, WORD opcode, VOID *function );

!item [Assembler:]
!begin_verbatim
pea (a2)                  ; TOS does not save A2 in traps
move.l    function,-(sp)  ; Offset 8
move.w    opcode,-(sp)    ; Offset 6
move.w    install,-(sp)   ; Offset 4
move.w    layer,-(sp)     ; Offset 2
move.w    #555,-(sp)      ; Offset 0
trap      #14             ; XBIOS aufrufen
lea       12(sp),sp       ; Stack korrigieren
move.l    (sp)+,a2        ; restore A2
!end_verbatim
(!ende_liste)
!end_node


!begin_node WdgCtrl
(!begin_liste) [Beschreibung:]
!item [Name:]
ØWdgCtrlÆ - Einstellen des Hardware-Watchdog
!item [Xbiosnummer:]
161
!item [Binding:]
(!link [Bindings fÅr WdgCtrl] [Bindings fÅr WdgCtrl])
!item [Beschreibung:]
Diese Funktion de- oder aktiviert den Hardware-Watchdog.
!begin_table [l|l}
Parmeter !! wert
!hline
OpCode   !! 0x0000   -   return 0 to check that WdgCtrl is present
~        !! 0x1234   -   enable watchdog
~        !! 0xdead   -   disable watchdog
~        !! 0x4242   -   re-trigger watchdog
!end_table

(!B)Hinweis:(!b) Die Funktion macht nur auf der Hardware des Milans 2.1 und neuer
Sinn. Die Version gibt es allerdings nur als Spezialversion und ist nicht freiverfÅgbar.
Die Funktion ist ab dem MilanTOS mit dem Datum 9.6.2002 vorhanden.

!item [Ergebnis:]
   0 - OK (!nl)
   E_UNDEV (-15) - no watchdog present (!nl)
   E_BADRQ (-5)  - unimplemented OpCode (!nl)
!item [Gruppe:]
Spezialbefehle
!item [Querverweis:]    (!link [Binding] [Bindings fÅr WdgCtrl])
(!ende_liste)
!end_node



!begin_node Bindings fÅr WdgCtrl
!ignore_index
(!begin_liste) [Assembler:]
!item [C:]
 #include <portab.h> (!nl)
 #include <tos.h>

LONG xbios ( 161, WORD OpCode );

!item [Assembler:]
!begin_verbatim
pea (a2)                  ; TOS does not save A2 in traps
move.w    OpCode,-(sp)    ; Offset 2
move.w    #161,-(sp)      ; Offset 0
trap      #14             ; XBIOS aufrufen
lea       4(sp),sp       ; Stack korrigieren
move.l    (sp)+,a2        ; restore A2
!end_verbatim
(!ende_liste)
!end_node
