!iflang [english]


!begin_node XBIOS-Strukturen

!subtoc [stg, html]

!begin_node BCONMAP

Diese Struktur ist wie folgt definiert:
!begin_verbatim        
typedef struct
{
   MAPTAB  *maptab;      /* Liste der seriellen Schnittstellen */
   int16_t  maptabsize;  /* Anzahl der Schnittstellentreiber   */ 
} BCONMAP;

Querverweis: Bconmap
!end_verbatim
!end_node

!begin_node CD_DISC_INFO

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
   uint8_t  disctype;
   uint8_t  firsttrack, lasttrack, curtrack;
   uint8_t  relposz, relposm, relposs, relposf;
   uint8_t  absposz, absposm, absposs, absposf;
   uint8_t  endposz, endposm, endposs, endposf;
   uint8_t  index, res[3];
   uint32_t reserved[123];
} CD_DISC_INFO;
!end_verbatim

Querverweis: Metadiscinfo
!end_node


!begin_node CD_TOC_ENTRY

Die Struktur CD_TOC_ENTRY ist wie folgt definiert:

!begin_verbatim
typedef struct
{
   uint8_t trackno;
   uint8_t minute;
   uint8_t second;
   uint8_t frame;
} CD_TOC_ENTRY;
!end_verbatim

Querverweis: (!link [CD-ROM Opcodes fÅr Fcntl][Fcntl, CD-ROM-Kommandos fÅr])
!end_node 


!begin_node DSPBLOCK
Diese Struktur ist wie folgt definiert:
!begin_verbatim
typedef struct
{
   int16_t  blocktype;  /* Typ der Daten im Puffer: */
                        /*   0 : LongInt            */
                        /*   1 : Integer            */
                        /*   2 : Byte               */
   int32_t  blocksize;  /* Puffergrîûe              */
   void    *blockaddr;  /* Zeiger auf den Puffer    */
} DSPBLOCK;

!end_verbatim
Querverweis: Dsp_MultBlocks ~  DSP-Programmierung
!end_node

!begin_node KBDVBASE

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
   void   (*kb_midivec)();   /* MIDI Interrupt-Vektor    */
   void   (*kb_vkbderr)();   /* Tastatur Fehler-Vektor   */
   void   (*kb_vmiderr)();   /* MIDI Fehler-Vektor       */
   void   (*kb_statvec)();   /* Tastatur-Status          */
   void   (*kb_mousevec)();  /* Tastatur-Maus-Status     */
   void   (*kb_clockvec)();  /* Tastatur-Zeitgeber       */
   void   (*kb_joyvec)();    /* Tastatur-Joystick-Status */
   void   (*kb_midisys)();   /* System-Midi-Vektor       */
   void   (*kb_kbdsys)();    /* Tastatur-Vektor          */
   int8_t drvstat;           /* Tastatur-Treiberstatus   */
} KBDVBASE;
!end_verbatim

(!B)Hinweis:(!b) Bei den Komponenten (!I)kb_clockvec(!i) und
(!I)kb_joyvec(!i) ist zu beachten, daû die Adresse des Paketes im Register
A0 und auf dem Stack Åbergeben wird; die Routinen sollten auûerdem mit einem
RTS abgeschlossen sein, und nach Mîglichkeit nicht lÑnger als 1ms laufen.

Die Komponente (!I)drvstat(!i) enthÑlt einen Wert ungleich Null, wenn der
IKBD gerade eine Paket verschickt.

Querverweis: Kbdvbase
!end_node


!begin_node KEYTAB

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
   int8_t *unshift;       /* Tabelle 'normale' TastendrÅcke */
   int8_t *shift;         /* Tabelle Shift-TastendrÅcke     */
   int8_t *capslock;      /* Tabelle Capslock-TastendrÅcke  */
   int8_t *altunshift;    /* ab TOS 4.00, undokumentiert!   */
   int8_t *altshift;      /* ab TOS 4.00, undokumentiert!   */
   int8_t *altcapslock;   /* ab TOS 4.00, undokumentiert!   */
   int8_t *altgr;         /* ab TOS 4.06, undokumentiert!   */
} KEYTAB;
!end_verbatim

Querverweis: Keytbl

# Source: Mail von Rainer Seitel; Fido.ATARI_EXPERT.GER: A44399@KA
!end_node


!begin_node MAPTAB

Diese Struktur ist wie folgt definiert:
!begin_verbatim
typedef struct
{
   int16_t  (*Bconstat)(); 
   int32_t  (*Bconin)();
   int32_t  (*Bcostat)();
   void     (*Bconout)();
   uint32_t (*Rsconf)();
   IOREC    *iorec;
} MAPTAB;
!end_verbatim

Querverweis: Bconmap  ~ BCONMAP   
!end_node


!begin_node META_DRVINFO

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
   int8_t  *mdr_name;
   int32_t  reserved[3];
} META_DRVINFO;
!end_verbatim

Querverweis: Laufwerksfunktionen ~ Metaopen
!end_node

!begin_node META_INFO_1

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
   uint32_t    drivemap;  /* Bits fÅr MetaDOS Laufwerke.   */
                          /*   (Bit-0 = Laufwerk-A, usw.)  */
   int8_t      *version;  /* Name und Version von MetaDOS  */
   int32_t     reserved;  /* reserviert                    */
   META_INFO_2 *info;     /* Zeiger auf zweite Struktur    */
} META_INFO_1;
!end_verbatim

(!B)Hinweis:(!b) Die Komponente (!I)info(!i) ist erst ab (!nolink [MetaDOS]) V2.30
vorhanden!

Querverweis: Metainit
!end_node


!begin_node META_INFO_2

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
   uint16_t     mi_version;    /* Versionsnummer (0x230 = '02.30') */
   int32_t      mi_magic;      /* Magic-Konstante '_MET'           */
   const int8_t *mi_log2phys;  /* Zuordnung GEMDOS->MetaDOS        */
} META_INFO_2;
!end_verbatim

(!B)Hinweis:(!b) Diese Struktur existiert erst ab (!nolink [MetaDOS])
Version 2.30. Der Parameter (!I)mi_log2phys(!i) ist ein Zeiger auf ein Feld,
das zu jedem (!nolink [GEMDOS])-GerÑt den dazugehîrigen (!nolink [MetaDOS])
Laufwerksbuchstaben oder Null enthÑlt. Mit Hilfe dieser Information kann man
also feststellen, welcher (!nolink [MetaDOS]) Laufwerksbuchstabe zu welchem
(!nolink [GEMDOS])-Laufwerk gehîrt.

Querverweis: Metainit ~ META_INFO_1
!end_node


!begin_node MOD_DESC
!begin_verbatim
typedef struct
{
   int8_t  Name[34];   /* beschreibender Text     */
   int32_t colors;
   int16_t xres,yres;
   int32_t fileptr;    /* Zeiger in die Modedatei */
} MOD_DESC;
!end_verbatim

Querverweis: Crazy-Dots-XBIOS-Erweiterung
!end_node


!begin_node MOUSE

Diese Struktur ist wie folgt definiert:
!begin_verbatim
typedef struct
{
   int8_t  topmode;  /* 0: Y=0 am unteren Rand,    */
                     /* 1: Y=1 am oberen Rand      */
   int8_t  buttons;  /* analog IKBD                */
   int8_t  x_scale;  /* zusÑtzliche Parameter, vom */
   int8_t  y_scale;  /* gewÑhlten Modus abhÑngig.  */
   int16_t x_max;    /* maximale X-Position        */
   int16_t y_max;    /* maximale Y-Position        */
   int16_t x_start;  /* Anfangsposition X          */
   int16_t y_start;  /* Anfangsposition Y          */
} MOUSE;
!end_verbatim

(!B)Hinweis:(!b) Die Komponenten (!I)x_max(!i) und folgende sind nur im
absoluten Modus verfÅgbar.

Querverweis: GEM  ~ Initmouse ~  VDI
!end_node


!begin_node OVERPATCH
Diese Struktur ist wie folgt definiert:
!begin_verbatim
typedef struct
{
   int16_t low_w  ,mid_w  ,high_w;   /* Breite in Pixeln                */
   int16_t low_h  ,mid_h  ,high_h;   /* Hîhe   in Pixeln                */
   int32_t low_off,mid_off,high_off; /* Offset Bildspeicher<>Logbase    */
   int32_t mono_add,color_add;       /* ZusÑtzlicher Speicherbedarf     */
   int8_t  clear_scan;               /* Scancode  der Clear-Funktion    */
   int8_t  clear_shift;              /* Shiftcode der Clear-Funktion    */
   int8_t  setup_shift;              /* Shiftcode fÅr Setup (Maske)     */
   int8_t  invert_shift;             /* Shiftcode zum Invert. des Modus */
   int8_t  abort_shift;              /* Shiftcode zum Abbrechen         */
} OVERPATCH;
!end_verbatim
Querverweis: Oscanpatch ~  OverScan-XBIOS-Erweiterungen

!end_node


!begin_node PBDEF

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
   void    *pb_scrptr;  /* Zeiger auf Bildschirmanfang     */
   int16_t  pb_offset;  /* dazu zu addierender Offset      */
   int16_t  pb_width;   /* Bildschirmbreite in Punkten     */
   int16_t  pb_height;  /* Bildschirmhîhe in Punkten       */
   int16_t  pb_left;    /* Linker Rand in Punkten          */
   int16_t  pb_right;   /* Rechter Rand in Punkten         */  
   int16_t  pb_screz;   /* Auflîsung                       */
   int16_t  pb_prrez;   /* Druckertyp (Atari/Epson)        */
   void    *pb_colptr;  /* Zeiger auf Farbpalette          */
   int16_t  pb_prtype;  /* 0: Atari Matrix monochrom
                            1: Atari Matrix farbig
                            2: Atari Typenrad monochrom
                            3: Epson Matrix monochrom       */
   int16_t  pb_prport;  /* Schnittstelle Centronics/RS-232 */
   void    *pb_mask;    /* Zeiger auf Halbtonmaske         */
} PBDEF;
!end_verbatim

(!B)Hinweis:(!b) Es muû darauf geachtet werden, daû die Summe der
Komponenten (!I)pb_width(!i), (!I)pb_left(!i) und (!I)pb_right(!i) genau die
tatsÑchliche Bildschirmbreite ergibt.

Querverweis: Prtblk  ~ XBIOS

!end_node

!begin_node PMODE
!begin_verbatim
typedef struct  {
   int8_t  name[34];
   int16_t mode_id;       /* lfd. Nr.                             */
   int16_t xres,yres;     /* Breite/Hîhe in Pixeln                */
   int16_t fx,fy;         /* Breite/Hîhe gesamt                   */
   int32_t colors;        /* Anzahl gleichzeitiger Farben         */
   int16_t org;           /* Organisation des Speichers           */
   int16_t fh10,fv10;     /* Zeilenfreq.*10, Bildfreq*10          */
   int16_t aspect100;     /* 100*PixelBreite/PixelHîhe            */
   int16_t disp_scan100;
   int32_t clk;           /* Dotclock in Hz                       */
   /*
   * Register des Grafikcontrollers
   */
   int16_t Clock;         /* Frequenznummer, muû vorm Schreiben in */
                          /* das Clock-Register Åber die IcsLut
                             umgesetzt werden (s. u.)              */
   int8_t  misc_out;
   int8_t  ts[10];        /* Timing Sequencer Regs.                */
   int8_t  crtc[35];      /* CRT-Controller Regs.                  */
   int8_t  gdc[10];       /* Graphics Display Controller           */
   int8_t  atc[24];       /* Attribute Controller                  */
   int8_t  reserved[18];
} PMODE;

static int8_t IcsLut[32] = { 0,16,8,24,4,20,12,28,2,18,10,26,6,22,14,
               30,1,17,9,25,5,21,13,29,3,19,11,27,7,23,15,31 };
!end_verbatim

Querverweis: Crazy-Dots-XBIOS-Erweiterung ~ ReadMode ~ GetActiveModeDesc
!end_node


!begin_node SCREEN
!begin_verbatim
typedef struct 
{
   int8_t   xbra_id[4];       /* XBRA-Id: 'CDOT'                      */
   int8_t   version[4];       /* z.B.: '1.10'                         */
   int8_t  *sm194_addr;       /* Zeiger auf Groûbildschirmspeicher    */
   int8_t  *sm124_addr;       /* Zeiger auf SM124 Bildspeicher.       */
   LINEA   *line_A;           /* Zeiger auf LINE_A Block.             */
   int16_t  scrn_width;       /* Bildschirmweite                      */
   int16_t  scrn_height;      /* Bildschirmhîhe                       */
   int16_t  scrn_byte_width;  /* Bildschirmweite in Bytes             */
   int16_t  scrn_planes;      /* Bildschirmfarbebenen                 */
   int16_t  PhysMode;         /* Modusmummer                          */
   int16_t  VirtMode;         /* x/16 u. y/16 in je einem Byte cod.   */
   PMODE   *ModStruct;        /* Zeiger auf akt. Grafikmodus (s.u.)   */
   int16_t  grau;/* Flag fÅr den VDI-Treiber (Darstellung: Grau/Farbe)*/
   int16_t  BiosText;         /* Flag fÅr den VDI-Treiber             */
   int16_t  CurText;          /* Flag fÅr den VDI-Treiber             */
   int16_t  BlitMode;         /*           "                          */
} SCREEN;
!end_verbatim

Querverweis: Crazy-Dots-XBIOS-Erweiterung
!end_node


!begin_node SCREEN, OverScan
Diese Struktur ist wie folgt definiert:
!begin_verbatim
typedef struct
{
   int16_t width;             /* Breite in Pixel                     */
   int16_t height;            /* Hîhe   in Pixel                     */
   int16_t bytes_per_line;    /* Bytes pro Bildschirmzeile           */
   int32_t length_of_screen;  /* LÑnge des Bildspeichers in Bytes    */
   int32_t physbase_offset;   /* Offset Start-Bildspeicher<>Physbase */
   int32_t logbase_offset;    /* Offset Start-Bildspeicher<>Logbase  */  
} SCREEN;
!end_verbatim
Querverweis:  (!link [OverScan-XBIOS-Funktionen] [OverScan-XBIOS-Erweiterungen]) ~
Oscantab
!end_node

!begin_node VDO_MODE

!begin_verbatim
/* mode code xxxx xxxF SOPV 8NNN */
typedef struct 
{
   uint16_t Plan:3;            /* bit 0 Ö 2: NNN (nombre de plan)         */
   uint16_t _80Col:1;          /* bit 3: Flag 80 colonnes (8)             */
   uint16_t VGA:1;             /* bit 4: Flag VGA (V)                     */
   uint16_t Pal:1;             /* bit 5: Flag Pal (P)                     */
   uint16_t Overscan:1;        /* bit 6: Flag overscan (O)                */
   uint16_t STComp:1;          /* bit 7: Flag ST compatible (S)           */
   uint16_t Vertical:1;        /* bit 8: Flag Vertical (F)                */
   uint16_t NRJStart:1;        /* bit 9: mode energy star actif ou non    */
   uint16_t Eco:1;             /* bit 10: Çconomiseur actif ou non        */
   uint16_t Virtual:1;         /* bit 11: Çcran virtuel actif ou non      */
   uint16_t ExtClock:1;        /* bit 12: horloge externe 32/36MHz (CT2)  */
   uint16_t ExtClockEnable:1;  /* bit 13: validation de l'horloge externe */
   uint16_t StandardResol:1;   /* bit 14: rÇsolution standard             */
   uint16_t DefaultMode:1;     /* bit 15: mode vidÇo par dÇfaut           */
} VDO_MODE;
!end_verbatim

Querverweise: VDO_PARAM

!end_node 

!begin_node VDO_PARAM

!begin_verbatim
typedef struct
{
   int16_t V_Hdl;        /* handle                                 */
   VDO_MODE V_mode;      /* video mode like on Falcon              */
   int16_t  V_physw;     /* width of the physical screen           */
   int16_t  V_physh;     /* height of the physical screen          */
   int16_t  V_plan;      /* number of plane                        */
   int16_t  V_logw;      /* width of the virtual screen            */
   int16_t  V_logh;      /* height of the virtual screen           */
   int16_t  V_eco;       /* delay in seconds before shut down      */
   int16_t  V_eco2;      /* delay in seconds between the shut down */
                         /* and the Energy Star mode               */
   int8_t   V_name[33];  /* name of the video mode (32 bytes maxi) */
                         /* terminated by a 0.                     */
   int8_t   Reserved;    /* RÇservÇ pour un usage futur            */
   int32_t  V_length;    /* taille du buffer                       */
} VDO_PARAM;
!end_verbatim

Querverweise: Vread

!end_node

!begin_node VPOS

!begin_verbatim
typedef struct
{
   int16_t x;
   int16_t y;
} VPOS;
!end_verbatim

Querverweise: Vseek

!end_node


!else


!begin_node XBIOS-Strukturen

!subtoc [stg, html]

!begin_node BCONMAP

Diese Struktur ist wie folgt definiert:
!begin_verbatim        
typedef struct
{
   MAPTAB  *maptab;      /* Liste der seriellen Schnittstellen */
   int16_t  maptabsize;  /* Anzahl der Schnittstellentreiber   */ 
} BCONMAP;

Querverweis: Bconmap
!end_verbatim
!end_node

!begin_node CD_DISC_INFO

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
   uint8_t  disctype;
   uint8_t  firsttrack, lasttrack, curtrack;
   uint8_t  relposz, relposm, relposs, relposf;
   uint8_t  absposz, absposm, absposs, absposf;
   uint8_t  endposz, endposm, endposs, endposf;
   uint8_t  index, res[3];
   uint32_t reserved[123];
} CD_DISC_INFO;
!end_verbatim

Querverweis: Metadiscinfo
!end_node


!begin_node CD_TOC_ENTRY

Die Struktur CD_TOC_ENTRY ist wie folgt definiert:

!begin_verbatim
typedef struct
{
   uint8_t trackno;
   uint8_t minute;
   uint8_t second;
   uint8_t frame;
} CD_TOC_ENTRY;
!end_verbatim

Querverweis: (!link [CD-ROM Opcodes fÅr Fcntl][Fcntl, CD-ROM-Kommandos fÅr])
!end_node 


!begin_node DSPBLOCK
Diese Struktur ist wie folgt definiert:
!begin_verbatim
typedef struct
{
   int16_t  blocktype;  /* Typ der Daten im Puffer: */
                        /*   0 : LongInt            */
                        /*   1 : Integer            */
                        /*   2 : Byte               */
   int32_t  blocksize;  /* Puffergrîûe              */
   void    *blockaddr;  /* Zeiger auf den Puffer    */
} DSPBLOCK;

!end_verbatim
Querverweis: Dsp_MultBlocks ~  DSP-Programmierung
!end_node

!begin_node KBDVBASE

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
   void   (*kb_midivec)();   /* MIDI Interrupt-Vektor    */
   void   (*kb_vkbderr)();   /* Tastatur Fehler-Vektor   */
   void   (*kb_vmiderr)();   /* MIDI Fehler-Vektor       */
   void   (*kb_statvec)();   /* Tastatur-Status          */
   void   (*kb_mousevec)();  /* Tastatur-Maus-Status     */
   void   (*kb_clockvec)();  /* Tastatur-Zeitgeber       */
   void   (*kb_joyvec)();    /* Tastatur-Joystick-Status */
   void   (*kb_midisys)();   /* System-Midi-Vektor       */
   void   (*kb_kbdsys)();    /* Tastatur-Vektor          */
   int8_t drvstat;           /* Tastatur-Treiberstatus   */
} KBDVBASE;
!end_verbatim

(!B)Hinweis:(!b) Bei den Komponenten (!I)kb_clockvec(!i) und
(!I)kb_joyvec(!i) ist zu beachten, daû die Adresse des Paketes im Register
A0 und auf dem Stack Åbergeben wird; die Routinen sollten auûerdem mit einem
RTS abgeschlossen sein, und nach Mîglichkeit nicht lÑnger als 1ms laufen.

Die Komponente (!I)drvstat(!i) enthÑlt einen Wert ungleich Null, wenn der
IKBD gerade eine Paket verschickt.

Querverweis: Kbdvbase
!end_node


!begin_node KEYTAB

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
   int8_t *unshift;   /* Tabelle 'normale' TastendrÅcke */
   int8_t *shift;     /* Tabelle Shift-TastendrÅcke     */
   int8_t *capslock;  /* Tabelle Capslock-TastendrÅcke  */
} KEYTAB;
!end_verbatim

Querverweis: Keytbl
!end_node


!begin_node MAPTAB

Diese Struktur ist wie folgt definiert:
!begin_verbatim
typedef struct
{
   int16_t  (*Bconstat)(); 
   int32_t  (*Bconin)();
   int32_t  (*Bcostat)();
   void     (*Bconout)();
   uint32_t (*Rsconf)();
   IOREC    *iorec;
} MAPTAB;
!end_verbatim

Querverweis: Bconmap  ~ BCONMAP   
!end_node


!begin_node META_DRVINFO

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
   int8_t  *mdr_name;
   int32_t  reserved[3];
} META_DRVINFO;
!end_verbatim

Querverweis: Laufwerksfunktionen ~ Metaopen
!end_node

!begin_node META_INFO_1

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
   uint32_t    drivemap;  /* Bits fÅr MetaDOS Laufwerke.   */
                          /*   (Bit-0 = Laufwerk-A, usw.)  */
   int8_t      *version;  /* Name und Version von MetaDOS  */
   int32_t     reserved;  /* reserviert                    */
   META_INFO_2 *info;     /* Zeiger auf zweite Struktur    */
} META_INFO_1;
!end_verbatim

(!B)Hinweis:(!b) Die Komponente (!I)info(!i) ist erst ab (!nolink [MetaDOS]) V2.30
vorhanden!

Querverweis: Metainit
!end_node


!begin_node META_INFO_2

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
   uint16_t     mi_version;    /* Versionsnummer (0x230 = '02.30') */
   int32_t      mi_magic;      /* Magic-Konstante '_MET'           */
   const int8_t *mi_log2phys;  /* Zuordnung GEMDOS->MetaDOS        */
} META_INFO_2;
!end_verbatim

(!B)Hinweis:(!b) Diese Struktur existiert erst ab (!nolink [MetaDOS])
Version 2.30. Der Parameter (!I)mi_log2phys(!i) ist ein Zeiger auf ein Feld,
das zu jedem (!nolink [GEMDOS])-GerÑt den dazugehîrigen (!nolink [MetaDOS])
Laufwerksbuchstaben oder Null enthÑlt. Mit Hilfe dieser Information kann man
also feststellen, welcher (!nolink [MetaDOS]) Laufwerksbuchstabe zu welchem
(!nolink [GEMDOS])-Laufwerk gehîrt.

Querverweis: Metainit ~ META_INFO_1
!end_node


!begin_node MOD_DESC
!begin_verbatim
typedef struct
{
   int8_t  Name[34];   /* beschreibender Text     */
   int32_t colors;
   int16_t xres,yres;
   int32_t fileptr;    /* Zeiger in die Modedatei */
} MOD_DESC;
!end_verbatim

Querverweis: Crazy-Dots-XBIOS-Erweiterung
!end_node


!begin_node MOUSE

Diese Struktur ist wie folgt definiert:
!begin_verbatim
typedef struct
{
   int8_t  topmode;  /* 0: Y=0 am unteren Rand,    */
                     /* 1: Y=1 am oberen Rand      */
   int8_t  buttons;  /* analog IKBD                */
   int8_t  x_scale;  /* zusÑtzliche Parameter, vom */
   int8_t  y_scale;  /* gewÑhlten Modus abhÑngig.  */
   int16_t x_max;    /* maximale X-Position        */
   int16_t y_max;    /* maximale Y-Position        */
   int16_t x_start;  /* Anfangsposition X          */
   int16_t y_start;  /* Anfangsposition Y          */
} MOUSE;
!end_verbatim

(!B)Hinweis:(!b) Die Komponenten (!I)x_max(!i) und folgende sind nur im
absoluten Modus verfÅgbar.

Querverweis: GEM  ~ Initmouse ~  VDI
!end_node


!begin_node OVERPATCH
Diese Struktur ist wie folgt definiert:
!begin_verbatim
typedef struct
{
   int16_t low_w  ,mid_w  ,high_w;   /* Breite in Pixeln                */
   int16_t low_h  ,mid_h  ,high_h;   /* Hîhe   in Pixeln                */
   int32_t low_off,mid_off,high_off; /* Offset Bildspeicher<>Logbase    */
   int32_t mono_add,color_add;       /* ZusÑtzlicher Speicherbedarf     */
   int8_t  clear_scan;               /* Scancode  der Clear-Funktion    */
   int8_t  clear_shift;              /* Shiftcode der Clear-Funktion    */
   int8_t  setup_shift;              /* Shiftcode fÅr Setup (Maske)     */
   int8_t  invert_shift;             /* Shiftcode zum Invert. des Modus */
   int8_t  abort_shift;              /* Shiftcode zum Abbrechen         */
} OVERPATCH;
!end_verbatim
Querverweis: Oscanpatch ~  OverScan-XBIOS-Erweiterungen

!end_node


!begin_node PBDEF

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
   void    *pb_scrptr;  /* Zeiger auf Bildschirmanfang     */
   int16_t  pb_offset;  /* dazu zu addierender Offset      */
   int16_t  pb_width;   /* Bildschirmbreite in Punkten     */
   int16_t  pb_height;  /* Bildschirmhîhe in Punkten       */
   int16_t  pb_left;    /* Linker Rand in Punkten          */
   int16_t  pb_right;   /* Rechter Rand in Punkten         */  
   int16_t  pb_screz;   /* Auflîsung                       */
   int16_t  pb_prrez;   /* Druckertyp (Atari/Epson)        */
   void    *pb_colptr;  /* Zeiger auf Farbpalette          */
   int16_t  pb_prtype;  /* 0: Atari Matrix monochrom
                            1: Atari Matrix farbig
                            2: Atari Typenrad monochrom
                            3: Epson Matrix monochrom       */
   int16_t  pb_prport;  /* Schnittstelle Centronics/RS-232 */
   void    *pb_mask;    /* Zeiger auf Halbtonmaske         */
} PBDEF;
!end_verbatim

(!B)Hinweis:(!b) Es muû darauf geachtet werden, daû die Summe der
Komponenten (!I)pb_width(!i), (!I)pb_left(!i) und (!I)pb_right(!i) genau die
tatsÑchliche Bildschirmbreite ergibt.

Querverweis: Prtblk  ~ XBIOS

!end_node

!begin_node PMODE
!begin_verbatim
typedef struct  {
   int8_t  name[34];
   int16_t mode_id;       /* lfd. Nr.                             */
   int16_t xres,yres;     /* Breite/Hîhe in Pixeln                */
   int16_t fx,fy;         /* Breite/Hîhe gesamt                   */
   int32_t colors;        /* Anzahl gleichzeitiger Farben         */
   int16_t org;           /* Organisation des Speichers           */
   int16_t fh10,fv10;     /* Zeilenfreq.*10, Bildfreq*10          */
   int16_t aspect100;     /* 100*PixelBreite/PixelHîhe            */
   int16_t disp_scan100;
   int32_t clk;           /* Dotclock in Hz                       */
   /*
   * Register des Grafikcontrollers
   */
   int16_t Clock;         /* Frequenznummer, muû vorm Schreiben in */
                          /* das Clock-Register Åber die IcsLut
                             umgesetzt werden (s. u.)              */
   int8_t  misc_out;
   int8_t  ts[10];        /* Timing Sequencer Regs.                */
   int8_t  crtc[35];      /* CRT-Controller Regs.                  */
   int8_t  gdc[10];       /* Graphics Display Controller           */
   int8_t  atc[24];       /* Attribute Controller                  */
   int8_t  reserved[18];
} PMODE;

static int8_t IcsLut[32] = { 0,16,8,24,4,20,12,28,2,18,10,26,6,22,14,
               30,1,17,9,25,5,21,13,29,3,19,11,27,7,23,15,31 };
!end_verbatim

Querverweis: Crazy-Dots-XBIOS-Erweiterung ~ ReadMode ~ GetActiveModeDesc
!end_node


!begin_node SCREEN
!begin_verbatim
typedef struct 
{
   int8_t   xbra_id[4];       /* XBRA-Id: 'CDOT'                      */
   int8_t   version[4];       /* z.B.: '1.10'                         */
   int8_t  *sm194_addr;       /* Zeiger auf Groûbildschirmspeicher    */
   int8_t  *sm124_addr;       /* Zeiger auf SM124 Bildspeicher.       */
   LINEA   *line_A;           /* Zeiger auf LINE_A Block.             */
   int16_t  scrn_width;       /* Bildschirmweite                      */
   int16_t  scrn_height;      /* Bildschirmhîhe                       */
   int16_t  scrn_byte_width;  /* Bildschirmweite in Bytes             */
   int16_t  scrn_planes;      /* Bildschirmfarbebenen                 */
   int16_t  PhysMode;         /* Modusmummer                          */
   int16_t  VirtMode;         /* x/16 u. y/16 in je einem Byte cod.   */
   PMODE   *ModStruct;        /* Zeiger auf akt. Grafikmodus (s.u.)   */
   int16_t  grau;/* Flag fÅr den VDI-Treiber (Darstellung: Grau/Farbe)*/
   int16_t  BiosText;         /* Flag fÅr den VDI-Treiber             */
   int16_t  CurText;          /* Flag fÅr den VDI-Treiber             */
   int16_t  BlitMode;         /*           "                          */
} SCREEN;
!end_verbatim

Querverweis: Crazy-Dots-XBIOS-Erweiterung
!end_node


!begin_node SCREEN, OverScan
Diese Struktur ist wie folgt definiert:
!begin_verbatim
typedef struct
{
   int16_t width;             /* Breite in Pixel                     */
   int16_t height;            /* Hîhe   in Pixel                     */
   int16_t bytes_per_line;    /* Bytes pro Bildschirmzeile           */
   int32_t length_of_screen;  /* LÑnge des Bildspeichers in Bytes    */
   int32_t physbase_offset;   /* Offset Start-Bildspeicher<>Physbase */
   int32_t logbase_offset;    /* Offset Start-Bildspeicher<>Logbase  */  
} SCREEN;
!end_verbatim
Querverweis:  (!link [OverScan-XBIOS-Funktionen] [OverScan-XBIOS-Erweiterungen]) ~
Oscantab
!end_node

!begin_node VDO_MODE

!begin_verbatim
/* mode code xxxx xxxF SOPV 8NNN */
typedef struct 
{
   uint16_t Plan:3;           /* Bit 0-2: NNN (Anzahl Planes)       */
   uint16_t _80Col:1;         /* Bit 3: Flag 80 Spalten (8)         */
   uint16_t VGA:1;            /* Bit 4: Flag VGA (V)                */
   uint16_t Pal:1;            /* Bit 5: Flag Pal (P)                */
   uint16_t Overscan:1;       /* Bit 6: Flag overscan (O)           */
   uint16_t STComp:1;         /* Bit 7: Flag ST compatible (S)      */
   uint16_t Vertical:1;       /* Bit 8: Flag Vertical (F)           */
   uint16_t NRJStart:1;       /* Bit 9: Energy Star                 */
   uint16_t Eco:1;            /* Bit 10: Eenrgiesparmodus           */
   uint16_t Virtual:1;        /* Bit 11: virtueller Bildschirm      */
   uint16_t ExtClock:1;       /* Bit 12: externe Uhr 32/36MHz (CT2) */
   uint16_t ExtClockEnable:1; /* Bit 13: externen Uhr testen        */
   uint16_t StandardResol:1;  /* Bit 14: Standardauflîsung          */
   uint16_t DefaultMode:1;    /* Bit 15: default Videomode          */
} VDO_MODE;
!end_verbatim

Querverweise: VDO_PARAM

!end_node 

!begin_node VDO_PARAM

!begin_verbatim
typedef struct
{
   int16_t V_Hdl;        /* Handle                                  */
   VDO_MODE V_mode;      /* Videomodus wie beim Falcon              */
   int16_t  V_physw;     /* Breite des physikalischen Bildschirms   */
   int16_t  V_physh;     /* Hîhe des physikalischen Bildschirms     */
   int16_t  V_plan;      /* Anzahl Planes                           */
   int16_t  V_logw;      /* Breite des virtuellen Bildschirms       */
   int16_t  V_logh;      /* Hîhe des virtuellen Bildschirms         */
   int16_t  V_eco;       /* Delay in Sekunden vor Shutdown          */
   int16_t  V_eco2;      /* Delay in Sekunden zwischen Shutdown     */
                         /* und Energie Star Modus                  */
   int8_t   V_name[33];  /* Name des Videomodus (max. 32 Bytes)     */
                         /* mit 0 abgeschlossen.                    */
   int8_t   Reserved;    /* reserviert fÅr zukÅnftige Erweiterungen */
   int32_t  V_length;    /* Puffergrîûe                             */
} VDO_PARAM;
!end_verbatim

Querverweise: Vread

!end_node

!begin_node VPOS

!begin_verbatim
typedef struct
{
   int16_t x;
   int16_t y;
} VPOS;
!end_verbatim

Querverweise: Vseek

!end_node


!endif