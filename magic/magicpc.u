## Hypertext zum TOS-Betriebssystem
## entwickelt fÅr den ST-Guide
##
## Last Edit: 08.12.96
##
## Kapitel x: MagiCPC



!begin_node MagiCPC-Schnittstelle
!ignore_subtoc

(!U)0. Allgemeines(!u)

MPS = Magic_Programmier_Schnittstelle


Dateien des Demobeispieles:
!begin_xlist [mps_base.def ]
!item [mps_base.def]   Die Exportliste der DLL, NICHT éNDERN
!item [mps_base.h]  Definition der MPS_Schnittstelle, NICHT éNDERN
!item [mps_base.cpp]   Basis-Funktionen der DLL, NICHT éNDERN
!item [mps_demo.h]  Definitionen fÅr die Demo-DLL
!item [mps_demo.cpp]   Die MPS_Funktionen der Demo-DLL

!item [testmps.s]   Motorola - Beispiel zum Aufruf der MPS-Funktionen des Demo-Beispieles
!end_xlist

Um eigene MPS_DLLs zu entwickeln, verwenden Sie bitte (!nolink [mps_base.def]), (!nolink [mps_base.h]) und 
(!nolink [mps_base.cpp]) unverÑndert. Zu Ñndern/ergÑnzen sind (!nolink [mps_demo.h]) und (!nolink [mps_demo.cpp])
Insbesondere wÑhlen Sie bitte eine eigene DLL_ID in mps_demo.h zur Unterscheidung
von anderen MPS_DLLs.


(!U)I. Konzept(!u)

Windowsseitig kînnen Åber dynamische Bibliotheken (DLLs) beliebig viele 
Funktionen (im folgenden MPS_Funktionen genannt) eingerichtet werden, die 
innerhalb von MagiC_PC (motorolaseitig) aufgerufen werden kînnen.

In der Startphase versucht MagiC_PC, alle DLLs im Unterverzeichnis MPS zu laden
und zu starten. Dazu ruft MagiC_PC drei von der DLL zu exportierende 
Funktionen auf (in dieser Reihenfolge):
!begin_enumerate
!item mps_get_type():  muû 0x4701 liefern!
!item  mps_get_functionlist(...): ermittelt DLL_ID und MPS_Funktionsliste der DLL.
!item  mps_magicinfo: teilt MagiC_PC-eigene Daten/Funktionen mit, die die DLL bei
   Bedarf verwenden kann.
!end_enumerate

Alle in 2) angemeldeten Funktionen kînnen Åber spezielle Opcodes motorola-seitig
aufgerufen werden. NÑheres zum Aufruf siehe IV.


(!U)II. Zu exportierende Funktionen der DLL ("Basisfunktionen")(!u)


Eine MPS-DLL muû genau 3 C-Funktionen unter fester Ordinalzahl exportieren:
(auch Basisfunktionen genannt)
(siehe mfp_base.def, mfp_base.cpp, mfp_base.h)

!begin_itemize
!item @101: int mps_get_type()
   
   Zweck: Dient der RÅckversicherung, ob tatsÑchlich MPS_DLL erwischt.
   !! RÅckgabewert: 0x4701 !!

!item @102: int mps_get_functionlist(DWORD *mps_dll_id,MPS_fuptr **p_funktionsliste);

   Zweck: MagiC_PC mîchte DLL_ID und MPS_Funktionsliste wissen.

   RÅckgabewerte: (!nl)
   *mps_ddl_id:        DLL_ID (4 Bytes, DLL_spezifisch zu wÑhlen!) (!nl)
   *p_funktionsliste:  Zeiger auf Liste der MPS_Funktionen.  (!nl)
   return: 1: alles klar

!item @103: void mps_magicinfo(MPS_magicinfo *is);         

   Zweck: MagiC_PC teilt eigene Infos / Funktionspointer mit, die die DLL
   verwenden darf:
!label MPS_magicinfo
!begin_verbatim
   typedef struct {
    DWORD sizeof_str;               // Grîûe von MPS_magicinfo
    DWORD magic_version;            // z.B. 0x010001
    DWORD magic_date;               // z.B. 19960815      (aufsteigend)
    BYTE  is_demo;                  // Ist demoversion?
    BYTE  uu1, uu2, uu3;            // noch unbenutzt, 0

    BYTE *(*intel_adr)(DWORD motadr);   // Adressumrechnung Motorola -> Intel
    BYTE *(*intel_ptr)(DWORD motptr);   // Pointer-Umrechnung Motorola -> Intel (NULL bleibt NULL!)

    WORD (*swap_word)(WORD w);      // Ein Word swappen
    DWORD (*swap_long)(DWORD dw);   // Ein Langwort swappen
    } MPS_magicinfo;
!end_verbatim
   Die Adressumrechnungen ergeben NULL, falls motadr bzw motptr ungÅltig ist.
!end_itemize

(!U)III. Die frei definierbaren MPS_Funktionen einer DLL:(!u)

   MPS_Funktionen haben grundsÑtzlich die Form

      void funktion_blabla( MPS_motregs *motregs )

   motregs zeigt dabei auf die Liste der Motorola-Register d0-a7.
   Der Inhalt der Register ist schon im richtigen Intel-ByteSex.
   Die Motorola-Register dÅrfen auch mit neuen Werten beschrieben werden.

   Die DLL Åbergibt mit mps_get_functionlist die Liste der Adressen aller 
   solcher MPS_Funktionen. Die Funktionsnummern entsprechen 
   der Position der Funktion innerhalb der Liste. Soll eine Nummer freibleiben,
   ist als Adresse 0xffffffff (= -1) zu Åbergeben. Siehe auch mps_demo.cpp.


(!U)IV. Motorola-seitiger Aufruf(!u)

  MPS_Funktionen werden durch einen 8-Byte-Opcode motorola-seitig aufgerufen:

!begin_verbatim
    dc.w    $4fbf       * 2 Bytes: nicht Ñndern
    dc.l    DLL_ID      * 4 Bytes: DLL-spezifische DLL_ID
    dc.w    Fkt_Nr.     * 2 Bytes: Funktionsnummer.
!end_verbatim

  Die DLL_ID ist die Åber mps_get_functionlist mitgeteilte DLL_ID (4 Bytes!).
  Funktionsnummer ist die Position der Funktion in der Åber 
  mps_get_functionlist mitgeteilten Funktionsliste (ZÑhlung beginnt bei 0).


(!U)V. Sonstiges(!u)
!begin_enumerate
!item Jede DLL sollte eine individuelle DLL_ID verwenden, um Konflikte zwischen mehreren
   DLLs zu vermeiden (siehe mps_demo.h). 
   DLL_IDs mit gesetztem Bit 31 sind fÅr uns (Application Systems) bzw. fÅr zugeteilte 
   IDs reserviert. Bitte wÑhlen Sie deshalb keine DLL_ID mit  gesetztem Bit 31!
   Falls wir Ihnen eine reservierte DLL_ID zuteilen sollen, setzen Sie sich bitte mit
   Herrn Hoffmann von Application Systems in Verbindung.

!item Achten Sie auf die Verschiebung des Adressraumes!! (!nl)
   Wollen Sie eine Motorola-Adresse DLL-seitig verwenden, ist zur Konvertierung
   intel_adr(..) bzw.
   intel_ptr(..) 
   aufzurufen (siehe MPS_magicinfo in mps_base.h).
   (!nolink [Adressen]) aus dem DLL-Adressraum kînnen motorola-seitig NICHT verwendet werden!

!item Achten Sie auf den unterschiedlichen Byte-Sex zwischen Motorola- und Intel-Prozessor.
   Worte und Langworte aus dem Motorola-Adressraum mÅssen geswappt werden, damit sie
   in der DLL richtig vorliegen. Beim eventuellen zurÅckschreiben ist wieder zu swappen.
   Sie kînnen dazu die Funktionen
   swap_word(..) bzw.
   swap_long(..)
   aufrufen (siehe MPS_magicinfo in mps_base.h).
   Aber: Die Elemente von MPS_motregs (d0-a7) liegen schon intelmÑûig vor und mÅssen
   nicht mehr geswappt werden.
!end_enumerate


!begin_node mps_base.h
!begin_verbatim
; ========================================================
; Export-Definitionen fÅr MPS MagiC_PC Progr.Schnittstelle    FS 15.08.96
; ========================================================
;
; !! NICHT éNDERN !!
; ==================
EXPORTS
   mps_get_type         @101
   mps_get_functionlist @102
   mps_magicinfo        @103
!end_verbatim
!end_node

!begin_node mps_base.def
!begin_verbatim
// Tabsize: 3

// Letzte énderung:  15.08.96    
// Autor:   FS

// ------------------------------------------------------------------------------
//
// Die MagiC_PC - Programmier-Schnittstelle
//
// mps_base.h: Basis-Include     !! UNVERéNDERT öBERNEHMEN !!
//                               ======================

#ifdef __cplusplus   
   extern "C" {
#endif

/* =========================================================================
   Die vom Anwender frei definierbaren DLL-Funktionen haben die Form
   void mps_funktion(MPS_motregs *r),
   wobei r ein Pointer auf die 16 Motorola-Register darstellt, also:
*/ 
   typedef struct {                 // MPS_motregs = Die Motorola-Register
     long d0,d1,d2,d3,d4,d5,d6,d7;
     long a0,a1,a2,a3,a4,a5,a6,a7;
     } MPS_motregs;
                                    // MPS_fuptr = Pointer auf eine MPS_Funktion:
   typedef void (*MPS_fuptr)(MPS_motregs *);    


/* ============================================================
   Der DLL-Basisfunktion mps_info wird der folgende Infoblock 
   MPS_infostr mitgegeben:
*/
   typedef struct {
     DWORD sizeof_str;           // Grîûe von MPS_infostr
     DWORD magic_version;        // z.B. 0x010001
     DWORD magic_date;           // z.B. 19960815     (aufsteigend)
     BYTE  is_demo;              // Ist demoversion?
     BYTE  uu1, uu2, uu3;        // noch unbenutzt, 0

     BYTE *(*intel_adr)(DWORD motadr); // Adressumrechnung Motorola -> Intel
     BYTE *(*intel_ptr)(DWORD motptr); // Pointer-Umrechnung Motorola -> Intel (NULL bleibt NULL!)

     WORD (*swap_word)(WORD w);           // Ein Word swappen
     DWORD (*swap_long)(DWORD dw);        // Ein Langwort swappen
     } MPS_magicinfo;

// =============== zu exportieren sind 3 Basisfunktionen: ==================
//
   int mps_get_type();                                                        // @101
   int mps_get_functionlist(DWORD *mps_dll_id,MPS_fuptr **p_funktionsliste);  // @102
   void mps_magicinfo(MPS_magicinfo *is);                                     // @103
// 
// siehe auch mps_base.cpp, mps_base.def
   

#ifdef __cplusplus   
   } 
#endif
!end_verbatim

Querverweise: MagiCPC-Schnittstelle
!end_node

!begin_node mps_base.cpp
!begin_verbatim
// Tabsize: 3

// Letzte énderung:  15.08.96    
// Autor:   FS

// ------------------------------------------------------------------------------
// Demobeispiel zu MagiC_PC - Programmier-Schnittstelle (MPS)
//
// Teil 1: Basisfunktionen, UNVERéNDERT Åbernehmen!
// =======
//
// ------------------------------------------------------------------------------

#include "windows.h"
#include "mps_base.h"
#include "mps_demo.h"

// 
// Die folgenden 3 Basisfunktionen mÅssen von der DLL exportiert werden:
//


// 1) Basisfuktion @101: Typabfrage
// ---------------------
   int mps_get_type()
// ----------------
 {
   return(0x4701);         // muû diesen Wert zurÅckgeben
 }

// 2) Basisfuktion @102: MagiC_PC fordert Id und Funktionsliste an.
// ---------------------
   int mps_get_functionlist(DWORD *mps_dll_id,MPS_fuptr **p_funktionsliste)
// ------------------------
 {
   *mps_dll_id = DLL_ID;               // benutzerdefinierte ID, siehe mps_demo.h
   *p_funktionsliste = my_funclist;    // Zeiger auf Funktionsliste eintragen
   return(1);
 }

// 3) Basisfuktion @103: MagiC_PC Åbergibt MPS_magicinfo an die DLL
// ---------------------
   void mps_magicinfo(MPS_magicinfo *is)
// -------------
 {
   m_info = *is;                    // Merken
 }

//
// ENDE Basisfunktionen -------------------------------------------------------
//

!end_verbatim

Querverweise: MagiCPC-Schnittstelle
!end_node

!begin_node mps_demo.h
!begin_verbatim
// Tabsize: 3

// Letzte énderung:  15.08.96    
// Autor:   FS

// ------------------------------------------------------------------------------
// Demobeispiel zu MagiC_PC - Programmier-Schnittstelle (MPS)
//
// Teil 2: Benutzer-definierte Funktionen, DLL_ID auf eigenen Wert Ñndern !!!
// =======
//
// ------------------------------------------------------------------------------

#define DLL_ID  0x01020304             // auf eigenen Wert Ñndern. 
                                       // !! Werte mit gesetztem Bit 31 reserviert fÅr Appl.Systems.
                                       // ID-Reservierung: Bei Appl.Systems (Herrn Hoffmann) anfragen!

   extern MPS_fuptr my_funclist[];     // Die Funktionsliste in der Demo-DLL

   extern MPS_magicinfo m_info;        // wird von MagiC_PC Åbernommen
!end_verbatim

Querverweise: MagiCPC-Schnittstelle
!end_node

!begin_node mps_demo.cpp
!begin_verbatim
// Tabsize: 3

// Letzte énderung:  15.08.96    
// Autor:   FS

// ------------------------------------------------------------------------------
// Demobeispiel zu MagiC_PC - Programmier-Schnittstelle (MPS)
//
// Teil 2: Benutzer-definierte Funktionen, frei Ñnderbar.
// =======
//
// ------------------------------------------------------------------------------

#include "windows.h"
#include "mps_base.h"
#include "mps_demo.h"

   MPS_magicinfo m_info;               // global fÅr die DLL

// 
// Liste der benutzerdefinierten Funktionen (nach Bedarf Ñndern/erweitern):
// -----------------------------------------------------------------------
   static void demo_0(MPS_motregs *r);
   static void demo_1(MPS_motregs *r);
   static void demo_3(MPS_motregs *r);
   static void copy_string(MPS_motregs *r);

   MPS_fuptr my_funclist[] = {
     demo_0,                           // Demo-Funktion 0
     demo_1,                           // Demo-Funktion 1
     (MPS_fuptr) -1,                   // -1 (d.h Funktion Nummer 2 nicht definiert)
     demo_3,                           // Demo-Funktion 3
     copy_string,                      // Demo-Funktion 4
     NULL                              // !! Am Listenende ein NULL-Eintrag !!
     } ;


// *******************************************************************************
//
// Hier die benutzerdefinierten Funktionen:
// ========================================
//

// Demo_0 liefert nur in d0 den Wert 1 zurÅck:
//
   static void demo_0(MPS_motregs *r)
// ----------------------
 {
   r->d0 = 1;                       // Demo-0 setzt d0 auf 1
   return;
 }

// Demo_1 addiert die Register d1 und d2; Ergebnis nach d0:
// 
   static void demo_1(MPS_motregs *r)
// ----------------------
 {
   r->d0 = r->d1 + r->d2;           
   return;
 }

// Demo_3 tut gar nichts:
//
   static void demo_3(MPS_motregs *r)
// ----------------------
 {
   return;
 }

// Demo-Routine4 copy_string kopiert einen String in den Motorola-Adressraum:
//               -----------
// a0: Ziel-Adresse,
// d0: Maximalzahl der Zeichen (incl. 0)
//
   static void copy_string(MPS_motregs *r)
// -----------------------
 {
   static char string[] = "Dies ist ein Demo-Text von copy_string(..)";

   int i, nchmax;
   char *ziel;

   nchmax = (int) r->d0;
   ziel = (char *) (*m_info.intel_ptr)(r->a0);
   if (nchmax<=0 || ziel==NULL) return;         // ungÅltig?

   for (i=0; i<nchmax; i++) {
     if ((ziel[i] = string[i])==0)
       return;
     }
   ziel[nchmax-1] = 0;                          // zu lange->abschneiden
   return;
 }
!end_verbatim

Querverweise: MagiCPC-Schnittstelle

!end_node

!begin_node testmps.s
!begin_verbatim

*                                                 FS  15.08.96
*
*   =============================================================
*   Beispiel fÅr den Aufruf der MPS-Funktionen von Motorola aus
*   =============================================================
*
* Quelle Windows-seitig:
* ----------------------
* mps_base.cpp, mps_demo.cpp
*
mps_code .equ  $4fbf                   * !! NICHT éNDERN !!
DLL_ID   .equ  $01020304               * hier eigene DLL_ID eintragen

* -------------------------------------- 60 Bytes Puffer
bufsize  .equ  60
.bss
.even
buffer:   ds.w  bufsize
* --------------------------------------


*
* ------------------- Hier gehts los: ---------------------------------
*
.text
.globl _main
_main:
      moveq    #-1,d0                  * d0 auf -1 (zum Testen)

*     ===========================      * Funktion 0 (Demo_0) aufrufen:
      dc.w     mps_code                * = $4fbf 
      dc.l     DLL_ID                  * = eigene DLL_ID
      dc.w     0                       * Funktionsnummer (hier 0)
*     ===========================
      cmpi.l   #1,d0                   * mÅûte 1 zurÅckliefern
      bne      fertig

* Beispiel fÅr Aufruf mit Parametern (copy_string)
* ----------------------------------
      movea.l  #buffer,a0              * Zeiger auf Puffer fÅr String
      move.l   #bufsize,d0             * Max. StringlÑnge (incl.0-Byte).

*     ===========================      * Funktion 4 (copy_string) aufrufen:
      dc.w     mps_code                * = $4fbf 
      dc.l     DLL_ID                  * = eigene DLL_ID
      dc.w     4                       * Funktionsnummer (hier 4)
*     ===========================

      bsr      put_line                * Zeile (a0) ausgeben
fertig:
      bsr      wait                    * Auf Tastendruck warten
      rts
*
* --------------------- ENDE Hauptroutine _main ------------------------
*


* ------------------------ Zeile (a0) ausgeben -----------------------
put_line:
      moveq    #13,d0
      bsr      put_char
      moveq    #10,d0
put_lnext:
      bsr      put_char
      move.b   (a0)+,d0
      bne      put_lnext
      rts

* ------------------------ Zeichen d0 ausgeben -----------------------
put_char:
      movem.l  d0-d2/a0-a2,-(sp)
      move.w   d0,-(sp)
      move.w   #2,-(sp)
      move.w   #3,-(sp)
      trap     #13
      addq.l   #6,sp
      movem.l  (sp)+,d0-d2/a0-a2
      rts

* -------------------------- auf Tastendruck warten. --------------------
wait:
      move.w   #2,-(sp)
      move.w   #2,-(sp)
      trap     #13
      addq.l   #4,sp
      rts

!end_verbatim

Querverweise: MagiCPC-Schnittstelle
!end_node


!end_node
