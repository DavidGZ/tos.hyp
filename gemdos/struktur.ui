!begin_node GEMDOS-Strukturen

!subtoc [stg, html]


!begin_node cd_ad

Diese Union ist wie folgt definiert:

!begin_verbatim
typedef union
{
    struct
    {
           BYTE reserved;    /* reserviert */
           BYTE minute;      /* Minute     */
           BYTE second;      /* Sekunde    */
           BYTE frame;       /* Frame      */
    } msf;
    LONG lba;
} cd_ad;
!end_verbatim

Querverweis: (!link [CD-ROM Opcodes fÅr Fcntl][Fcntl, CD-ROM-Kommandos fÅr])
!end_node


!begin_node cdrom_audioctrl

Diese Struktur ist wie folgt definiert:

!begin_verbatim
struct cdrom_audioctrl
{
    /* Eingabe-Parameter */
    SHORT set;                   /* 0 = nur nachfragen */
    /* Ein-/Ausgabe-Parameter */
    struct
    {
        BYTE selection;
        BYTE volume;
    } channel[4];    
};
!end_verbatim

Querverweis: (!link [CD-ROM Opcodes fÅr Fcntl][Fcntl, CD-ROM-Kommandos fÅr])
!end_node 


!begin_node cdrom_mcn

Diese Struktur ist wie folgt definiert:

!begin_verbatim
struct cdrom_mcn
{
    BYTE  mcn_audiostatus;
    BYTE  mcn_mcn[23];       /* Media-Katalog-Nummer als ASCII-String */
};
!end_verbatim

Querverweis: (!link [CD-ROM Opcodes fÅr Fcntl][Fcntl, CD-ROM-Kommandos fÅr]) ~
ASCII-Tabelle
!end_node


!begin_node cdrom_msf

Diese Struktur ist wie folgt definiert:

!begin_verbatim
struct cdrom_msf
{
    BYTE cdmsf_min0;       /* Anfangs-Minute  */
    BYTE cdmsf_sec0;       /* Anfangs-Sekunde */
    BYTE cdmsf_frame0;     /* Anfangs-Frame   */
    BYTE cdmsf_min1;       /* Ende-Minute     */
    BYTE cdmsf_sec1;       /* Ende-Sekunde    */
    BYTE cdmsf_frame1;     /* Ende-Frame      */
};
!end_verbatim

Querverweis: (!link [CD-ROM Opcodes fÅr Fcntl][Fcntl, CD-ROM-Kommandos fÅr])
!end_node


!begin_node cdrom_read

Diese Struktur ist wie folgt definiert:

!begin_verbatim
struct cdrom_read
{
    LONG  cdread_lba;       /* Adresse               */
    BYTE *cdread_bufaddr;   /* Zeiger auf den Puffer */
    LONG  cdread_buflen;    /* LÑnge des Puffers     */
};
!end_verbatim

Querverweis: (!link [CD-ROM Opcodes fÅr Fcntl][Fcntl, CD-ROM-Kommandos fÅr])
!end_node


!begin_node cdrom_subchnl

Diese Struktur ist wie folgt definiert:

!begin_verbatim
struct cdrom_subchnl
{
    /* Eingabe-Parameter */
    BYTE cdsc_format;             /* CDROM_MSF oder CDROM_LBA */
    /* Ausgabe-Parameter */
    BYTE     cdsc_audiostatus;
    UNSIGNED cdsc_resvd: 8;       /* reserviert */
    UNSIGNED cdsc_adr  : 4;
    UNSIGNED cdsc_ctrl : 4;
    BYTE   cdsc_track;            /* aktueller Track        */
    BYTE   cdsc_ind;              /* aktueller Index        */
    cd_ad  cdsc_absaddr;          /* absolute Adresse       */
    cd_ad  cdsc_reladdr;          /* relative Track-Adresse */
};
!end_verbatim

Querverweis: (!link [CD-ROM Opcodes fÅr Fcntl][Fcntl, CD-ROM-Kommandos fÅr])
!end_node


!begin_node cdrom_ti

Diese Struktur ist wie folgt definiert:

!begin_verbatim
struct cdrom_ti
{
    BYTE cdti_trk0;        /* Start-Track */
    BYTE cdti_ind0;        /* Start-Index */
    BYTE cdti_trk1;        /* Ende-Track  */
    BYTE cdti_ind1;        /* Ende-Index  */
};
!end_verbatim

Querverweis: (!link [CD-ROM Opcodes fÅr Fcntl][Fcntl, CD-ROM-Kommandos fÅr])
!end_node


!begin_node cdrom_tochdr

Diese Struktur ist wie folgt definiert:

!begin_verbatim
struct cdrom_tochdr
{
    BYTE cdth_trk0;        /* Start-Track */
    BYTE cdth_trk1;        /* Ende-Track  */
};
!end_verbatim

Querverweis: (!link [CD-ROM Opcodes fÅr Fcntl][Fcntl, CD-ROM-Kommandos fÅr])
!end_node


!begin_node cdrom_tocentry

Diese Struktur ist wie folgt definiert:

!begin_verbatim
struct cdrom_tocentry
{
    /* Eingabe-Parameter */
    BYTE cdte_track;               /* Track-Nummer oder CDROM_LEADOUT */
    BYTE cdte_format;              /* CDROM_LBA oder CDROM_MSF        */
    /* Ausgabe-Parameter */
    UNSIGNED cdte_adr:4;           /* SUBQ Channel Encodes; es gilt:
                                      0 = keine
                                      1 = Positions-Daten
                                      2 = MCN
                                      3 = ISRC
                                      (alle anderen Werte reserviert) */
    UNSIGNED cdte_ctrl:4;          /* Bit-0: Audio mit Pre-Emphasis
                                      Bit-1: digitale Kopie mîglich
                                      Bit-2: Daten Track
                                      Bit-3: 4-Kanal  */
    BYTE     cdte_datamode;        /* z.Zt. unbenutzt */
    cd_ad    dte_addr;             /* Track-Start     */
};
!end_verbatim

Querverweis: (!link [CD-ROM Opcodes fÅr Fcntl][Fcntl, CD-ROM-Kommandos fÅr])
!end_node


!begin_node cdrom_tisrc

Diese Struktur ist wie folgt definiert:

!begin_verbatim
struct cdrom_tisrc
{
    /* Eingabe-Parameter */
    BYTE tisrc_track;            /* Track-Nummer */
    /* Ausgabe-Parameter */
    BYTE tisrc_audiostatus;
    BYTE tisrc_tisrc[23];      /* Track International Standard
                                  Recording Code als ASCII-String */
};
!end_verbatim

Querverweis: (!link [CD-ROM Opcodes fÅr Fcntl][Fcntl, CD-ROM-Kommandos fÅr]) ~
ASCII-Tabelle
!end_node


!begin_node cdrom_volctrl

Diese Struktur ist wie folgt definiert:

!begin_verbatim
struct cdrom_volctrl
{
    BYTE  channel0;   /* Kanal-1: LautstÑrke 0...255 */
    BYTE  channel1;   /* Kanal-2: LautstÑrke 0...255 */
    BYTE  channel2;   /* Kanal-3: LautstÑrke 0...255 */
    BYTE  channel3;   /* Kanal-4: LautstÑrke 0...255 */
};
!end_verbatim

Querverweis: (!link [CD-ROM Opcodes fÅr Fcntl][Fcntl, CD-ROM-Kommandos fÅr])
!end_node


!begin_node CD-ROM Definitionen

!begin_verbatim
/* Adressierungs-Typen */
#define CDROM_LBA               0x01
#define CDROM_MSF               0x02

/* SUB-Q Kontroll-Bits */

#define CDROM_AUDIO_EMPHASIS    0x01
#define CDROM_COPY_PERMITTED    0x02
#define CDROM_DATA_TRACK        0x04
#define CDROM_FOUR_CHANNEL      0x08
#define CDROM_LEADOUT           0xAA   

/* RÅckgabewerte von READ SUBCHANNEL DATA */

#define CDROM_AUDIO_INVALID     0x00 
#define CDROM_AUDIO_PLAY        0x11
#define CDROM_AUDIO_PAUSED      0x12
#define CDROM_AUDIO_COMPLETED   0x13
#define CDROM_AUDIO_ERROR       0x14
#define CDROM_AUDIO_NO_STATUS   0x15
!end_verbatim

Querverweis: (!link [CD-ROM Opcodes fÅr Fcntl][Fcntl, CD-ROM-Kommandos fÅr])
!end_node


!begin_node DISKINFO

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
    ULONG   b_free;    /* Anzahl der freien Cluster */
    ULONG   b_total;   /* Gesamtzahl der Cluster    */
    ULONG   b_secsiz;  /* Bytes pro Sektor          */
    ULONG   b_clsiz;   /* Sektoren pro Cluster      */
} DISKINFO;
!end_verbatim

Querverweis:
Dfree ~  GEMDOS
!end_node


!begin_node DOSTIME

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
   UWORD     time;  /* Zeit wie in Tgettime  */
   UWORD     date;  /* Datum wie in Tgetdate */
} DOSTIME;
!end_verbatim

Die Struktur der beiden Integer-Werte gliedert sich wie folgt:

!begin_xlist !short [11-15]
!item [Bit]
time
!item [~]
~
!item [0-4]
Sekunden in Zweierschritten (0-29)
!item [5-10]
Minuten (0-59)
!item [11-15]
Stunden (0-23)
!end_xlist

!begin_xlist !short [9-15]
!item [Bit]
date
!item [~]
~
!item [0-4]
Tag im Monat (1-31)
!item [5-8]
Monat (1-12)
!item [9-15]
Jahr (0-119, 0=1980)
!end_xlist

Querverweis: Fdatime ~ GEMDOS
!end_node


!begin_node DOSVARS

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
   BYTE      *in_dos;                 /* Adresse der DOS- Semaphore */
   WORD      *dos_time;               /* Adresse der DOS- Zeit      */
   WORD      *dos_date;               /* Adresse des DOS- Datums    */
   LONG      res1;                    /*                            */
   LONG      res2;                    /*                            */
   LONG      res3;                    /* ist 0L                     */
   VOID      *act_pd;                 /* Laufendes Programm         */
   LONG      res4;                    /*                            */
   WORD      res5;                    /*                            */
   VOID      *res6;                   /*                            */
   VOID      *res7;                   /* interne DOS- Speicherliste */
   VOID      (*resv_intmem)();        /* DOS- Speicher erweitern    */
   LONG      (*etv_critic)();         /* etv_critic des GEMDOS      */
   BYTE *    ((*err_to_str)(BYTE e)); /* Umrechnung Code->Klartext  */
   LONG      res8;                    /*                            */
   LONG      res9;                    /*                            */
   LONG      res10;                   /*                            */
} DOSVARS;
!end_verbatim

(!B)Hinweis:(!b) Diese Variablen sind READ-ONLY !

Mit Hilfe der Funktion (!I)resv_intmem(!i) lÑût sich Ñhnlich wie mit
FOLDRnnnn Speicher fÅr die interne Speicherverwaltung reservieren. Im
Gegensatz zu TOS wird diese jedoch deutlich weniger belastet, so daû ein
Erweitern i.a. nicht notwendig ist. Muû der Speicher erweitert werden, was
auch in ADDMEM geschieht, Åbergibt man der Funktion (!I)resv_intmem(!i) in
Register A0 die Adresse, und in Register D0 die LÑnge des zu reservierenden
Speicherblocks.

(!B)Der Prototyp fÅr den (!I)Event-Critic-Handler(!i) lautet:(!b)
!begin_verbatim
LONG etv_critic (WORD errcode, WORD drvnr)
!end_verbatim
Man beachte, daû die Funktion die Argumente auf dem Stack erwartet, und
daher in (!I)Pure-C(!i) als (!I)cdecl(!i) deklariert werden muû.

Die Funktion (!I)err_to_str(!i) erwartet in Register D0 einen
TOS-Fehlercode, und gibt in den Registern D0 und A0 einen Zeiger auf die
beschreibende Zeichenkette zurÅck. Bei einem ungÅltigen Fehlercode erhÑlt
man in D0 eine Null, und in A0 einen Zeiger auf die Zeichenkette
'TOS-Fehler'.

Querverweis: AESVARS ~ (!link [Cookie von MagiC][Cookie, MagX]) ~ Sconfig
!end_node

!begin_node DTA

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct
{
    BYTE    d_reserved[21];  /* fÅr GEMDOS reserviert */
    UBYTE   d_attrib;        /* Datei-Attribut        */
    UWORD   d_time;          /* Uhrzeit               */
    UWORD   d_date;          /* Datum                 */
    ULONG   d_length;        /* DateilÑnge            */
    BYTE    d_fname[14];     /* Dateiname             */
} DTA;
!end_verbatim

(!B)rekursive Suche in Ordnern(!b)

In je einer DTA werden genau alle nîtigen Informationen gespeichert,
die nach einem (!nolink [Fsfirst]) fÅr weitere (!nolink [Fsnext]) benîtigt werden.
Das heiût, daû auf keinen Fall erneut (!nolink [Fsfirst]) fÅr andere
Verzeichnisse/Wildcards aufrufen sollte, solange noch weitere
(!nolink [Fsnext])-Aufrufe in der Ebene gemachen werden. (!nl)
Bei einer rekursiven Suche muût fÅr jedes neue (!nolink [Fsfirst]) eine eigene
DTA verwendet werden, die solange erhalten bleiben muû, bis alle
(!nolink [Fsnext]) fÅr den (!nolink [Fsfirst]) getÑtigt sind.
Hier ein Bsp in pseudo-C:

!begin_verbatim
void durchsuche_verzeichnis (char *pfadname)
{
  DTA_Record local_dta, saved_dta;
 
  saved_dta = GetDTA ();
  SetDTA (local_dta);
 
  err = Fsfirst (pfadname, ...);
  while (err == 0) {
    if (local_dta.attrib == subdir) {
      // rekursive suche in sub-dir
      durchsuche_verzeichnis (subdir-pfadname);
    } else {
      ... normales file auswerten
    }
    err = Fsnext ();
  }
 
  SetDTA (saved_dta);
}
!end_verbatim

Querverweis: Fgetdta ~ Fsetdta ~Fsfirst ~ Fsnext~ GEMDOS
!end_node

!begin_node flock, Fcntl

!begin_verbatim
struct flock
{
    SHORT l_type;     /* Art des Lockings */
    SHORT l_whence;   /* SEEK_SET, SEEK_CUR, SEEK_END */
    LONG  l_start;    /* Start des Locking-Bereiches  */
    LONG  l_len;      /* LÑnge des Locking-Bereiches  */
    SHORT l_pid;      /* PID des sperrenden Prozesses */
};
!end_verbatim

(!B)Hinweis:(!b) Mîgliche Werte fÅr l_type sind 0 = Read-Locking, 1 =
Write-Locking sowie 3 = kein Locking.
!end_node


!begin_node ltchars

Diese Struktur ist wie folgt definiert:

!begin_verbatim
struct ltchars
{
    BYTE t_suspc;
    BYTE t_dsuspc;
    BYTE t_rprntc;
    BYTE t_flushc;
    BYTE t_werasc;
    BYTE t_lnextc;
};
!end_verbatim
!end_node


!begin_node Process-Descriptor (PD) bzw. BASEPAGE
!label PD
!label BASEPAGE
Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct pd
{
   VOID   *p_lowtpa;      /* Anfangsadresse der TPA            */
   VOID   *p_hitpa;       /* erstes Byte nach dem Ende der TPA */
   VOID   *p_tbase;       /* Anfangsadresse des Programmcodes  */
   LONG   p_tlen;         /* LÑnge des Programmcodes           */
   VOID   *p_dbase;       /* Anfangsadresse des DATA-Bereichs  */
   LONG   p_dlen;         /* LÑnge des DATA-Abschnittes        */
   VOID   *p_bbase;       /* Anfangsadresse des BSS-Bereichs   */
   LONG   p_blen;         /* LÑnge des BSS-Abschnittes         */
   DTA    *p_dta;         /* Zeiger auf Default-DTA.           */
                          /* Achtung: zeigt zunÑchst in die    */
                          /* Kommandozeile !                   */
   struct pd *p_parent;   /* Zeiger auf die Basepage des auf-  */
                          /* rufenden Prozesses                */
   LONG   p_resrvd0;      /* reserviert                        */                          
   BYTE   *p_env;         /* Adresse der Environment-Strings   */
   BYTE   p_resrvd1[80];  /* reserviert                        */
   BYTE   p_cmdlin[128];  /* Kommandozeile                     */
} PD; /* auch: BASEPAGE */
!end_verbatim

(!B)Hinweis zur Kommandozeile:(!b) Im ersten Byte wird die Anzahl der
Zeichen eingesetzt. Die maximale LÑnge der Kommandozeile belÑuft sich
(!I)nicht(!i) auf 127, sondern nur auf 124 Zeichen!

Querverweis: GEMDOS ~ OSHEADER ~ Pexec ~ Programmstart und TPA
!end_node

!begin_node ploadinfo

Diese Struktur ist wie folgt definiert:

!begin_verbatim
struct ploadinfo
{
   SHORT fnamelen;  /* LÑnge von 'fname'                         */
   BYTE *cmdlin;    /* Kommandozeile des Prozesses (128 Bytes)   */
   BYTE *fname;     /* vollst. Pfad- und Dateiname des Prozesses */
};
!end_verbatim

Querverweis: Fcntl ~ PLOADINFO
!end_node

!begin_node sgttyb

Diese Struktur ist wie folgt definiert:

!begin_verbatim
struct sgttyb
{
    BYTE   sg_ispeed;
    BYTE   sg_ospeed;
    BYTE   sg_erase;
    BYTE   sg_kill;
    USHORT sg_flags;
};
!end_verbatim
!end_node


!begin_node struct sigaction
!label sigaction

Diese Struktur ist wie folgt definiert:

!begin_verbatim
struct sigaction
{
   VOID  cdecl (*sa_handler)(LONG sig);
   LONG  sa_mask;
   WORD  sa_flags;
};
!end_verbatim

(!B)Hinweis:(!b) Die Komponente (!I)sa_handler(!i) kann dabei verschiedene
Werte annehmen. Ein Wert von 0 bedeutet eine Default-Signal-Behandlung durch
das System, bei einem Wert von 1 wird das Signal ignoriert; jeder andere
Werte wird als die Adresse einer Signalbehandlungsroutine interpretiert, die
dann aufgerufen wird.

Die Komponente (!I)sa_mask(!i) enthÑlt die zusÑtzlich (zu dem gerade in
Bearbeitung befindlichen Signal) wÑhrend der Signalbehandlung zu
maskierenden Signale. Es gilt dann also mask = oldmask+(1<<sig)+sa_mask).
öber (!I)sa_flags(!i) kann das Verhalten eines Signals weiter beeinfluût
werden. Ein Wert von 1 fÅr (!I)sa_flags(!i) bedeutet in MiNT, daû das Signal
SIGCHLD nur beim Terminieren, und nicht beim Anhalten eines Childs ausgelîst
wird; andere Werte fÅr (!I)sa_flags(!i) sind z.Zt. noch nicht definiert.

Querverweis: Signale  ~    Signalhandler in MagiC  ~ GEMDOS ~
Psigaction ~  Prozessfunktionen
!end_node

!begin_node tchars

Diese Struktur ist wie folgt definiert:

!begin_verbatim
struct tchars
{
    BYTE t_intrc;
    BYTE t_quitc;
    BYTE t_startc;
    BYTE t_stopc;
    BYTE t_eofc;
    BYTE t_brkc;
};
!end_verbatim
!end_node




!begin_node timeval
!begin_verbatim
struct timeval
{
  long int tv_sec;
  long int tv_usec;
}; 
!end_verbatim

tv_sec holds the number of seconds elapsed since the epoch. The 
epoch is Thu, Jan 1 1970 00:00:00 UTC.

tv_usec holds the fractional part of tv_sec measured 
in microseconds.
!end_node




!begin_node timezone
!begin_verbatim
struct timezone
{
  long int tz_minuteswest;
  long int tz_dsttime;
}; 
!end_verbatim
tz_minuteswest holds the offset to UTC in seconds. Timezones 
east of the zero-meridian (e.g. Eastern Europe) have a negative offset, 
timezones west of the zero-meridian (e.g. America) have a positive 
one.

tz_dsttime is non-zero, if daylight savings time applies 
during some part of the year.
!end_node



!begin_node winsize

Diese Struktur ist wie folgt definiert:

!begin_verbatim
struct winsize
{
    SHORT  ws_row;
    SHORT  ws_col;
    SHORT  ws_xpixel;
    SHORT  ws_ypixel;
};
!end_verbatim
!end_node


!begin_node XATTR

Diese Struktur ist wie folgt definiert:

!begin_verbatim
typedef struct xattr
{
   UWORD   mode;               /* Dateimodus, Angaben zu     */
                               /* - mîglichen Filetypen      */
                               /* - speziellen Bits          */
                               /* - Zugriffsrechten          */
   LONG    index;              /* Dateinummer                */
   UWORD   dev;                /* GerÑtenummer               */
   UWORD   rdev;               /* tatsÑchliches GerÑt        */
                               /* (z.B. bei BIOS-Files)      */
                               /* in MagiC jedoch reserviert */
   UWORD   nlink;              /* Anzahl der Links           */
   UWORD   uid;                /* Benutzernummer             */
   UWORD   gid;                /* Gruppennummer              */
   LONG    size;               /* DateilÑnge                 */
   LONG    blksize, nblocks;   /* Blockgrîûe/belegte Blocks  */
   UWORD   mtime, mdate;       /* Datum der letzten énderung */
   UWORD   atime, adate;       /* Datum des letzten Zugriffs */
   UWORD   ctime, cdate;       /* Erstellungsdatum           */
   UWORD   attr;               /* TOS-Dateiattribute         */
   UWORD   reserved2;          /* reserviert                 */
   LONG    reserved3[2];       /* reserviert                 */
} XATTR;
!end_verbatim

(!B)Hinweis:(!b) MagiC liefert fÅr FAT-Dateisysteme folgende Index-Daten:

!begin_xlist !short [˘ sonstige Dateien:]
!item [˘ Verzeichnisse:]
Startcluster im Motorola-Format
!item [˘ sonstige Dateien:]
!begin_xlist !short
!item [Hiword =]
Startcluster des Verzeichnisses
!item [Loword =]
Position innerhalb des Verzeichnisses >> 5
!end_xlist
!end_xlist

Dieses Verfahren ist Ñhnlich wie das, welches Linux und Solaris verwenden.
Nachteil ist, daû Dateien beim Verschieben ihren Index Ñndern.

Die Komponente (!I)index(!i) ist also ein Langwort zur eindeutigen
Identifizierung einer Datei bzw. eines Ordners. Der Index muû innerhalb
eines Dateisystems eindeutig sein; zusammen mit dem folgenden Feld
((!I)dev(!i)) ist damit eine Datei oder ein Ordner systemglobal vollstÑndig
festgelegt.

Unter UNIX-Ñhnlichen Dateisystemen ist (!I)index(!i) die Nummer des Inode.

Auf Macintosh-Partitionen wird die hard file ID bzw. die hard dir ID
verwendet, die vom MacOS zur VerfÅgung gestellt wird. Das MacOS verwendet
als Standard-Deskriptoren aber das FSSpec. FÅr Verzeichnisse, d.h. fÅr
Directory IDs, gibt es Funktionen des MacOS, um einen FSSpec zu berechnen.
Leider lassen sich die hard file IDs fÅr normale Dateien (d.h. nicht
Unterverzeichnisse) (!I)nicht(!i) weiter verwenden, da sie von keiner
Funktion des MacOS verarbeitet werden.

Querverweis: (!link [XFS-Konzept in MagiC][Das XFS-Konzept von MagiC]) ~
Fxattr ~ Dxreaddir


!begin_node XATTR, dev-Komponente

Legt das Dateisystem fest. Auf dem Atari sind 0..25 die BIOS-Laufwerke A:
bis Z:, Laufwerk U: oder andere Dateisysteme verwenden hîhere Nummern. Auf
dem Macintosh wird die 'volume ID' eingesetzt, die vom MacOS vergeben wird.



!begin_node XATTR, mîgliche Filetypen
!label mîgliche Filetypen
(!B)Mîgliche Filetypen, die Åber die XATTR-Struktur gesetzt bzw. ermittelt
werden kînnen:(!b)

!begin_verbatim
#define S_IFMT  0170000  /* zur Isolierung des Filetyps */
#define S_IFCHR 0020000  /* spezielles BIOS-File        */
#define S_IFDIR 0040000  /* Verzeichnis                 */
#define S_IFREG 0100000  /* normale Datei               */
#define S_IFIFO 0120000  /* FIFO (Pipe mit Namen)       */
#define S_IMEM  0140000  /* Speicherblock/Prozeûfile    */
#define S_IFLNK 0160000  /* symbolischer Link           */
!end_verbatim
!end_node

!begin_node Sticky-Bit

(!B)Spezielle Bits, die Åber die XATTR-STruktur gesetzt bzw. ermittelt
werden kînnen:(!b)

!begin_verbatim
#define S_ISUID 04000  /* User-ID des EigentÅmers setzen */
#define S_ISGID 02000  /* Gruppen-ID bei Aufruf setzen   */
#define S_ISVTX 01000  /* Sticky bit                     */
!end_verbatim

(!B)Hinweis:(!b) Die Bedeutung des (!I)Sticky-Bits(!i) ist dabei vom Filetyp
abhÑngig.
!end_node

!begin_node XATTR, size-Komponente

Auf (!B)DOS-Partitionen(!b) wird fÅr Ordner der Wert 0 als LÑnge geliefert.
Die tatsÑchliche LÑnge kann leider aufgrund der EinschrÑnkungen von MSDOS
nicht ermittelt werden. Die LÑnge des Wurzelverzeichnisses kann allerdings
ermittelt werden.

Auf (!B)Macintosh-Partitionen(!b) haben Ordner immer die LÑnge 0, die
tatsÑchliche LÑnge lÑût sich (zumindest unter System 7) nicht ermitteln.
!end_node

!begin_node XATTR, spezielle Bits

(!B)Spezielle Bits, die Åber die XATTR-STruktur gesetzt bzw. ermittelt
werden kînnen:(!b)

!begin_verbatim
#define S_ISUID 04000  /* User-ID des EigentÅmers setzen */
#define S_ISGID 02000  /* Gruppen-ID bei Aufruf setzen   */
#define S_ISVTX 01000  /* Sticky bit                     */
!end_verbatim

(!B)Hinweis:(!b) Die Bedeutung des (!I)Sticky-Bits(!i) ist dabei vom
Filetyp abhÑngig.
!end_node

!begin_node XATTR, Zugriffsrechte

(!B)Mîgliche Zugriffsrechte, die Åber die XATTR-Struktur gesetzt bzw.
ermittelt werden kînnen:(!b)

!begin_verbatim
#define S_IRUSR 0400   /* EigentÅmer darf Datei lesen    */
#define S_IWUSR 0200   /* dto. darf beschreiben          */
#define S_IXUSR 0100   /* dto. darf ausfÅhren            */
#define S_IRGRP 0040   /* Gruppenmitglieder dÅrfen lesen */
#define S_IWGRP 0020   /* dto. dÅrfen beschreiben        */
#define S_IXGRP 0010   /* dto. dÅrfen ausfÅhren          */
#define S_IROTH 0004   /* Andere dÅrfen Datei lesen      */
#define S_IWOTH 0002   /* dto. dÅrfen beschreiben        */
#define S_IXOTH 0001   /* dto. dÅrfen ausfÅhren          */
!end_verbatim
!end_node
!end_node


!begin_node xkey

Diese Struktur ist wie folgt definiert:

!begin_verbatim
struct xkey
{
    SHORT   xk_num;
    BYTE    xk_def[8];
};
!end_verbatim

Querverweise: Fcntl ~ TIOCGXKEY

!end_node

!end_node

