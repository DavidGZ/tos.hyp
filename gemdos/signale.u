!begin_node Signale

Das aus der U*NIX-Welt stammende Signal-Konzept steht auch unter den
Betriebssystemen MultiTOS und MagiC (ab Version 4.50) zur VerfÅgung. Signale
kînnen als natÅrliche Zahlen aufgefaût werden, die einen bestimmten
Ausnahmezustand (Exception) reprÑsentieren. Sie sind mit einem Interrupt
oder einer CPU-Exception vergleichbar, mit dem Unterschied jedoch, daû es
sich um eine reine (!I)Software(!i)-Implementation handelt.

(!B)Jeder Prozess besitzt:(!b)

!begin_itemize
!item einen Bitvektor der wartenden Signale (pending Signals). Dieser
beschreibt diejenigen Signale, die noch auf ihre Bearbeitung warten, weil
sie z.B. gerade durch die Signalmaske gesperrt sind, oder weil der Prozess
in einem Zustand ist, in dem er keine Signale bearbeiten kann.
!item eine Signalmaske. Dieser 32bit-Wert definiert als Bitvektor diejenigen
Signale, die momentan gesperrt sind; wenn in diesem Vektor z.B. Bit-30
gesetzt ist, ist das Signal SIGUSR2 gesperrt. Die Signalmaske wird nicht
nur explizit (d.h. durch Systemaufrufe), sondern auch (!I)implizit(!i) durch
andere VorgÑnge beeinfluût. WÑhrend der Abarbeitung eines Signals ist dieses
z.B. gesperrt, andere kînnen jedoch noch auftreten. Nach der Bearbeitung des
Signals wird dieses wieder freigegeben und damit evtl. eine weitere
Signalbehandlung ausgelîst. Beachtet werden muss, daû einige Signale (z.B.
SIGKILL, SIGSTOP, SIGCONT) (!I)nicht(!i) maskiert werden kînnen.
!item eine Tabelle der Form struct sigaction
!end_itemize

Bei einem Pexec werden die Signalmaske und der pending-Wert (s.o.) des
Child-Prozesses auf Null gesetzt. Die Komponente (!I)sa_handler(!i) der
sigaction Struktur wird vererbt, wobei ein Wert ungleich 0 oder 1 immer auf
0 gesetzt wird. Die Komponenten (!I)sa_mask(!i) und (!I)sa_flags(!i) der
Struktur werden auf den Wert Null gesetzt.

Die meisten Signale kînnen von einem Programm abgefangen, (um etwa beim
Eintreffen eine bestimmte Routine aufzurufen) ignoriert, oder auch blockiert
werden. Blockierte Signale werden solange nicht berÅcksichtigt, bis die
Blockade wieder aufgehoben wird. (!B)Zur Terminologie:(!b) Man sagt, daû ein
Signal zu einem Prozess (!I)geschickt(!i) wird, wenn die das Signal
reprÑsentierende Exception auftritt, oder wenn das Signal per Pkill von
einem anderen Prozess gesendet wird. Ein Signal wurde hingegen an einen
Prozess (!I)Åberbracht(!i), wenn der entsprechende Prozess aufwacht, und die
fÅr das Signal passenden Aktionen einleitet. Zu beachten ist, daû das
SignalHandling nicht zeitlos geschieht: Zwischen dem Abschicken eines
Signals, und der Aufnahme der dazu passenden Aktionen kann evtl. ein
betrÑchtlicher Zeitraum verstreichen.

!label Signale, Liste der
Insgesamt stehen 31 mîgliche Signale (0 bis 30) zur VerfÅgung, denen aber
noch nicht allen eine feste Bedeutung zugewiesen ist. Die folgende Liste
beschreibt (soweit bekannt) alle mîglichen Signale in der Form:
Signalnummer, Name des Signals, Bedeutung des Signals fÅr den empfangenden
Prozess. (!B)Sofern nicht ausdrÅcklich anders beschrieben, besteht die
Default Aktion beim Eintreffen eines Signals in der Terminierung des
empfangenden Prozesses(!b).

!begin_xlist !short [Nummer SIGVTALRM]
!item [Nummer Name]
Bedeutung
!item [~]
~

!label SIGNULL
!item [~~~0~~ SIGNULL]
Null: Dieses Signal besitzt keine Defaultaktion, da es streng genommen gar
kein Signal ist. Zusammen mit Pkill kann es jedoch benutzt werden, um die
Existenz eines Prozesses zu testen. Das Signal kann (!I)nicht(!i) maskiert
oder abgefangen werden.

!label SIGHUP
!item [~~~1~~ SIGHUP]
Hang Up: Wird normalerweise verschickt, wenn ein Terminal, mit dem ein
Prozess verbunden ist, nicht mehr gÅltig ist. Nach Erhalt dieses Signals
sollte der Prozess keine Ausgaben mehr auf das Terminal machen. In MagiC
wird der VT52 das Signal in Zukunft verschicken, wenn ein Terminalfenster
geschlossen wurde.

!label SIGINT
!item [~~~2~~ SIGINT]
Interrupt: Wird i.a. verschickt, wenn der Benutzer die Tastenkombination ^C
betÑtigt. Dieses Signal wird in Zukunft von (!nolink [MagiC]) statt der bisherigen
^C-Behandlung benutzt.

!label SIGQUIT
!item [~~~3~~ SIGQUIT]
Quit: Wird i.a. verschickt, wenn der Benutzer die Tastenkombination ^\
betÑtigt. Das Signal soll 'hÑrter' als SIGINT sein, und wird z.Zt. noch
nicht von (!nolink [MagiC]) bzw. VT52 verschickt.

!label SIGILL
!item [~~~4~~ SIGILL]
Illegal instruction: Entspricht dem gleichnamigen Exceptionvektor des
68K-Prozessors. Das Signal sollte (!I)nicht(!i) abgefangen werden. In MiNT
kann das Signal abgefangen werden, d.h. der Vektor wird praktisch fÅr jeden
Prozess umgebogen. In (!nolink [MagiC]) funktioniert das jedoch z.Zt. noch nicht, so daû
hier immer 8 Bomben erscheinen.

!label SIGTRAP
!item [~~~5~~ SIGTRAP]
Trap: Entspricht dem Exceptionvektor 'Trace' des 68K-Prozessors. Dieses
Signal sollte nur von (!B)Debuggern(!b) abgefangen werden. In MiNT kann das
Signal abgefangen werden, d.h. der Vektor wird praktisch fÅr jeden Prozess
umgebogen. In (!nolink [MagiC]) funktioniert das z.Zt. jedoch noch nicht, d.h. es
erscheinen immer 9 Bomben.

!label SIGABRT
!item [~~~6~~ SIGABRT]
Abort: Wird normalerweise von der Bibliotheksfunktion abort() in ANSI C
verwendet, und sollte (!I)nicht(!i) abgefangen werden. Dieses Signal wird
nicht vom Betriebssystem selbst verschickt.

!label SIGPRIV
!item [~~~7~~ SIGPRIV]
Privilege Violation: Entspricht dem gleichnamigen Exceptionvektor im
68K-Prozessor. Dieses Signal sollte nicht abgefangen werden; in MiNT ist
dies jedoch mîglich, so daû der Exceptionvektor praktisch fÅr jeden Prozess
umgebogen wird. In (!nolink [MagiC]) funktioniert das z.Zt. jedoch noch nicht, d.h.
es erscheinen immer 8 Bomben.

!label SIGFPE
!item [~~~8~~ SIGFPE]
Floating Point Exception: Die Default-Aktion besteht darin, das Signal zu
ignorieren. Es entspricht dem 68k-Execptionvektor 'Division durch Null'. Das
Signal kann ignoriert oder abgefangen werden. In MiNT kann das Signal
abgefangen werden, so daû der Vektor praktisch fÅr jeden Prozess umgebogen
wird. In (!nolink [MagiC]) ist dies z.Zt. noch nicht mîglich.

!label SIGKILL
!item [~~~9~~ SIGKILL]
Kill: Terminiert den empfangenden Prozess. Das Signal kann nicht maskiert
bzw. abgefangen werden; deshalb sollte dieses Signal erst dann verschickt
werden, wenn SIGTERM erfolglos war. Das Signal wird von MagiC selbst z.Zt.
noch nicht verschickt.

!label SIGBUS
!item [~~10~~ SIGBUS]
Bus Error: Entspricht dem gleichnamigen Exceptionvektor des 68K-Prozessors.
Das Signal sollte (!I)nicht(!i) ignoriert oder abgefangen werden. In MiNT
kann das Signal abgefangen werden, d.h. der Exceptionvektor wird praktisch
fÅr jeden Prozess umgebogen; in (!nolink [MagiC]) geht das z.Zt. jedoch noch nicht, so
daû immer 2 Bomben erscheinen. In MiNT werden SIGBUS, SIGSEGV und SIGPRIV
beim ersten Eintreffen des Signals auf die Defaultroutine des Systems
zurÅckgesetzt, so daû ein (!I)doppelter(!i) Bus-/Adreû-/Privilegfehler den
Prozess immer beendet.

!label SIGSEGV
!item [~~11~~ SIGSEGV]
Segmentation violation: Entspricht dem Exceptionvektor 'Adressfehler' des
68K-Prozessors. Das Signal sollte (!I)nicht(!i) abgefangen oder ignoriert
werden. In MiNT kann das Signal abgefangen werden, d.h. der Exceptionvektor
wird praktisch fÅr jeden Prozess umgebogen. In (!nolink [MagiC]) geht das jedoch z.Zt.
noch nicht, d.h. es erscheinen immer 3 Bomben.

!label SIGSYS
!item [~~12~~ SIGSYS]
Bad System Call: Wird von (!nolink [MagiC]) z.Zt. noch nicht verschickt.

!label SIGPIPE
!item [~~13~~ SIGPIPE]
Pipe Error: Wird beim Versuch verschickt, in eine nicht mehr existierende
Pipe zu schreiben, und kann z.B. beim Drag&Drop-Protokoll maskiert werden.
Dieses Signal wird z.Zt. von (!nolink [MagiC]) noch nicht verschickt.

!label SIGALRM
!item [~~14~~ SIGALRM]
Alarm: Wird von MiNT fÅr Talarm verwendet, und dient z.B. zum Behandeln von
Time-Outs. In (!nolink [MagiC]) wird dieses Signal z.Zt. noch nicht verschickt.

!label SIGTERM
!item [~~15~~ SIGTERM]
Terminate: Standardsignal zum Beenden eines Prozesses; es wird von MiNT z.B.
beim Lîschen einer Programmdatei im Verzeichnis U:\PROC verschickt, von
(!nolink [MagiC]) z.Zt. jedoch noch ignoriert.

!label SIGURG
!item [~~16~~ SIGURG]
Dieses Signal ist z.Zt. noch nicht definiert.

!label SIGSTOP
!item [~~17~~ SIGSTOP]
Stop: Die Default-Aktion besteht darin, den empfangenden Prozess anzuhalten.
Das Signal kann (!I)nicht(!i) blockiert bzw. abgefangen werden. In MagiC
werden dabei sÑmtliche Threads eines Prozesses angehalten. Im gestoppten
Zustand gehen in (!nolink [MagiC]) keinerlei Maus- bzw. Tastaturklicks verloren; beim
Fortfahren des Prozesses per SIGCONT werden die entsprechenden Nachrichten
ausgewertet.

!label SIGTSTP
!item [~~18~~ SIGTSTP]
Terminal Stop: Die Default-Aktion besteht darin, den empfangenden Prozess
anzuhalten. Das Signal entspricht SIGSTOP, und wird i.a. vom Benutzer durch
DrÅcken der Tastenkombination ^Z ausgelîst. Es kann (!I)nicht(!i) maskiert
bzw. abgefangen werden. Das Signal wird z.Zt. noch nicht von (!nolink [MagiC]) und VT52
verschickt.

!label SIGCONT
!item [~~19~~ SIGCONT]
Continue: Die Default-Aktion besteht darin, den empfangenen (und vorher
durch SIGSTOP oder Pause gestoppten) Prozess wieder aufzuwecken. Obwohl das
Signal nicht maskiert bzw. ignoriert werden kann, kann eine
Behandlungsroutine fÅr das Signal installiert werden. In (!nolink [MagiC]) werden
sÑmtliche Threads aufgeweckt, die durch einen Aufruf von (!nolink [Pause]) bzw. SIGSTOP
angehalten worden sind.

!label SIGCHLD
!item [~~20~~ SIGCHLD]
Child Terminated: Die Default-Aktion besteht darin, das Signal zu
ignorieren. Es wird sowohl beim Terminieren als auch beim Anhalten eines
Prozesses an den Parent-Prozess verschickt. In MiNT kann festgelegt werden,
daû dieses Signal nur beim Terminieren verschickt wird, und darÅber hinaus
auch festgestellt werden, welcher Child-Prozess betroffen war. Da (!nolink [MagiC])
bisher nur das wartende Pexec kennt (d.h. der Parent wartet so lange, bis
der Child terminiert), gibt es das Signal hier noch nicht. Die durch
shel_write erzeugten Prozesse sind (!I)keine(!i) richtigen Childs, sondern
vîllig unabhÑngige Prozesse; in diesen FÑllen muss daher auf das Eintreffen
der Nachricht CH_EXIT gewartet werden.

!label SIGTTIN
!item [~~21~~ SIGTTIN]
Terminal Input-Error: Die Default-Aktion besteht darin, den empfangenden
Prozess anzuhalten. In der Regel versucht ein Prozess von einem Terminal zu
lesen, das ihm nicht gehîrt. Von (!nolink [MagiC]) bzw. VT52 wird das Signal z.Zt. noch
nicht verschickt.

!label SIGTTOU
!item [~~22~~ SIGTTOU]
Terminal Output-Error: Die Default-Aktion besteht darin, den empfangenden
Prozess anzuhalten. In der Regel versucht ein Prozess Ausgaben auf ein
Terminal vorzunehmen, das ihm nicht gehîrt. Von (!nolink [MagiC]) bzw. VT52 wird das
Signal z.Zt. noch nicht verschickt.

!label SIGIO
!item [~~23~~ SIGIO]
Dieses Signal ist z.Zt. noch nicht definiert.

!label SIGXCPU
!item [~~24~~ SIGXCPU]
Exhaustion of CPU-Limit: Das per Psetlimit bzw. durch die erweiterten
shel_write-Modi festgelegte Rechenzeit-Kontingent ist abgelaufen. Da die
Begrenzung der Rechenzeit in MagiC bisher nicht implementiert ist, wird das
Signal z.Zt. noch nicht verschickt.

!label SIGXFSZ
!item [~~25~~ SIGXFSZ]
Dieses Signal hat z.Zt. noch keine Bedeutung.

!label SIGVTALRM
!item [~~26~~ SIGVTALRM]
Dieses Signal hat z.Zt. noch keine Bedeutung.

!label SIGPROF
!item [~~27~~ SIGPROF]
Dieses Signal hat z.Zt. noch keine Bedeutung.

!label SIGWINCH
!item [~~28~~ SIGWINCH]
Window-Changed: Die Default-Aktion besteht darin, das Signal zu ignorieren.
Es wird normalerweise verschickt, wenn sich die Terminalgrîûe (d.h. die
Anzahl der Zeilen bzw. Spalten) verÑndert hat. Ein Programm daû im
Terminalfenster ablÑuft, kann sich nun entsprechend neu konfigurieren. Zur
Ermittlung der aktuellen Fenstergrîûe gibt es in MiNT Fcntl-Opcodes, die in
(!nolink [MagiC]) bisher jedoch noch nicht implementiert sind. Das Signal wird daher
z.Zt. noch nicht von MagiC bzw. VT52 verschickt.

!label SIGUSR1
!item [~~29~~ SIGUSR1]
User-Defined:

!label SIGUSR2
!item [~~30~~ SIGUSR2]
User-Defined: Diese zwei Signale dÅrfen durch Benutzerprogramme verschickt
werden. Da ein Prozess beim Empfangen dieses Signals per Default terminiert
wird, sollte es nur verschickt werden, wenn der EmpfÑnger bekannt ist.
!end_xlist

Querverweis: (!nl)
Signalhandler in MagiC ~  Prozessfunktionen ~
(!link [Beispielcode][Beispielcode zu Signalen]) ~
             Psigaction      ~   Psignal    ~   Pkill ~
             (!link [Test auf Pipes][Pipes, Test auf])


!begin_node Signalhandler in MagiC

Da sich Signalhandler in MagiC etwas von denen in MiNT bzw. MultiTOS
unterscheiden, wird an dieser Stelle auf die wichtigsten Unterschiede bzw.
Eigenschaften eingegangen. ZunÑchst einmal muss festgestellt werden, daû
in (!nolink [MagiC]) AES- und VDI-Aufrufe aus einem Signalhandler heraus (!I)erlaubt(!i)
sind (ganz im Gegensatz zu MiNT).

Ein Signalhandler lÑuft im Usermodus und verwendet den Userstack des
Haupt-Threads, der solange schlÑft. In MiNT wird der Supervisor-Stack des
Prozesses verwendet. Daher schieût laut MiNT-Dokumentation die
Verschachtelung von Signalen ab 4 StÅck einen Prozeû wegen StapelÅberlaufs
ab. In (!nolink [MagiC]) ist jeder Signalhandler ein (!I)eigener(!i) Thread mit
(!I)eigenem(!i) Supervisor-Stack, es kann also lediglich der extrem
unwahrscheinliche Fall des Userstack-öberlaufs eintreten. Wenn jedoch zur
Behandlung eines Signals zuwenig Speicher fÅr einen neuen Thread zur
VerfÅgung steht, wird eine Alertbox "System hat keinen freien Speicher mehr"
ausgegeben, und  es sollte schleunigst ein Programm beendet werden. FÅr jede
Signalbehandlung benîtigt (!nolink [MagiC]) ca. 7k Speicherplatz.

FÅr Signale gilt in (!nolink [MagiC]) das gleiche wie fÅr Threads (ein Signalhandler ist
ein Thread), d.h. die entsprechenden Systembibliotheken mÅssen
(!I)reentrant(!i) sein. Es kommt jedoch noch erschwerend hinzu, daû der
Haupt-Thread wÑhrend der Abarbeitung des Signals angehalten wird. Wenn also
der Haupt-Thread eine Semaphore (Stichwort: wind_update) gesetzt hat,
ensteht ein Deadlock, wenn der Signalhandler diese Semaphore ebenfalls
setzen will. Weiterhin kann ein Prozeû in (!nolink [MagiC]) an beinahe beliebiger Stelle
unterbrochen werden ((!nolink [MagiC]) ist reentrant, sogar DOS ist unterbrechbar), so
daû der Haupt-Thread u.U. wichtige Bereiche des Systems sperrt (Dateien,
Verzeichnisse, Semaphoren). Daher kann es z.B. vorkommen, daû bestimmte
Dateien nicht gelîscht oder geîffnet werden kînnen.

Beim normalen Beenden eines Signalhandlers werden alle von dem Handler
gesperrten Semaphoren automatisch freigegeben. Weiterhin werden ggf.
Fenster, Bildschirmhintergrund und MenÅleiste des Signalhandlers
freigegeben. Man beachte, daû ein Signalhandler eine eigene AES
Message-Queue besitzt, d.h. evnt_message und appl_write sind mit Vorsicht
zu verwenden.

Bei Psigreturn werden die Semaphoren aller Signalhandler als auch die des
Haupt-Thread freigegeben. Nicht freigegeben werden jedoch Fenster,
Bildschirmhintergrund und MenÅleiste der Signalhandler. Das wÑre zwar kein
groûes Problem gewesen, dÅrfte aber in der Praxis nicht notwendig sein.
(!nolink [Psigreturn]) restauriert den Supervisor-Stack des Haupt-Thread, d.h. ein
setjmp/longjmp-Mechanismus braucht nur den USP zu setzen. Dies ist in der
MiNT-Dokumentation nicht ausreichend dokumentiert und funktioniert auch
nur dann, wenn der Haupt-Thread per GEMDOS-Aufruf wartet. Kommt (!nolink [AES]) ins
Spiel, stÅrzt MultiTOS ab. (!nolink [Psigreturn]) sollte daher nach Mîglichkeit
vermieden werden. (!nolink [Psigreturn]) ist in (!nolink [MagiC]) nicht vom Typ VOID wie in MiNT,
sondern vom Typ LONG. Wenn die Funktion von einem Nicht-Signalhandler
aufgerufen wird, liefert (!nolink [Psigreturn]) den Wert EACCDN zurÅck, sonst E_OK. Hat
(!nolink [Psigreturn]) E_OK geliefert, sollte (wie in MiNT) auf (!I)keinen(!i) Fall die
Behandlungs-Prozedur normal per rts beendet werden, weil die
RÅcksprungadresse auf dem Userstack nach der AusfÅhrung von (!nolink [Psigreturn])
ungÅltig ist.

Ein Problem existiert in (!nolink [MagiC]) mit den bisherigen Versionen von VT52. Ein
Signalhandler kann noch (!I)keine(!i) Tastaturabfragen im VT52 durchfÅhren;
die Tasten werden noch nicht empfangen. Dies wird sich in einer spÑteren
Version jedoch noch Ñndern.

Querverweis: Prozessfunktionen ~ Signale ~
(!link [Threads][Threads in MagiC])
!end_node


!begin_node Beispielcode zu Signalen

Das erste Programm installiert einen Signalhandler fÅr die beiden Signale
SIGUSR1 und SIGUSR2. Damit kann man die Verschachtelung der beiden (!nolink [Signale])
testen, wenn beide hintereinander verschickt werden. Das Programm sollte im
VT52 bzw. im MINIWIN laufen. Wenn man wÑhrend der "for()" Warteschleife
Ctrl-Alt-Esc betÑtigt, erkennt man, daû MagiC fÅr jeden Signalhandler einen
eigenen Thread erstellt. Das hat den Vorteil, daû unter (!nolink [MagiC]) keine
Ereignisse (Maus, Timer, ...) verlorengehen kînnen, wÑhrend ein Signal
bearbeitet wird.

!begin_verbatim
------------------------------ schnipp --------------------------
#include <tos.h>
#include <stdio.h>

void cdecl handler(long signr)
{
    long i;

    printf("handler: Signal %ld empfangen.\n", signr);
    Cconws("warte...");
    for (i = 0; i < 7000000L; i++)
        ;
    Cconws("...OK\r\n");
}

int main( void )
{
    long ret;

    printf("Meine ProcID ist %d.\n", Pgetpid());
    ret = (long) Psignal(SIGUSR1, handler);
    printf("Psignal => %ld\n", ret);
    ret = (long) Psignal(SIGUSR2, handler);
    printf("Psignal => %ld\n", ret);
    Cconin();
    return(0);
}
------------------------------ schnipp --------------------------
!end_verbatim

Das zweite Programm zeigt die Behandlung des Psigreturn()-Aufrufs. Unter
MiNT funktioniert dieses Programm nur, wenn man keine AES-Aufrufe
(evnt_keybd() oder evnt_multi()) verwendet, sondern z.B. Cconin() verwendet.
D.h. das folgende Programm funktioniert unter (!nolink [MagiC]) und stÅrzt unter
MultiTOS (MiNT 1.08+(!nolink [AES]) 4.1) ab. Das Problem liegt wahrscheinlich an der
Restauration des Supervisor-Stacks (Systemstapelzeiger), dabei versagt
MultiTOS wegen des inhomogenen Konzepts (!nolink [AES])<->MiNT.

!begin_verbatim
------------------------------ schnipp --------------------------
#include <tos.h>
#include <aes.h>
#include <setjmp.h>
#include <tosdefs.h>
#include <stdio.h>

jmp_buf env;

void cdecl handler(long signr)
{
    printf("handler: Signal %ld empfangen.\n", signr);
    Cconws("Mache Psigreturn()\r\n");
    Psigreturn();
    longjmp(env, 1);
}

int main( void )
{
    long ssp;

    appl_init();
    printf("Meine ProcID ist %d.\n", Pgetpid());
    Psignal(SIGUSR1, handler);

    if  (setjmp(env))
        Cconws("komme von longjmp.\r\n");
    else    Cconws("komme von setjmp.\r\n");
    ssp = Super(0L);
    Super((void *) ssp);
    printf("ssp = 0%08lx\n", ssp);
    evnt_keybd();
    return(0);
}
!end_verbatim

Querverweis: Signale ~ Prozessfunktionen ~ GEMDOS
!end_node
!end_node
