!begin_node Salert
(!begin_liste) [Beschreibung:]
!item [Name:]
ØSalertÆ - Warnung bzw. Fehlermeldung ausgeben.
!item [Gemdosnummer:]
316
!item [Binding:]
(!link [Bindings fÅr Salert] [Bindings fÅr Salert])
!item [Beschreibung:]
Die Funktion gibt eine Fehler- bzw. Warnmeldung aus, die in die
Alert-Pipeline U:\PIPE\ALERT geschrieben wird.

Die Meldung (!I)msg(!i) sollte keine Steuerzeichen, Linefeeds etc.
enthalten. Sie sollte eine einfache einzeilige Warn- oder Fehlermeldung
sein.

Die Funktion formatiert die Meldung selbstÑndig und sendet sie dem Benutzer.
Die genaue Form des Outputs hÑngt jedoch von der verwendeten
Systemkonfiguration ab.

(!B)Achtung:(!b) Diese Funktion ist optional, daher darf ein Aufruf mit
EINVFN beantwortet werden.
!item [Ergebnis:]
Die Funktion hat kein direktes Ergebnis.
!item [Gruppe:]
(!link [Systemfunktionen][Systemfunktionen des GEMDOS])

!item [Querverweis:] Cconws ~ Test auf Pipes
(!ende_liste)


!begin_node Bindings fÅr Salert
!ignore_index
(!begin_liste) [Assembler:]
!item [C:]
VOID Salert ( BYTE *msg );
!item [Assembler:]
!begin_verbatim
pea       msg          ; Offset 2
move.w    #316,-(sp)   ; Offset 0
trap      #1           ; GEMDOS aufrufen
addq.l    #6,sp        ; Stack korrigieren
!end_verbatim
!ifdest [html]
!item [GFA-Basic]
!begin_raw
<A HREF="http://www.milanstation.de/at/gfahutil/gfau7gd.htm">GFA-H-Util GEMDOS</A>
!end_raw
!endif
(!ende_liste)
!end_node
!end_node




!begin_node Shutdown
(!begin_liste) [Beschreibung:]
!item [Name:]
ØShutdownÆ - kills all processes, syncs filesystems then halts or reboots
the system.
!item [Gemdosnummer:]
337 (0x0151)

!item [Binding:]
(!link [Bindings fÅr Shutdown] [Bindings fÅr Shutdown])

!item [Beschreibung:]
This function kills all processes, syncs filesystems then halts or reboots
the system.

!label SHUT_HALT
On (!I)mode(!i) equal to SHUT_HALT (0L), the system will shutdown 
then enter a halted condition.

!label SHUT_BOOT
On (!I)mode(!i) equal to SHUT_BOOT (1L), the system will 
reboot the machine after shutting everything down.

!label SHUT_COLD
On (!I)mode(!i) equal to SHUT_COLD (2L), the system will act 
the same as with the SHUT_BOOT mode, except that a cold start 
rather than the warm start will be performed.

That last mode is recognized as of FreeMiNT version 1.15.5, older 
versions of the kernel will treat the SHUT_BOOT and 
SHUT_COLD values equally.

All other values of mode are reserved for future definition.

Older versions of MiNT contained a bug that might cause the 
system to crash, if you called Shutdown() while both GEM AES and 
virtual console daemon were present.

You need root privileges to shut the system down.

!item [Ergebnis:]
Returns a negative GEMDOS error code, if failed. On success this call obviously 
never returns.

!item [VerfÅgbar:]
This function is available under all MiNT versions integrated with MultiTOS.

!item [Gruppe:]
(!link [Systemfunktionen][Systemfunktionen des GEMDOS])

!item [Querverweis:] (!link [Sync][Ssync])
(!ende_liste)


!begin_node Bindings fÅr Shutdown
!ignore_index
(!begin_liste) [Assembler:]
!item [C:]
VOID Shutdown ( LONG mode );
!item [Assembler:]
!begin_verbatim
move.l    mode,-(sp)   ; Offset 2
move.w    #337,-(sp)   ; Offset 0
trap      #1           ; GEMDOS aufrufen
addq.l    #6,sp        ; Stack korrigieren
!end_verbatim
(!ende_liste)
!end_node
!end_node




!begin_node Slbclose

(!begin_liste) [Beschreibung:]
!item [Name]           ØSlbcloseÆ - schlieût eine "shared lib".

!item [Gemdosnummer]   23

!item [Binding:]
(!link [Bindings fÅr Slbclose] [Bindings fÅr Slbclose])

!item [Beschreibung]   Die Funktion schlieût eine Shared Lib

               Der Parameter (!I)sl(!i) ist der Deskriptor welcher bei 
               Slbclose ermittelt wird.
              
!item [Ergebnis]       E_OK   =   Alles OK, Versionsnummer der Bibliothek.
               oder negative GEMDOS-Fehlernummer.

!item [VerfÅgbar:]      Diese Funktion ist optional, daher darf ein
                        Aufruf mit (!nolink [EINVFN]) beantwortet werden. Sie steht 
                        ab (!nolink [MagiC]) 5.20 und FreeMiNT 1.15.4 zu VerfÅgung.


!item [Gruppe]         (!link [Systemfunktionen][Systemfunktionen des GEMDOS])

!item [Querverweis]    Slbopen ~ Shared Libraries
(!ende_liste)


!begin_node Bindings fÅr Slbclose
!ignore_index
(!begin_liste) [Assembler:]
!item [C:]
LONG Slbclose( SHARED_LIB *sl );
!item [Assembler:]
!begin_verbatim
pea       sl           ; Offset 2
move.w    #23,-(sp)    ; Offset 0
trap      #1           ; GEMDOS aufrufen
addq.l    #6,sp        ; Stack korrigieren
!end_verbatim
(!ende_liste)
!end_node
!end_node



!begin_node Slbopen
(!begin_liste) [Beschreibung:]
!item [Name]           ØSlbopenÆ - ôffnet eine "shared lib"

!item [Gemdosnummer]   22

!item [Binding:]
(!link [Bindings fÅr Slbopen] [Bindings fÅr Slbopen])

!item [Beschreibung]   Die Funktion îffnet eine Shared Lib

!begin_xlist [Paramter]
!item [Parameter] Bedeutung

!item [~]
~
!item [name]       Der Name der Bibliothek, in Groûschrift,
                        inkl. Extension (".SLB"). Der Bibliotheks-
                         name ist gleichzeitig Dateiname.

!item [path]          Pfad bei dem zuerst nach der Bibliothek
                             gesucht (der Pfad muû in (!nolink [MagiC]) 5.20
                             mit '\' abgeschlossen sein; dies ist in
                             (!nolink [MagiC]) 6 nicht mehr nîtig). (!nl)
                             Wenn der Parameter NULL ist oder die
                             Bibliothek im angegebenen Pfad nicht gef-
                             unden wurde, wird im XTENSION-Ordner ge-
                             sucht. (!nl)
                             Ab (!nolink [MagiC]) 6 wird die Environment-Variable
                             SLBPATH ausgewertet. Sie enthÑlt wie PATH
                             eine Liste der Suchpfade, jeweils durch ';'
                             getrennt.Ist die Variable definiert, wird
                             nicht mehr extra im XTENSION-Ordner gesucht.

Bei FreeMiNT wird versucht die Bibliothek aus dem  aktuelle Verzeichnis zuladen, falls
(!I)path(!i) NULL ist.

!item [min_ver]       Minimal notwendige Versionsnummer der Bibliothek.

!item [sl]            Zeiger auf den Deskriptor.

!item [fn]            Zeiger auf den Funktionszeiger.
!end_xlist
     
!item [Ergebnis]       >= 0   ~~~~    Alles OK, Versionsnummer der Bibliothek. (!nl)
               ERANGE ~~    Versionsnummer zu niedrig (!nl)
               EACCDN ~~    Bibliothek schon von diesem Prozeû geîffnet (!nl)
               EFILNF ~~    Bibliothek nicht gefunden (!nl)
               ENSMEM ~~    zuwenig Speicher

!item [VerfÅgbar:]      Diese Funktion ist optional, daher darf ein
                        Aufruf mit (!nolink [EINVFN]) beantwortet werden. Sie steht 
                        ab (!nolink [MagiC]) 5.20 und FreeMiNT 1.15.4 zu VerfÅgung.

!item [Gruppe]         (!link [Systemfunktionen][Systemfunktionen des GEMDOS])

!item [Querverweis]    Slbclose ~ Shared Libraries
(!ende_liste)


!begin_node Bindings fÅr Slbopen
!ignore_index
(!begin_liste) [Assembler:]
!item [C:]
LONG Slbopen( char *name, char *path, LONG min_ver,
                             SHARED_LIB *sl, SLB_EXEC *fn );
!item [Assembler:]
!begin_verbatim
pea       fn           ; Offset 18
pea       sl           ; Offset 14
move.l    minver,-(sp) ; Offset 10
pea       path         ; Offset 6
pea       name         ; Offset 2
move.w    #22,-(sp)    ; Offset 0
trap      #1           ; GEMDOS aufrufen
addq.l    #22,sp       ; Stack korrigieren
!end_verbatim
(!ende_liste)
!end_node
!end_node


!begin_node Sconfig
(!begin_liste) [Beschreibung:]
!item [Name:]
ØSconfigÆ - erlaubt die Konfigurierung von Teilen des Betriebssystems.
!item [Gemdosnummer:]
51
!item [Binding:]
(!link [Bindings fÅr Sconfig] [Bindings fÅr Sconfig])
!item [Beschreibung:]
Die Funktion erlaubt die Konfigurierung von Teilen des Betriebssystems. Es
gilt:
!begin_xlist !short [Parameter]
!item [Parameter]
Bedeutung
!item [~]
~
!item [mode]
(!B)Aktion(!b)
!begin_xlist !short
!item [0 =]
Konfiguration ermitteln
!item [1 =]
Konfiguration setzen
!item [2 =]
Zeiger auf DOSVARS-Struktur ermitteln
!end_xlist
!item [flags]
(!B)Konfiguration als Bitvektor(!b)
!begin_xlist !short [Bit-11 =]
!item [Bit-0  =]
PfadÅberprÅfung ein
!item [Bit-1  =]
EinfÅgemodus fÅr GEMDOS und (!nolink [Dialogboxen])
!item [Bit-2  =]
reserviert
!item [Bit-3  =]
reserviert
!item [Bit-4  =]
Fastload fÅr Diskette ein
!item [Bit-5  =]
TOS-KompatibilitÑt ein
!item [Bit-6  =]
Smart-Redraw aus
!item [Bit-7  =]
Grow-/Shrinkboxen aus
!item [Bit-8  =]
kein Halt nach TOS-Programmen
!item [Bit-9  =]
reserviert
!item [Bit-10 =]
Pulldown-MenÅs
!item [Bit-11 =]
Floppy-Hintergrundbetrieb
!end_xlist
!end_xlist
(!B)Hinweis:(!b) Die Funktion steht nur unter MagiC ab Version 2.0 zur
VerfÅgung. Gesetzte Bits schalten die jeweilige Funktion ein, nicht gesetzte
Bits schalten sie wieder aus. (!nl)
Bit-11 steht erst ab (!nolink [MagiC]) 3.0 zur VerfÅgung.
Das Setzen der Konfiguration ist nur bei (!I)abgeschalteter(!i)
TOS-KompatibilitÑt mîglich.

Die Funktion is auch in KAOS vorhanden, allerings mit einer etwas anderen 
Belegung des Bitvektors.
!begin_xlist !short [Bit-11 =]
!item [Bit-0  =]
PfadÅberprÅfung ein
!item [Bit-1  =]
Diskwechsel-Simulation im Desktop ein
!item [Bit-2  =]
Break ein; CTRL-C Abfrage bei jedem DOS-Aufruf
!item [Bit-3  =]
CTRL-C Abfrage aus; fÅr zeichenorientierte Funktionen
!item [Bit-4  =]
Fastload fÅr Diskette ein
!end_xlist

!item [Ergebnis:]
Die Funktion liefert, in AbhÑngigkeit des Parameters (!I)mode(!i), die
aktuell gÅltige Konfiguration oder einen Zeiger auf eine DOSVARS-Struktur
zurÅck.
!item [Gruppe:]
(!link [Systemfunktionen][Systemfunktionen des GEMDOS])
!item [Querverweis:] Sysconf
(!ende_liste)


!begin_node Bindings fÅr Sconfig
!ignore_index
(!begin_liste) [Assembler:]
!item [C:]
LONG Sconfig ( WORD mode, LONG flags );
!item [Assembler:]
!begin_verbatim
move.l    flags,-(sp)  ; Offset 4
move.w    mode,-(sp)   ; Offset 2
move.w    #51,-(sp)    ; Offset 0
trap      #1           ; GEMDOS aufrufen
addq.l    #8,sp        ; Stack korrigieren
!end_verbatim
!ifdest [html]
!item [GFA-Basic]
!begin_raw
<A HREF="http://www.milanstation.de/at/gfahutil/gfau7gd.htm">GFA-H-Util GEMDOS</A>
!end_raw
!endif
(!ende_liste)
!end_node
!end_node


!begin_node Srealloc
(!begin_liste) [Beschreibung:]
!item [Name:]
ØSreallocÆ - Bildschirmspeicher allozieren.
!item [Gemdosnummer:]
21
!item [Binding:]
(!link [Bindings fÅr Srealloc] [Bindings fÅr Srealloc])
!item [Beschreibung:]
Die GEMDOS-Routine Srealloc alloziert fÅr den Bildschirmspeicher einen
Bereich der LÑnge (!I)len(!i) Bytes.

Der Bildschirmspeicher ist ein Block des ST-RAM, dessen Eigner der
Bootprozeû ist. Die Adresse des Bildschirmspeichers (logbase oder physbase)
wird von dieser Funktion nicht beeinfluût.

(!B)Achtung:(!b) Diese Funktion ist optional, daher darf ein Aufruf mit
EINVFN beantwortet werden.
!item [Ergebnis:]
Die Funktion liefert (falls (!I)len(!i) den Wert -1 besitzt) die maximal
mîgliche Grîûe des Bildschirmspeichers zurÅck.
!item [Gruppe:]
(!link [Systemfunktionen][Systemfunktionen des GEMDOS])
#item [Querverweis:]
(!ende_liste)


!begin_node Bindings fÅr Srealloc
!ignore_index
(!begin_liste) [Assembler:]
!item [C:]
LONG Srealloc ( LONG len );
!item [Assembler:]
!begin_verbatim
move.l    len,-(sp)    ; Offset 2
move.w    #21,-(sp)    ; Offset 0
trap      #1           ; GEMDOS aufrufen
addq.l    #6,sp        ; Stack korrigieren
!end_verbatim
!ifdest [html]
!item [GFA-Basic]
!begin_raw
<A HREF="http://www.milanstation.de/at/gfahutil/gfau7gd.htm">GFA-H-Util GEMDOS</A>
!end_raw
!endif
(!ende_liste)
!end_node
!end_node




!begin_node Ssystem
(!begin_liste) [Beschreibung:]
!item [Name:]
ØSsystemÆ - controlling Cookie Jar, memory access and various system settings.
!item [Gemdosnummer:]
340 (0x0154)
!item [Binding:]
(!link [Bindings fÅr Ssystem] [Bindings fÅr Ssystem])
!item [Beschreibung:]
The Ssystem call has been designed to make your life easier. Using this
you can get some closer (!nolink [control]) on the system and the kernel itself. Via
this call the kernel now supports e.g. an easy Cookie Jar management and
provides a safe access to supervisor memory. It's strictly encouraged to
access GEMDOS variables and system vectors via the Ssystem(), because this
way is considered safe for multiuser setups.

(!I)arg1(!i) and (!I)arg2(!i) are long parameters specific for a 
particular mode. If a mode doesn't use a parameter, it is 
usually ignored, but should be set to a zero for future compatibility. 
mode specifies a particular action as follows:

!begin_xlist [S_OSNAM]
!item [mode] meaning

!item [S_OSNAME(0x0000)]
Identifies the operating system type. Returned longword contains a 
32-bit positive number, which interpreted as an ASCII string gives a 
4-character id. For MiNT the returned value is 0x4d694e54 
('MiNT').

!item [S_OSXNAME(0x0001)]
Identifies the subtype of the operating system. If this call 
returns a zero or a negative value, that means, that no subtype is 
available. Otherwise the returned value, when interpreted as an ASCII 
string gives a 4-character subtype id. For FreeMiNT, being a 
derivative of the MiNT, the returned value is 0x46726565 ('Free').

If a subtype id is less than 4 characters long, it should be padded with zeros.

!item [S_OSVERSION(0x0002)]
Identifies the exact operating system version. Returned longword 
contains a 32 bit positive version number encoded as follows: 
!begin_verbatim
bits  meaning
----  -------
0-7   some printable character
      to characterize the current version,
      e.g.
      0x61 (`a') if alpha release,
      0x62 (`b') if beta release.
      For official releases you will
      always find a value of 0 here.
8-15  patchlevel (0x55 for pl 88)
16-23 minor version number (0x0e for x.14)
24-31 major version number ($01 for 1.xx)
!end_verbatim
Definition of an official release: every release for which in 
bits 0-7 a value of 0 is returned...

!item [S_OSHEADER(0x0003)]
Allows to access the TOS header in order to get some 
information from. Current implementation allows to access the first 
256 longwords of the header. The address of the required longword, 
relative to the begin address of the TOS header, has to be specified as 
arg1. Only even values are allowed (bit 0 of the 
arg1 is masked out by the kernel). Always a whole 
longword is returned.

!item [S_OSBUILDDATE(0x0004)]
Returns a 32 bit positive value with the build date encoded as follows:
!begin_verbatim
bits  meaning
----  -------
0-15  binary year ($07dd for 1998)
16-23 binary month ($0c for the December)
24-31 binary day of the month 
!end_verbatim

!item [S_OSBUILDTIME(0x0005)]
Returns a 32 bit positive value with the build time encoded as 
follows:
!begin_verbatim
bits  meaning
----  -------
0-7   binary seconds
8-15  binary minutes
16-23 binary hours
24-31 day of week
!end_verbatim
day of week has 1 for Monday, 2 for Tuesday... 7 for Sunday.

The call should never return a zero in these bits, but if it 
does, it should be interpreted as Sunday.

!item [S_OSCOMPILE(0x0006)]
Returns a 32-bit positive value specifying the primary CPU type the 
kernel has been compiled for. Encoding:
!begin_verbatim
bits  meaning
----  -------
0-7   binary minor CPU ID
8-15  binary major CPU ID
16-31 reserved for future definition.
!end_verbatim
The major ID identifies a particular series of processors. Currently 
only a value of $00 is defined and it is assigned to Motorola 68k 
series. Other values of this field are reserved for future definition.

The minor CPU ID interpretation depends on the major ID. For 
68k series, values are as follows:
!begin_verbatim
$00 68000
$0a 68010
$14 68020
$1e 68030
$28 68040
$3c 68060
!end_verbatim
This is not the same as the _CPU cookie value. The 
(!nolink [_CPU]) cookie specifies the CPU physically present in the 
machine, while the S_OSCOMPILE indicates the processor 
type selected at the time when the system was compiled. In other words, 
running a 68000 compiled kernel will return a $00 here, even if the 
machine is running 68040 or something.

!item [S_OSFEATURES(0x0007)]
Returns a 32-bit positive value specifying the state of kernel 
features. Encoding:
!begin_verbatim
bits  meaning
----  -------
0     memory protection (1 = turned on)
1     virtual memory (1 = turned on)
2-31  reserved for future usage 
!end_verbatim
This call has an informative purpose only and you cannot toggle 
anything with it.

!item [S_GETCOOKIE(0x0008)]
Fetches required information from the Cookie Jar.

!begin_enumerate
!item If arg1 is a value bigger than 65535 (0xffff), it is 
interpreted as a tag id. The Cookie Jar is searched for such a tag, 
then if the tag is found, the corresponding slot value is returned or 
-1 otherwise.

!item If arg1 is a value between 1 and 65535, it is 
interpreted as a slot number, not a tag id.Then the corresponding tag 
id is fetched and returned or a value of -1 if the specified slot is 
free or does not exist at all (a slot number past the end of the Cookie 
Jar was specified). The first slot in the Cookie Jar is considered 
number 1.

!item If arg1 is equal to a zero, then the Cookie Jar is 
searched for the NULL cookie, then the corresponding slot value 
is returned.
!end_enumerate
The place where the value fetched from the Cookie Jar will be returned 
is defined by the arg2. If this is a zero, the call 
returns its values in the GEMDOS return value (d0). If the 
arg2 is not a zero, it is interpreted as a pointer to a 
memory location, where the slot tag or its value should be written to. 
The return value is 0 (E_OK) then, if everything went OK, or -1 
otherwise.

This behaviour (where arg2 != NULL) is not implemented in MiNT versions
below 1.14.8.

!item [S_SETCOOKIE(0x0009)]
Places a tag id specified by the arg1 with the value of 
the arg2 in the Cookie Jar. If a slot with the specified 
tag id already exists, it will be replaced with the new value. 
NULL cookie is reallocated automatically and its value is 
adjusted. If there are no more free slots, no action is performed and 
ENOMEM is returned instead.

S_SETCOOKIE requires root euid, EACCES is returned 
otherwise and no action is performed.

The call refuses to place a cookie (a value of -1 is returned) 
whose tag id contains a zero-byte.

!item [S_GETLVAL(0x000a)]
Fetches and returns a longword from the address of supervisor area 
specified as a 16-bit, even, unsigned integer value passed as 
arg1. Bit 0 and bits 16-31 are masked out (ignored). 
The call returns a zero if the value at the specified address has to be 
"hidden" from reading. Currently the hidden values are the initial PC 
value and the initial stack pointer value stored at $00000000 and 
$00000004 respectively. Reading a hidden value may require root 
euid.

If the desired address is long word aligned, longwords can be 
also retrieved from the supervisor area using Setexc().

!item [S_GETWVAL(0x000b)]
Fetches and returns a word from the address of supervisor area 
specified as a 16-bit, even, unsigned integer value passed as 
arg1. Bit 0 and bits 16-31 are masked out (ignored). 
The call returns a zero if the value at the specified address has to be 
"hidden" from reading. Currently the hidden values are the initial PC 
value and the initial stack pointer value stored at $00000000 and 
$00000004 respectively. Reading a hidden value may require root 
euid.

!item [S_GETBVAL(0x000c)]

Fetches and returns a byte from the address of supervisor area 
specified as a 16-bit unsigned integer value passed as 
arg1. Bits 16-31 are masked out (ignored). The call 
returns a zero if the value at the specified address has to be "hidden" 
from reading. Currently the hidden values are the initial PC value and 
the initial stack pointer value stored at $00000000 and $00000004 
respectively. Reading a hidden value may require root euid.

!item [S_SETLVAL(0x000d)]
Places a longword value specified by arg2 at address 
specified as 16 bit integer by arg1. Bit 0 and bits 
16-31 of the arg1 are masked out (ignored). Since this 
call is designed to manipulate operating system variables located 
within the supervisor area (first 32k), it is restricted for root 
euid and returns EACCES if called by an unprivileged 
process.

!item [S_SETWVAL(0x000e)]
Places a word value specified by arg2 at address 
specified as 16 bit integer by arg1. Bit 0 and bits 
16-31 of the arg1 are masked out (ignored). Since this 
call is designed to manipulate operating system variables located 
within the supervisor area (first 32k), it is restricted for root 
euid and returns EACCES if called by an unprivileged 
process.

!item [S_SETBVAL(0x000f)]
Places a byte value specified by arg2 at address 
specified as 16 bit integer by arg1. Bits 16-31 of the 
arg1 are masked out (ignored). Since this call is 
designed to manipulate operating system variables located within the 
supervisor area (first 32k), it is restricted for root 
euid and returns EACCES if called by an unprivileged 
process.

!item [S_SECLEVEL(0x0010)]
Resets the current security level to a value specified by 
arg1. Valid levels are as follows:

0: none of hardware specific system calls are restricted. This 
is a 'MultiTOS compatibility' mode.

1: BIOS and XBIOS calls require root 
privileges; any call except Supexec() and Super() returns 
EACCES if called by an unprivileged process. This does not apply 
to Setexc(), which sends SIGSYS to the caller if a change of an 
exception vector was attempted.

2: as above, with except that (!nolink [Supexec])() and 
(!nolink [Super])() generates (!nolink [SIGSYS]) in order to kill the calling 
process.

On values bigger than a 2, the EACCES is returned. If 
arg1 is equal to a -1, the current security level value 
is returned.

The call totally needs root privileges - user processes cannot 
even inquire the current security level value.

!item [S_RUNLEVEL(0x0011)]
Reserved for future definition.

!item [S_TSLICE(0x0012)]
Allows to set/interrogate the (!nolink [global]) timeslice value. Values are 
exactly the same as for SLICES keyword in mint.cnf. If 
arg1 is equal to -1, the call returns the current (!nolink [global])
timeslice value.

Setting the timeslice requires root privileges.

!item [S_FORCEFASTLOAD(0x0013)]
Allows to change the interpretation of the FASTLOAD bit in the 
program header.

On Ssystem(S_FORCEFASTLOAD, 0L, 0L); the program header bit 
will be used as before, this is actually equal to FASTLOAD=NO in 
mint.cnf.

On Ssystem(S_FORCEFASTLOAD, 1L, 0L); , the program header bit 
will be ignored and fastload will be forced for all programs. 

arg1 = -1 allows to interrogate the current state of this 
variable.

You need root privileges to toggle the FASTLOAD 
mode.

!item [S_SYNCTIME(0x0014)]
Allows to interrogate or change the (!nolink [global]) filesystem sync time. 
The default value is 5 sec.

If arg1 is a positive value, it is interpreted as a 
new sync time value.

If arg1 is equal to -1, the current sync time value 
will be returned.

To be able to change the filesystem sync time you need root 
privileges desperately.

!item [S_BLOCKCACHE(0x0015)]
A positive value of arg1 ranging from 0 to 
100, specifies the percentage of filesystem cache to be filled with 
linear reads, as in the PERCENTAGE keyword in the mint.cnf file. A 
negative value of arg1 returns the currently set 
percentage value.

Root privileges are required to use this mode.

!item [S_FLUSHCACHE(0x0016)]
Invalidates CPU cache entries. The arg1 is a pointer 
to the memory area whose cache entries should be invalidated, the 
arg2 is the size of the area in bytes. Passing -1 as the 
arg2 invalidates all cache entries. If the CPU features a 
separate instruction and data caches, both are flushed.

This call automatically recognizes caches in 68020/030/040/060 and 
handles them as appropriate. The 68060 branch cache is 
automatically invalidated too. On 68000/68010 calling this mode has no 
effect. This mode is in fact just an interface to the MiNT function 
cpush() used internally by the system.

Root privileges are NOT required to use this mode.

!item [S_CTRLCACHE(0x0017)]
Provides an universal (among 68k family members) way of controlling 
the CPU on chip caches. The arg1, referenced as Cache 
Control Word (CCW) is a bitfield where each bit enables (if 1) or 
disables (if 0) a particular function of CPU caches. The 
arg2, referenced as Cache Control Mask (CCM), is a bit 
mask where you define (by setting appropriate bits to 1) which bits of 
the Cache Control Word should be actually taken into account and 
written into the Cache Control Register (CACR). This is (!nolink [control])
mode of the S_CTRLCACHE.

In inquire mode you can pass -1 as either argument. If the 
CCW is -1, the call returns a longword reflecting the actual state of 
the caches.

If the CCM is -1, a default bitmask is returned, where any bit set 
indicates, that a cache function defined by the same bit in the 
Cache Control Word is valid for the processor the MiNT is currently 
running on.

If both arguments are negative, the call simply returns E_OK 
if it is valid at all or ENOSYS otherwise. This is the 
acknowledge mode of the S_CTRLCACHE.

Bits in either argument are defined as follows:
!begin_verbatim
0     enable instruction cache
1     enable data cache
2     enable branch cache
3     freeze instruction cache
4     freeze data cache
5     instruction burst enable
6     data burst enable
7     enable write allocate
8     instruction cache full mode enable
9     instruction cache read/write allocate enable
10    data cache full mode enable
11    data cache read/write allocate enable
12    invalidate branch cache
13    invalidate branch cache user entries
14    enable CPUSH invalidate
15    enable store buffer
16-31 reserved for future definition
!end_verbatim
Notice, that no processor currently supports all of these functions 
and some (68000 and 68010) have no on-chip caches at all. To figure 
out, what functions are valid for the actual CPU used, you should first 
request the default bitmask using the inquire mode described 
above. Your program should save this mask, logically AND the 
arg2 with it, then pass the result as the Cache Control 
Mask for a (!nolink [control]) mode call.

Also notice, that the above bit definition does not exactly 
reflect the function and even position of actual bits in the physical 
Cache Control Register. The bits of either argument are arbitrarily 
assigned to particular cache functions, but their position and state 
are converted by the system before the Cache Control Register is 
written and after it is read, so that the user program can see always 
the same functions assigned to bits as above regardless of the physical 
configuration of the Cache Control Register.

Since changing cache configuration is (!nolink [global]) and may severely 
affect system performance, root privileges are needed to use 
S_CTRLCACHE (!nolink [control]) mode.

!item [S_INITIALTPA(0x0018)]
A positive non-zero value of arg1 defines the default 
amount of memory (in bytes) allocated for TPA space, as in the 
INITIALMEM keyword of the mint.cnf file. A negative value allows to 
interrogate the value currently set. A value of 0 is illegal and will 
cause the call to fail and return EBADARG. Notice that even if 
you define a very small value, like 1 or 2 bytes, the system will round 
this up to the smallest size of a memory block possible to allocate.

Root privileges are required to use this mode.

!item [S_CAD(0x0019)]
Reserved for future definition.

!item [S_CLOCKMODE(0x0064)]
S_CLOCKMODE called with an arg1 of -1 inquires the 
kernel's notion of the hardware system clock. If the command returns 
a zero, the hardware clock is considered to tick in UTC; if it returns 
a positive non-zero value, it is considered to tick in local time.
Any other positive value of the arg1 sets the current 
clock mode. On a 0 it is reset to UTC, or to local time otherwise.

Although this call will never really change the setting of the 
hardware clock, due to the changed interpretation the clock seems to 
warp; don't play around too much with it.

!item [S_KNAME(0x0384)]
arg1 and arg2 specify the address and 
length in bytes, respectively, of a memory buffer, where will be 
written a NULL terminated ASCII string identifying the full name 
and version of the system kernel. If the memory buffer is not long 
enough to hold the entire string, the string is truncated down to the 
buffer size.

!item [S_CNAME(0x038e)]
arg1 and arg2 specify the address and 
length in bytes, respectively, of a memory buffer, where will be 
written a NULL terminated ASCII string identifying the full name 
of the compiler used to compile the system kernel. If the memory buffer 
is not long enough to hold the entire string, the string is truncated 
down to the buffer size.

!item [S_CVERSION(0x038f)]
arg1 and arg2 specify the address and 
length in bytes, respectively, of a memory buffer, where will be 
written a NULL terminated ASCII string identifying the version 
of the compiler used to compile the system kernel. If the memory buffer 
is not long enough to hold the entire string, the string is truncated 
down to the buffer size.

!item [S_CDEFINES(0x0390)]
arg1 and arg2 specify the address and 
length in bytes, respectively, of a memory buffer, where will be 
written a NULL terminated ASCII string containing the 
compile time definitions (switches) used while compiling the system 
kernel. If the memory buffer is not long enough to hold the entire 
string, the string is truncated down to the buffer size.

!item [S_COPTIM(0x0391)]
arg1 and arg2 specify the address and 
length in bytes, respectively, of a memory buffer, where will be 
written a NULL terminated ASCII string containing the compile 
time optimization options used while compiling the system kernel. If 
the memory buffer is not long enough to hold the entire string, the 
string is truncated down to the buffer size.

!item [S_DEBUGLEVEL(0x03e8)]
S_DEBUGLEVEL called with an arg1 of -1 inquires 
the kernel's current debug level. Any other positive value will set 
the current debug level. If it is a zero, the kernel will not output 
any debugging information, except for fatal error messages. The higher 
the debug level, the more MiNT will spew about what it is doing.

Notice, that special debug kernels will output more information than 
an ordinary distribution kernel.

Root privileges are needed to change the debug level.

!item [S_DEBUGDEV(0x03e9)]
S_DEBUGDEV called with an arg1 of -1 inquires the 
current BIOS device to output the debug information to. The order of 
defined (!nolink [BIOS]) devices is as follows:
!begin_itemize !short
!item  0, printer
!item   1, AUX:
!item   2, console (default)
!item   3, MIDI
!item   4, keyboard
!item   5, raw screen
!end_itemize

Any positive value of arg1, that ranges from 0 to 9, 
will redirect the debug information output to an appropriate BIOS 
device. Notice however, that setting device 4 (keyboard) as a debug 
device does not make much sense and may produce undesired results. The 
system does not restrict this in any way though, just assuming that you 
know what you're doing.

Root privileges are needed to change the debug device.

!item [S_TIOCMGET(0x54f8)]
This mode is reserved for the internal and exclusive usage of the 
MiNT Library.
!end_xlist

Ssystem() was first introduced as of MiNT version 1.14.6, but it is
considered fully functional as of MiNT version 1.15.0 release.

The S_OSHEADER opcode should be only used for fetching the 
TOS version number when running MiNT versions below 1.15.0 release.

The S_FLUSHCACHE, S_CTRLCACHE, S_DEBUGLEVEL and 
S_DEBUGDEV are supported as of MiNT version 1.15.1 release.

You should never use Ssystem(S_TIOCMGET, ...); in own 
programs.

The Ssystem() behaviour does not depend on the 
S_SECLEVEL settings.

Any values returned by the kernel on reserved fields should 
be considered undocumented and no software should rely on 
them.

Its strictly encouraged to 
access GEMDOS variables and system vectors via the Ssystem(), 
because this way is considered safe for multiuser setups. For example, 
you can access the cookie jar pointer using Ssystem(S_GETLVAL, 
0x05a0, NULL), though if TOS compatibility is the issue, you should 
rather use 2, -1).

Prior to any further Ssystem() usage, your application should 
first check if the kernel supports this call. If it does, the 
Ssystem(-1, 0L, 0L); should return a zero.

Ssystem() is used and supported by the MiNT Library 
as of patchlevel 48.

!item [Ergebnis:]

!item [VerfÅgbar:]
Available when a 'MiNT' cookie with a version of at least 1.15 exists.

!item [Gruppe:]
(!link [Systemfunktionen][Systemfunktionen des GEMDOS])
!item [Querverweis:] Tgettimeofday ~ Tsettimeofday
(!ende_liste)


!begin_node Bindings fÅr Ssystem
!ignore_index
(!begin_liste) [Assembler:]
!item [C:]
LONG Ssystem ( WORD mode, LONG arg1, LONG arg2 );
!item [Assembler:]
!begin_verbatim
move.l    arg2,-(sp)   ; Offset 8
move.l    arg1,-(sp)   ; Offset 4
move.w    mode,-(sp)   ; Offset 2
move.w    #340,-(sp)   ; Offset 0
trap      #1           ; GEMDOS aufrufen
lea       $0c(sp),sp   ; Stack korrigieren
!end_verbatim
(!ende_liste)
!end_node
!end_node




!begin_node STEFcntrl
(!begin_liste) [Beschreibung:]
!item [Name:]
ØSTEFcntrlÆ - STEmulator (!nolink [Kontrollfunktionen])
!item [Gemdosnummer:]
24000 (0x5DC0)

!item [Binding:]
(!link [Bindings fÅr STEFcntrl] [Bindings fÅr STEFcntrl])
!item [Beschreibung:]

SET_INFOTEXT (1) (!nl)
special1 = (char *) Zeiger auf neue Infozeile (!nl)
special2 = (char *) Zeiger auf alte Infozeile

Der String auf den (!I)special1(!i) zeigt, wird als neue Infozeile in die
Status-Zeile des STEmulator Åber!-nommen. Ein Wert von NULL schaltet
wieder auf die Standard-Anzeige zurÅck.

Wenn in (!I)special2(!i) ein gÅltiger Zeiger auf einen Buffer Åbergeben wird,
enthÑlt dieser nach dem Funktions!-aufruf den alten Text der Infozeile.
Bei NULL, passiert nichts.

SET_WINDOWTITLE (2) (!nl)
special1 = (char *) Zeiger auf neue Titelzeile (!nl)
special2 = (char *) Zeiger auf alte Titelzeile

Der String auf den (!I)special1(!i) zeigt, wird als neue (!nolink [Titel]) des
STEmulator-Fenster Åbernommen.

Wenn in (!I)special2(!i) ein gÅltiger Zeiger auf einen Buffer Åbergeben wird,
enthÑlt dieser nach dem Funktions!-aufruf den alten Fenstertitel.
Bei NULL, passiert nichts.

!item [Ergebnis:]
EINVFN = Unbekannte Funktion (!nl)
ERANGE = ungÅltiger Parameter

!item [VerfÅgbar:]
STEmulator

!item [Gruppe:]
(!link [Systemfunktionen][Systemfunktionen des GEMDOS])

#item [Querverweis:] 
(!ende_liste)


!begin_node Bindings fÅr STEFcntrl
!ignore_index
(!begin_liste) [Assembler:]
!item [C:]
LONG STEFcntrl ( WORD func, LONG special1, LONG special2 );
!item [Assembler:]
!begin_verbatim
move.l    special2,-(sp)   ; Offset 8
move.l    special1,-(sp)   ; Offset 4
move.w    func,-(sp)       ; Offset 2
move.w    #24000,-(sp)     ; Offset 0
trap      #1               ; GEMDOS aufrufen
lea       $0c(sp),sp       ; Stack korrigieren
!end_verbatim
(!ende_liste)
!end_node

!end_node



!begin_node Super
(!begin_liste) [Beschreibung:]
!item [Name:]
ØsupervisorÆ - Supervisor-Modus umschalten.
!item [Gemdosnummer:]
32 (0x0020)

!item [Binding:]
(!link [Bindings fÅr Super] [Bindings fÅr Super])
!item [Beschreibung:]
Die GEMDOS-Routine Super schaltet zwischen User- und Supervisior-Modus um
bzw. fragt den aktuellen Betriebsmodus ab.

Die Adresse des Supervisor-Stacks kann beim Umschalten verÑndert werden.
Åbergibt man fÅr den Parameter (!I)stack(!i) den Wert 1, so wird der
aktuelle Betriebsmodus erfragt. Der Wert 0 schaltet zwischen User und
Supervisor-Modus um. Alle anderen Werten werden als neue Adresse fÅr den
Supervisor-Stack betrachtet. Im Supervisor-Modus kann auf alle geschÅtzten
Speicherstellen zugegriffen werden.

(!B)Hinweis:(!b) Im Hinblick auf zukÅnftige Betriebssystemversionen sollten
Sie den Einsatz der Super-Funktion vermeiden. Diese Funktion verursacht im
Zusammenhang mit virtuellem Speicher und unterbrechbaren (und reentranten)
Dateisystemen in einem Multitaskingsystem groûe Probleme. Stellen Sie ggf.
Ihren Code so um, daû Sie die BIOS-Funktion Supexec verwenden kînnen.

FÅr MiNT gilt: (!nl)
If you are in SECURELEVEL > 1, you must have root privileges
to get into supervisor mode. If you don't have them and call Super,
the SIGSYS signal (12) will be raised.

!item [Ergebnis:]
Sollte der Zustand ermittelt werden, erhÑlt man als Resultat 0 fÅr den User-
und -1 fÅr den Supervisor-Modus. Ansonsten liefert die Funktion als Ergebnis
die Adresse des alten Supervisor-Stacks, sofern in den Supervisor-Modus
umgeschaltet wurde.

!item [VerfÅgbar:]
Allen (!nolink [GEMDOS]) Versionen

!item [Gruppe:]
(!link [Systemfunktionen][Systemfunktionen des GEMDOS])

!item [Querverweis:] Supexec
(!ende_liste)


!begin_node Bindings fÅr Super
!ignore_index
(!begin_liste) [Assembler:]
!item [C:]
LONG Super ( VOID *stack );
!item [Assembler:]
!begin_verbatim
pea       stack        ; Offset 2
move.w    #32,-(sp)    ; Offset 0
trap      #1           ; GEMDOS aufrufen
addq.l    #6,sp        ; Stack korrigieren
!end_verbatim
!ifdest [html]
!item [GFA-Basic]
!begin_raw
<A HREF="http://www.milanstation.de/at/gfahutil/gfau7gd.htm">GFA-H-Util GEMDOS</A>
!end_raw
!endif
(!ende_liste)
!end_node

!begin_node Hinweis zur Verwendung der (!nolink [GEMDOS])-Funktion (!nolink [Super])

Die Funktion (!nolink [Super]) setzt bei der Umschaltung in den Supervisormode den
(!nolink [Super])-Stackpointer auf den User-Stack des Programms. Das kann fatal sein, da
das Programm nicht wissen kann, wie groû ein (!nolink [Super])-Stackbereich sein muû.
Ein zu kleiner Stack kann zu Fehlverhalten, AbstÅrzen o.Ñ. fÅhren. Der
(!nolink [Super])-Stack liegt nicht mehr in einem mîglicherweise durch
Speicherschutzmechanismen gesicherten Bereich, kann also durch das Programm
zerstîrt werden.

Ein Teil des User-Stacks kînnte durch virtuelle Speichermechanismen
ausgelagert worden sein. Ein ausgelagerter (!nolink [Super])-Stack bedeutet
Prozessorhalt, da der MC-680x0 Prozessor seine bei Exceptions Åbliche
Sicherung des CPU-Status auf den (!nolink [Super])-Stack nicht mehr durchfÅhren kann und
dann absichtlich stehenbleibt. Kein Anwendungsprogrammierer sollte es sich
anmaûen, dem System irgendeine BeschrÑnkung der Supervisorstackgrîûe
aufzuerlegen.

Querverweis: GEMDOS ~  Supexec
!end_node
!end_node




!begin_node Suptime
(!begin_liste) [Beschreibung:]
!item [Name:]
ØSuptimeÆ - returns the current uptime and load averages from the system.
!item [Gemdosnummer:]
319 (0x013f)

!item [Binding:]
(!link [Bindings fÅr Suptime] [Bindings fÅr Suptime])
!item [Beschreibung:]
This function returns the current uptime and load  averages from the system.

(!I)uptime(!i) is a pointer to a LONG value that will be filled with the current 
amount of seconds elapsed since last reboot.

(!I)loadaverage(!i) is a pointer to a three longword array, that will 
be filled with the current load averages (for last 1, 5 and 15 minutes).

The load average value is calculated using the following formula:

sum += (new_load - old_load) * LOAD_SCALE; (!ml)
load_avg = sum / MAX_SIZE;

where LOAD_SCALE is 2048, MAX_SIZE is the number of 5 
second periods in the specified amount of time (12 for 1 min., 60 for 5 
min. and 180 for 15 min). new_load is the number of currently 
running processes, old_load is the number of processes running 
previous time. A 'running' process is considered the one which 
is put onto run or ready queue.

!item [Ergebnis:]
Returns E_OK or a negative GEMDOS error code otherwise (actually it may 
be only ENOSYS if the call is not supported...).

!item [VerfÅgbar:]
Available when a 'MiNT' cookie with a version of at least 1.11 exists.

!item [Gruppe:]
(!link [Systemfunktionen][Systemfunktionen des GEMDOS])

#item [Querverweis:]
(!ende_liste)


!begin_node Bindings fÅr Suptime
!ignore_index
(!begin_liste) [Assembler:]
!item [C:]
LONG Suptime ( LONG *uptime, LONG *loadaverage );
!item [Assembler:]
!begin_verbatim
pea       loadaverage  ; Offset 6
pea       uptime       ; Offset 4
move.w    #48,-(sp)    ; Offset 0
trap      #1           ; GEMDOS aufrufen
lea       $0a(sp),sp   ; Stack korrigieren
!end_verbatim
(!ende_liste)
!end_node
!end_node




!begin_node Sversion
!label GEMDOS, Versionsnummer
!label Versionsnummer des GEMDOS
(!begin_liste) [Beschreibung:]
!item [Name:]
Øoperating system versionÆ - ermittelt die Nummer der (!nolink [GEMDOS])-Version.
!item [Gemdosnummer:]
48
!item [Binding:]
(!link [Bindings fÅr Sversion] [Bindings fÅr Sversion])
!item [Beschreibung:]
Die GEMDOS-Routine Sversion ermittelt die Versionsnummer des (!nolink [GEMDOS]). Zur
Zeit sind folgende Versionen bekannt:
!begin_xlist [Version]
!item [Version]
ErklÑrung
!item [~]
~
!item [0.13]
Findet sich in TOS 1.00 und 1.02. Diese Version zeichnet sich durch etliche
Fehler aus, sollte daher nicht mehr benutzt werden.
!item [0.14]
Nummer des Turbo-DOS, welches fÅr eine kurze Zeit von Atari mit Festplatten
ausgeliefert wurde. Schnell, aber auch sehr unsicher. Auch KAOS 1.2.x besitzt
diese Versionsnummer
!item [0.15]
Findet sich in TOS 1.04 und 1.06. Diese Version ist relativ schnell und
stabil.
!item [0.16]
KAOS 1.4.x
!item [0.17]
Findet sich in TOS 1.62. Der Unterschied zur Version 0.15 liegt lediglich
darin, daû das Patchprogramm POOLFIX3.PRG nicht mehr benîtigt wird.
!item [0.19]
Wurde zuerst im TOS 3.01 des Atari-TT gesichtet. Diese Version wurde im
wesentlichen um Funktionen zur Verwaltung des Alternate-Memory erweitert,
und wird auch von (!nolink [MagiC]) bis Version 6.10 angezeigt.
!item [0.20]
TOS 2.06 und TOS 3.06 haben die (!nolink [GEMDOS])-Version 0.20. Einzige bislang bekannte
énderung: Medien mit nur einer FAT werden unterstÅtzt. (!nl)
(!nolink [MagiC]) 6.20 gibt ebenfalls 0.20 zurÅck.
!item [0.30]
TOS 4.04

!item [0.32] MilanTOS 4.08, Release 08.07.1999
 
!item [0.33] MilanTOS 4.08, Release 15.06.2001

!item [0.40] FreeMiNT
!end_xlist
!item [Ergebnis:]
Die Funktion liefert die genannte Versionsnummer, und zwar wie folgt:
!begin_xlist !short [High-Byte :]
!item [Low-Byte :]
Haupt-Versionsnummer
!item [High-Byte :]
Neben-Versionsnummer
!end_xlist

!item [VerfÅgbar:]
Alle (!nolink [GEMDOS]) Versionen

!item [Gruppe:]
(!link [Systemfunktionen][Systemfunktionen des GEMDOS])

!item [Querverweis:] Sysconf ~ TOS Liste
(!ende_liste)

# Quelle: Im ST-Computer 1/90 S. 122 stehen ganz andere Werte?
# Quelle: Im ST-Magazin  xxxx S. 66 stehen ganz andere Werte?


!begin_node Bindings fÅr Sversion
!ignore_index
(!begin_liste) [Assembler:]
!item [C:]
UWORD Sversion ( VOID );
!item [Assembler:]
!begin_verbatim
move.w    #48,-(sp)    ; Offset 0
trap      #1           ; GEMDOS aufrufen
addq.l    #2,sp        ; Stack korrigieren
!end_verbatim
!ifdest [html]
!item [GFA-Basic]
!begin_raw
<A HREF="http://www.milanstation.de/at/gfahutil/gfau7gd.htm">GFA-H-Util GEMDOS</A>
!end_raw
!endif
(!ende_liste)
!end_node
!end_node


!begin_node Syield
(!begin_liste) [Beschreibung:]
!item [Name:]
ØSyieldÆ - CPU fÅr andere Prozesse freigeben.
!item [Gemdosnummer:]
255 
!item [Binding:]
(!link [Bindings fÅr Syield] [Bindings fÅr Syield])
!item [Beschreibung:]
Durch den Aufruf dieser Funktion, gibt ein Prozeû die CPU ab, so daû anderen
Prozessen diese (mîglicherweise frÅher als geplant) zugeteilt werden kann.

(!B)Hinweis:(!b) Unter (!nolink [MagiC]) ruft diese Funktion direkt die (!nolink [AES])-Routine
appl_yield auf, und wird im Auto-Ordner ignoriert.


!item [Ergebnis:]
Die Funktion liefert kein Ergebnis.

!item [Gruppe:]
(!link [Systemfunktionen][Systemfunktionen des GEMDOS])

!item [VerfÅgbar:]
Diese Funktion ist optional, daher darf ein Aufruf mit EINVFN beantwortet
werden. Sie steht in (!nolink [MagiC]) ab Version 3.0 und wenn der MiNT Cookie vorhanden
ist zur VerfÅgung.

!item [Querverweis:] Pause ~ Fselect
(!ende_liste)


!begin_node Bindings fÅr Syield
!ignore_index
(!begin_liste) [Assembler:]
!item [C:]
VOID Syield ( VOID );
!item [Assembler:]
!begin_verbatim
move.w    #255,-(sp)   ; Offset 0
trap      #1           ; GEMDOS aufrufen
addq.l    #2,sp        ; Stack korrigieren
!end_verbatim
!ifdest [html]
!item [GFA-Basic]
!begin_raw
<A HREF="http://www.milanstation.de/at/gfahutil/gfau7gd.htm">GFA-H-Util GEMDOS</A>
!end_raw
!endif
(!ende_liste)
!end_node
!end_node


!begin_node Ssync
!label Sync
(!begin_liste) [Beschreibung:]
!item [Name:]
ØSsyncÆ - synchronisiert alle gemounteten Dateisysteme.
!item [Gemdosnummer:]
336 (0x0150)

!item [Binding:]
(!link [Bindings fÅr Ssync] [Bindings fÅr Ssync])
!item [Beschreibung:]
Die Funktion synchronisiert alle gemounteten Dateisysteme.

(!B)Achtung:(!b) In MiNT wird diese Funktion mit Sync bezeichnet.

!item [Ergebnis:]
Die Funktion liefert kein Ergebnis zurÅck.

!item [VerfÅgbar:]
MagiC ab Version 4.01 und under all MiNT versions integrated with MultiTOS.

!item [Gruppe:]
(!link [Systemfunktionen][Systemfunktionen des GEMDOS])

!item [Querverweis:] Shutdown
(!ende_liste)


!begin_node Bindings fÅr Ssync
!ignore_index
(!begin_liste) [Assembler:]
!item [C:]
VOID Ssync ( VOID );
!item [Assembler:]
!begin_verbatim
move.w    #336,-(sp)   ; Offset 0
trap      #1           ; GEMDOS aufrufen
addq.l    #2,sp        ; Stack korrigieren
!end_verbatim
!ifdest [html]
!item [GFA-Basic]
!begin_raw
<A HREF="http://www.milanstation.de/at/gfahutil/gfau7gd.htm">GFA-H-Util GEMDOS</A>
!end_raw
!endif
(!ende_liste)
!end_node
!end_node


!begin_node Sysconf
(!begin_liste) [Beschreibung:]
!item [Name:]
ØSysconfÆ - Informationen Åber die Konfiguration des Betriebssystems
ermitteln.
!item [Gemdosnummer:]
290
!item [Binding:]
(!link [Bindings fÅr Sysconf] [Bindings fÅr Sysconf])
!item [Beschreibung:]
Die Funktion liefert Informationen Åber die Mîglichkeiten (bzw. die
Konfiguration) des Betriebssystems. öber den Parameter (!I)n(!i) lassen sich
die verschiedenen Werte abfragen:
!begin_xlist !short [-1]
!item [n]
Bedeutung
!item [~]
~
!item [-1]
max. legaler Wert fÅr Sysconf selbst.
!item [0]
max. Wert von Speicherbereichen pro Prozeû.
!item [1]
max. LÑnge der Kommandozeile fÅr Pexec.
!item [2]
max. Anzahl offener Dateien pro Prozess.
!item [3]
max. Anzahl der Supplementary-Groups pro Prozess.
!item [4]
max. Anzahl der Prozesse je Benutzer.
!end_xlist
Ein RÅckgabewert von 0xfffffff (2^31 - 1) bedeutet, daû der entsprechende
Wert unbegrenzt ist.

(!B)Achtung:(!b) Diese Funktion ist optional, daher darf ein Aufruf mit
EINVFN beantwortet werden.
!item [Ergebnis:]
Die Funktion liefert die durch den Parameter (!I)n(!i) spezifizierte
Information zurÅck.
!item [Gruppe:]
(!link [Systemfunktionen][Systemfunktionen des GEMDOS])

!item [Querverweis:] Dpathconf
(!ende_liste)


!begin_node Bindings fÅr Sysconf
!ignore_index
(!begin_liste) [Assembler:]
!item [C:]
LONG Sysconf ( WORD n );
!item [Assembler:]
!begin_verbatim
move.w    n,-(sp)      ; Offset 2
move.w    #290,-(sp)   ; Offset 0
trap      #1           ; GEMDOS aufrufen
addq.l    #4,sp        ; Stack korrigieren
!end_verbatim
!ifdest [html]
!item [GFA-Basic]
!begin_raw
<A HREF="http://www.milanstation.de/at/gfahutil/gfau7gd.htm">GFA-H-Util GEMDOS</A>
!end_raw
!endif
(!ende_liste)
!end_node
!end_node

